diff --git a/drivers/staging/wilc1000/Kconfig b/drivers/staging/wilc1000/Kconfig
index 73f7fefd3bc3..ae671c0f8b22 100644
--- a/drivers/staging/wilc1000/Kconfig
+++ b/drivers/staging/wilc1000/Kconfig
@@ -1,42 +1,52 @@
-config WILC1000
+config WILC
 	tristate
-	---help---
-	  This module only support IEEE 802.11n WiFi.
 
-config WILC1000_SDIO
-	tristate "Atmel WILC1000 SDIO (WiFi only)"
+config WLAN_VENDOR_MCHP
+        bool "Microhip devices"
+        default y
+	help
+	This adds support for WILC1000 & WILC3000 chips which support
+	IEEE 802.11n WiFi. WILC3000 is a WiFi-BT combo chip.
+
+if WLAN_VENDOR_MCHP
+
+config WILC_SDIO
+	tristate "WILC SDIO"
 	depends on CFG80211 && INET && MMC
-	select WILC1000
-	---help---
+	select WILC
+	help
 	  This module adds support for the SDIO interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
 	  It meets SDIO card specification version 2.0. The interface supports
 	  the 1-bit/4-bit SD transfer mode at the clock range of 0-50 MHz.
 	  The host can use this interface to read and write from any register
 	  within the chip as well as configure the WILC1000 for data DMA.
 	  To use this interface, pin9 (SDIO_SPI_CFG) must be grounded. Select
 	  this if your platform is using the SDIO bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_SPI
-	tristate "Atmel WILC1000 SPI (WiFi only)"
+config WILC_SPI
+	tristate "WILC SPI"
 	depends on CFG80211 && INET && SPI
-	select WILC1000
-	---help---
+	select WILC
+	help
 	  This module adds support for the SPI interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 has a Serial Peripheral
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 has a Serial Peripheral
 	  Interface (SPI) that operates as a SPI slave. This SPI interface can
 	  be used for control and for serial I/O of 802.11 data. The SPI is a
 	  full-duplex slave synchronous serial interface that is available
 	  immediately following reset when pin 9 (SDIO_SPI_CFG) is tied to
 	  VDDIO. Select this if your platform is using the SPI bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_HW_OOB_INTR
-	bool "WILC1000 out of band interrupt"
-	depends on WILC1000_SDIO
+config WILC_HW_OOB_INTR
+	bool "WILC out of band interrupt"
+	depends on WILC_SDIO
 	default n
-	---help---
-	  This option enables out-of-band interrupt support for the WILC1000
-	  chipset. This OOB interrupt is intended to provide a faster interrupt
-	  mechanism for SDIO host controllers that don't support SDIO interrupt.
-	  Select this option If the SDIO host controller in your platform
-	  doesn't support SDIO time devision interrupt.
+	help
+	  This option enables out-of-band interrupt support for the WILC1000 &
+	  WILC3000 chipset. This OOB interrupt is intended to provide a faster
+	  interrupt mechanism for SDIO host controllers that don't support SDIO
+	  interrupt. Select this option If the SDIO host controller in your
+	  platform doesn't support SDIO time devision interrupt.
+endif
diff --git a/drivers/staging/wilc1000/Makefile b/drivers/staging/wilc1000/Makefile
index ee7e26b886a5..f29f1cf42836 100644
--- a/drivers/staging/wilc1000/Makefile
+++ b/drivers/staging/wilc1000/Makefile
@@ -1,18 +1,15 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000) += wilc1000.o
-
-ccflags-y += -DFIRMWARE_1002=\"atmel/wilc1002_firmware.bin\" \
-		-DFIRMWARE_1003=\"atmel/wilc1003_firmware.bin\"
-
 ccflags-y += -I$(src)/ -DWILC_ASIC_A0 -DWILC_DEBUGFS
+ccflags-y += -DDISABLE_PWRSAVE_AND_SCAN_DURING_IP
 
-wilc1000-objs := wilc_wfi_cfgoperations.o linux_wlan.o linux_mon.o \
-			coreconfigurator.o host_interface.o \
-			wilc_wlan_cfg.o wilc_debugfs.o \
-			wilc_wlan.o
+wilc-objs := wilc_wfi_cfgoperations.o linux_wlan.o linux_mon.o \
+			host_interface.o wilc_wlan_cfg.o wilc_debugfs.o \
+			wilc_wlan.o sysfs.o wilc_bt.o
 
-obj-$(CONFIG_WILC1000_SDIO) += wilc1000-sdio.o
-wilc1000-sdio-objs += wilc_sdio.o
+obj-$(CONFIG_WILC_SDIO) += wilc-sdio.o
+wilc-sdio-objs += $(wilc-objs)
+wilc-sdio-objs += wilc_sdio.o
 
-obj-$(CONFIG_WILC1000_SPI) += wilc1000-spi.o
-wilc1000-spi-objs += wilc_spi.o
+obj-$(CONFIG_WILC_SPI) += wilc-spi.o
+wilc-spi-objs += $(wilc-objs)
+wilc-spi-objs += wilc_spi.o 
diff --git a/drivers/staging/wilc1000/TODO b/drivers/staging/wilc1000/TODO
deleted file mode 100644
index ae61b55f14fd..000000000000
--- a/drivers/staging/wilc1000/TODO
+++ /dev/null
@@ -1,18 +0,0 @@
-TODO:
-- remove the defined feature as kernel versions
-- remove OS wrapper functions
-- remove custom debug and tracing functions
-- rework comments and function headers(also coding style)
-- Move handling for each individual members of 'union message_body' out
-  into a separate 'struct work_struct' and completely remove the multiplexer
-  that is currently part of host_if_work(), allowing movement of the
-  implementation of each message handler into the callsite of the function
-  that currently queues the 'host_if_msg'.
-- make spi and sdio components coexist in one build
-- turn compile-time platform configuration (BEAGLE_BOARD,
-  PANDA_BOARD, PLAT_WMS8304, PLAT_RKXXXX, CUSTOMER_PLATFORM, ...)
-  into run-time options that are read from DT
-- support soft-ap and p2p mode
-- support resume/suspend function
-- replace SIOCDEVPRIVATE commands with generic API functions
-- use wext-core handling instead of private SIOCSIWPRIV implementation
diff --git a/drivers/staging/wilc1000/coreconfigurator.c b/drivers/staging/wilc1000/coreconfigurator.c
deleted file mode 100644
index 8cf886d32afb..000000000000
--- a/drivers/staging/wilc1000/coreconfigurator.c
+++ /dev/null
@@ -1,388 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include "coreconfigurator.h"
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-#include <linux/errno.h>
-#include <linux/slab.h>
-#define TAG_PARAM_OFFSET	(MAC_HDR_LEN + TIME_STAMP_LEN + \
-				 BEACON_INTERVAL_LEN + CAP_INFO_LEN)
-
-enum basic_frame_type {
-	FRAME_TYPE_CONTROL     = 0x04,
-	FRAME_TYPE_DATA        = 0x08,
-	FRAME_TYPE_MANAGEMENT  = 0x00,
-	FRAME_TYPE_RESERVED    = 0x0C,
-	FRAME_TYPE_FORCE_32BIT = 0xFFFFFFFF
-};
-
-enum sub_frame_type {
-	ASSOC_REQ             = 0x00,
-	ASSOC_RSP             = 0x10,
-	REASSOC_REQ           = 0x20,
-	REASSOC_RSP           = 0x30,
-	PROBE_REQ             = 0x40,
-	PROBE_RSP             = 0x50,
-	BEACON                = 0x80,
-	ATIM                  = 0x90,
-	DISASOC               = 0xA0,
-	AUTH                  = 0xB0,
-	DEAUTH                = 0xC0,
-	ACTION                = 0xD0,
-	PS_POLL               = 0xA4,
-	RTS                   = 0xB4,
-	CTS                   = 0xC4,
-	ACK                   = 0xD4,
-	CFEND                 = 0xE4,
-	CFEND_ACK             = 0xF4,
-	DATA                  = 0x08,
-	DATA_ACK              = 0x18,
-	DATA_POLL             = 0x28,
-	DATA_POLL_ACK         = 0x38,
-	NULL_FRAME            = 0x48,
-	CFACK                 = 0x58,
-	CFPOLL                = 0x68,
-	CFPOLL_ACK            = 0x78,
-	QOS_DATA              = 0x88,
-	QOS_DATA_ACK          = 0x98,
-	QOS_DATA_POLL         = 0xA8,
-	QOS_DATA_POLL_ACK     = 0xB8,
-	QOS_NULL_FRAME        = 0xC8,
-	QOS_CFPOLL            = 0xE8,
-	QOS_CFPOLL_ACK        = 0xF8,
-	BLOCKACK_REQ          = 0x84,
-	BLOCKACK              = 0x94,
-	FRAME_SUBTYPE_FORCE_32BIT  = 0xFFFFFFFF
-};
-
-enum info_element_id {
-	ISSID               = 0,   /* Service Set Identifier         */
-	ISUPRATES           = 1,   /* Supported Rates                */
-	IFHPARMS            = 2,   /* FH parameter set               */
-	IDSPARMS            = 3,   /* DS parameter set               */
-	ICFPARMS            = 4,   /* CF parameter set               */
-	ITIM                = 5,   /* Traffic Information Map        */
-	IIBPARMS            = 6,   /* IBSS parameter set             */
-	ICOUNTRY            = 7,   /* Country element                */
-	IEDCAPARAMS         = 12,  /* EDCA parameter set             */
-	ITSPEC              = 13,  /* Traffic Specification          */
-	ITCLAS              = 14,  /* Traffic Classification         */
-	ISCHED              = 15,  /* Schedule                       */
-	ICTEXT              = 16,  /* Challenge Text                 */
-	IPOWERCONSTRAINT    = 32,  /* Power Constraint               */
-	IPOWERCAPABILITY    = 33,  /* Power Capability               */
-	ITPCREQUEST         = 34,  /* TPC Request                    */
-	ITPCREPORT          = 35,  /* TPC Report                     */
-	ISUPCHANNEL         = 36,  /* Supported channel list         */
-	ICHSWANNOUNC        = 37,  /* Channel Switch Announcement    */
-	IMEASUREMENTREQUEST = 38,  /* Measurement request            */
-	IMEASUREMENTREPORT  = 39,  /* Measurement report             */
-	IQUIET              = 40,  /* Quiet element Info             */
-	IIBSSDFS            = 41,  /* IBSS DFS                       */
-	IERPINFO            = 42,  /* ERP Information                */
-	ITSDELAY            = 43,  /* TS Delay                       */
-	ITCLASPROCESS       = 44,  /* TCLAS Processing               */
-	IHTCAP              = 45,  /* HT Capabilities                */
-	IQOSCAP             = 46,  /* QoS Capability                 */
-	IRSNELEMENT         = 48,  /* RSN Information Element        */
-	IEXSUPRATES         = 50,  /* Extended Supported Rates       */
-	IEXCHSWANNOUNC      = 60,  /* Extended Ch Switch Announcement*/
-	IHTOPERATION        = 61,  /* HT Information                 */
-	ISECCHOFF           = 62,  /* Secondary Channel Offeset      */
-	I2040COEX           = 72,  /* 20/40 Coexistence IE           */
-	I2040INTOLCHREPORT  = 73,  /* 20/40 Intolerant channel report*/
-	IOBSSSCAN           = 74,  /* OBSS Scan parameters           */
-	IEXTCAP             = 127, /* Extended capability            */
-	IWMM                = 221, /* WMM parameters                 */
-	IWPAELEMENT         = 221, /* WPA Information Element        */
-	INFOELEM_ID_FORCE_32BIT  = 0xFFFFFFFF
-};
-
-static inline u16 get_beacon_period(u8 *data)
-{
-	u16 bcn_per;
-
-	bcn_per  = data[0];
-	bcn_per |= (data[1] << 8);
-
-	return bcn_per;
-}
-
-static inline u32 get_beacon_timestamp_lo(u8 *data)
-{
-	u32 time_stamp = 0;
-	u32 index    = MAC_HDR_LEN;
-
-	time_stamp |= data[index++];
-	time_stamp |= (data[index++] << 8);
-	time_stamp |= (data[index++] << 16);
-	time_stamp |= (data[index]   << 24);
-
-	return time_stamp;
-}
-
-static inline u32 get_beacon_timestamp_hi(u8 *data)
-{
-	u32 time_stamp = 0;
-	u32 index    = (MAC_HDR_LEN + 4);
-
-	time_stamp |= data[index++];
-	time_stamp |= (data[index++] << 8);
-	time_stamp |= (data[index++] << 16);
-	time_stamp |= (data[index]   << 24);
-
-	return time_stamp;
-}
-
-static inline enum sub_frame_type get_sub_type(u8 *header)
-{
-	return ((enum sub_frame_type)(header[0] & 0xFC));
-}
-
-static inline u8 get_to_ds(u8 *header)
-{
-	return (header[1] & 0x01);
-}
-
-static inline u8 get_from_ds(u8 *header)
-{
-	return ((header[1] & 0x02) >> 1);
-}
-
-static inline void get_address1(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 4, 6);
-}
-
-static inline void get_address2(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 10, 6);
-}
-
-static inline void get_address3(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 16, 6);
-}
-
-static inline void get_BSSID(u8 *data, u8 *bssid)
-{
-	if (get_from_ds(data) == 1)
-		get_address2(data, bssid);
-	else if (get_to_ds(data) == 1)
-		get_address1(data, bssid);
-	else
-		get_address3(data, bssid);
-}
-
-static inline void get_ssid(u8 *data, u8 *ssid, u8 *p_ssid_len)
-{
-	u8 len = 0;
-	u8 i   = 0;
-	u8 j   = 0;
-
-	len = data[TAG_PARAM_OFFSET + 1];
-	j   = TAG_PARAM_OFFSET + 2;
-
-	if (len >= MAX_SSID_LEN)
-		len = 0;
-
-	for (i = 0; i < len; i++, j++)
-		ssid[i] = data[j];
-
-	ssid[len] = '\0';
-
-	*p_ssid_len = len;
-}
-
-static inline u16 get_cap_info(u8 *data)
-{
-	u16 cap_info = 0;
-	u16 index    = MAC_HDR_LEN;
-	enum sub_frame_type st;
-
-	st = get_sub_type(data);
-
-	if ((st == BEACON) || (st == PROBE_RSP))
-		index += TIME_STAMP_LEN + BEACON_INTERVAL_LEN;
-
-	cap_info  = data[index];
-	cap_info |= (data[index + 1] << 8);
-
-	return cap_info;
-}
-
-static inline u16 get_assoc_resp_cap_info(u8 *data)
-{
-	u16 cap_info;
-
-	cap_info  = data[0];
-	cap_info |= (data[1] << 8);
-
-	return cap_info;
-}
-
-static inline u16 get_asoc_status(u8 *data)
-{
-	u16 asoc_status;
-
-	asoc_status = data[3];
-	return (asoc_status << 8) | data[2];
-}
-
-static inline u16 get_asoc_id(u8 *data)
-{
-	u16 asoc_id;
-
-	asoc_id  = data[4];
-	asoc_id |= (data[5] << 8);
-
-	return asoc_id;
-}
-
-static u8 *get_tim_elm(u8 *pu8msa, u16 rx_len, u16 tag_param_offset)
-{
-	u16 index;
-
-	index = tag_param_offset;
-
-	while (index < (rx_len - FCS_LEN)) {
-		if (pu8msa[index] == ITIM)
-			return &pu8msa[index];
-		index += (IE_HDR_LEN + pu8msa[index + 1]);
-	}
-
-	return NULL;
-}
-
-static u8 get_current_channel_802_11n(u8 *pu8msa, u16 rx_len)
-{
-	u16 index;
-
-	index = TAG_PARAM_OFFSET;
-	while (index < (rx_len - FCS_LEN)) {
-		if (pu8msa[index] == IDSPARMS)
-			return pu8msa[index + 2];
-		index += pu8msa[index + 1] + IE_HDR_LEN;
-	}
-
-	return 0;
-}
-
-s32 wilc_parse_network_info(u8 *msg_buffer,
-			    struct network_info **ret_network_info)
-{
-	struct network_info *network_info = NULL;
-	u8 msg_type = 0;
-	u8 msg_id = 0;
-	u16 msg_len = 0;
-
-	u16 wid_id = (u16)WID_NIL;
-	u16 wid_len  = 0;
-	u8 *wid_val = NULL;
-
-	msg_type = msg_buffer[0];
-
-	if ('N' != msg_type)
-		return -EFAULT;
-
-	msg_id = msg_buffer[1];
-	msg_len = MAKE_WORD16(msg_buffer[2], msg_buffer[3]);
-	wid_id = MAKE_WORD16(msg_buffer[4], msg_buffer[5]);
-	wid_len = MAKE_WORD16(msg_buffer[6], msg_buffer[7]);
-	wid_val = &msg_buffer[8];
-
-	{
-		u8 *msa = NULL;
-		u16 rx_len = 0;
-		u8 *tim_elm = NULL;
-		u8 *ies = NULL;
-		u16 ies_len = 0;
-		u8 index = 0;
-		u32 tsf_lo;
-		u32 tsf_hi;
-
-		network_info = kzalloc(sizeof(*network_info), GFP_KERNEL);
-		if (!network_info)
-			return -ENOMEM;
-
-		network_info->rssi = wid_val[0];
-
-		msa = &wid_val[1];
-
-		rx_len = wid_len - 1;
-		network_info->cap_info = get_cap_info(msa);
-		network_info->tsf_lo = get_beacon_timestamp_lo(msa);
-
-		tsf_lo = get_beacon_timestamp_lo(msa);
-		tsf_hi = get_beacon_timestamp_hi(msa);
-
-		network_info->tsf_hi = tsf_lo | ((u64)tsf_hi << 32);
-
-		get_ssid(msa, network_info->ssid, &network_info->ssid_len);
-		get_BSSID(msa, network_info->bssid);
-
-		network_info->ch = get_current_channel_802_11n(msa,
-							rx_len + FCS_LEN);
-
-		index = MAC_HDR_LEN + TIME_STAMP_LEN;
-
-		network_info->beacon_period = get_beacon_period(msa + index);
-
-		index += BEACON_INTERVAL_LEN + CAP_INFO_LEN;
-
-		tim_elm = get_tim_elm(msa, rx_len + FCS_LEN, index);
-		if (tim_elm)
-			network_info->dtim_period = tim_elm[3];
-		ies = &msa[TAG_PARAM_OFFSET];
-		ies_len = rx_len - TAG_PARAM_OFFSET;
-
-		if (ies_len > 0) {
-			network_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-			if (!network_info->ies) {
-				kfree(network_info);
-				return -ENOMEM;
-			}
-		}
-		network_info->ies_len = ies_len;
-	}
-
-	*ret_network_info = network_info;
-
-	return 0;
-}
-
-s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
-			       struct connect_resp_info **ret_connect_resp_info)
-{
-	struct connect_resp_info *connect_resp_info = NULL;
-	u16 assoc_resp_len = 0;
-	u8 *ies = NULL;
-	u16 ies_len = 0;
-
-	connect_resp_info = kzalloc(sizeof(*connect_resp_info), GFP_KERNEL);
-	if (!connect_resp_info)
-		return -ENOMEM;
-
-	assoc_resp_len = (u16)buffer_len;
-
-	connect_resp_info->status = get_asoc_status(buffer);
-	if (connect_resp_info->status == SUCCESSFUL_STATUSCODE) {
-		connect_resp_info->capability = get_assoc_resp_cap_info(buffer);
-		connect_resp_info->assoc_id = get_asoc_id(buffer);
-
-		ies = &buffer[CAP_INFO_LEN + STATUS_CODE_LEN + AID_LEN];
-		ies_len = assoc_resp_len - (CAP_INFO_LEN + STATUS_CODE_LEN +
-					    AID_LEN);
-
-		connect_resp_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-		if (!connect_resp_info->ies) {
-			kfree(connect_resp_info);
-			return -ENOMEM;
-		}
-
-		connect_resp_info->ies_len = ies_len;
-	}
-
-	*ret_connect_resp_info = connect_resp_info;
-
-	return 0;
-}
diff --git a/drivers/staging/wilc1000/coreconfigurator.h b/drivers/staging/wilc1000/coreconfigurator.h
deleted file mode 100644
index 3f5da8c58815..000000000000
--- a/drivers/staging/wilc1000/coreconfigurator.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/*!
- *  @file	coreconfigurator.h
- *  @brief
- *  @author
- *  @sa		coreconfigurator.c
- *  @date	1 Mar 2012
- *  @version	1.0
- */
-
-#ifndef CORECONFIGURATOR_H
-#define CORECONFIGURATOR_H
-
-#include "wilc_wlan_if.h"
-
-#define NUM_BASIC_SWITCHES      45
-#define NUM_FHSS_SWITCHES       0
-
-#define NUM_RSSI                5
-
-#ifdef MAC_802_11N
-#define NUM_11N_BASIC_SWITCHES  25
-#define NUM_11N_HUT_SWITCHES    47
-#else
-#define NUM_11N_BASIC_SWITCHES  0
-#define NUM_11N_HUT_SWITCHES    0
-#endif
-
-#define MAC_HDR_LEN             24
-#define MAX_SSID_LEN            33
-#define FCS_LEN                 4
-#define TIME_STAMP_LEN          8
-#define BEACON_INTERVAL_LEN     2
-#define CAP_INFO_LEN            2
-#define STATUS_CODE_LEN         2
-#define AID_LEN                 2
-#define IE_HDR_LEN              2
-
-#define SET_CFG              0
-#define GET_CFG              1
-
-#define MAX_STRING_LEN               256
-#define MAX_SURVEY_RESULT_FRAG_SIZE  MAX_STRING_LEN
-#define SURVEY_RESULT_LENGTH         44
-#define MAX_ASSOC_RESP_FRAME_SIZE    MAX_STRING_LEN
-
-#define MAC_CONNECTED                1
-#define MAC_DISCONNECTED             0
-
-#define MAKE_WORD16(lsb, msb) ((((u16)(msb) << 8) & 0xFF00) | (lsb))
-#define MAKE_WORD32(lsw, msw) ((((u32)(msw) << 16) & 0xFFFF0000) | (lsw))
-
-enum connect_status {
-	SUCCESSFUL_STATUSCODE    = 0,
-	UNSPEC_FAIL              = 1,
-	UNSUP_CAP                = 10,
-	REASOC_NO_ASOC           = 11,
-	FAIL_OTHER               = 12,
-	UNSUPT_ALG               = 13,
-	AUTH_SEQ_FAIL            = 14,
-	CHLNG_FAIL               = 15,
-	AUTH_TIMEOUT             = 16,
-	AP_FULL                  = 17,
-	UNSUP_RATE               = 18,
-	SHORT_PREAMBLE_UNSUP     = 19,
-	PBCC_UNSUP               = 20,
-	CHANNEL_AGIL_UNSUP       = 21,
-	SHORT_SLOT_UNSUP         = 25,
-	OFDM_DSSS_UNSUP          = 26,
-	CONNECT_STS_FORCE_16_BIT = 0xFFFF
-};
-
-struct rssi_history_buffer {
-	bool full;
-	u8 index;
-	s8 samples[NUM_RSSI];
-};
-
-struct network_info {
-	s8 rssi;
-	u16 cap_info;
-	u8 ssid[MAX_SSID_LEN];
-	u8 ssid_len;
-	u8 bssid[6];
-	u16 beacon_period;
-	u8 dtim_period;
-	u8 ch;
-	unsigned long time_scan_cached;
-	unsigned long time_scan;
-	bool new_network;
-	u8 found;
-	u32 tsf_lo;
-	u8 *ies;
-	u16 ies_len;
-	void *join_params;
-	struct rssi_history_buffer rssi_history;
-	u64 tsf_hi;
-};
-
-struct connect_resp_info {
-	u16 capability;
-	u16 status;
-	u16 assoc_id;
-	u8 *ies;
-	u16 ies_len;
-};
-
-struct connect_info {
-	u8 bssid[6];
-	u8 *req_ies;
-	size_t req_ies_len;
-	u8 *resp_ies;
-	u16 resp_ies_len;
-	u16 status;
-};
-
-struct disconnect_info {
-	u16 reason;
-	u8 *ie;
-	size_t ie_len;
-};
-
-s32 wilc_parse_network_info(u8 *msg_buffer,
-			    struct network_info **ret_network_info);
-s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
-			       struct connect_resp_info **ret_connect_resp_info);
-void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length);
-void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length);
-void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length);
-#endif
diff --git a/drivers/staging/wilc1000/host_interface.c b/drivers/staging/wilc1000/host_interface.c
index 421168b9a9ca..3995b1feec19 100644
--- a/drivers/staging/wilc1000/host_interface.c
+++ b/drivers/staging/wilc1000/host_interface.c
@@ -1,65 +1,54 @@
 // SPDX-License-Identifier: GPL-2.0
-#include <linux/slab.h>
-#include <linux/time.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/completion.h>
-#include <linux/list.h>
-#include <linux/workqueue.h>
-#include "host_interface.h"
-#include <linux/spinlock.h>
-#include <linux/errno.h>
-#include "coreconfigurator.h"
-#include "wilc_wlan.h"
-#include "wilc_wlan_if.h"
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
 #include <linux/etherdevice.h>
-#include "wilc_wfi_netdevice.h"
 
-#define HOST_IF_MSG_SCAN                        0
-#define HOST_IF_MSG_CONNECT                     1
-#define HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO        2
-#define HOST_IF_MSG_KEY                         3
-#define HOST_IF_MSG_RCVD_NTWRK_INFO             4
-#define HOST_IF_MSG_RCVD_SCAN_COMPLETE          5
-#define HOST_IF_MSG_CFG_PARAMS                  6
-#define HOST_IF_MSG_SET_CHANNEL                 7
-#define HOST_IF_MSG_DISCONNECT                  8
-#define HOST_IF_MSG_GET_RSSI                    9
-#define HOST_IF_MSG_ADD_BEACON                  11
-#define HOST_IF_MSG_DEL_BEACON                  12
-#define HOST_IF_MSG_ADD_STATION                 13
-#define HOST_IF_MSG_DEL_STATION                 14
-#define HOST_IF_MSG_EDIT_STATION                15
-#define HOST_IF_MSG_SCAN_TIMER_FIRED            16
-#define HOST_IF_MSG_CONNECT_TIMER_FIRED         17
-#define HOST_IF_MSG_POWER_MGMT                  18
-#define HOST_IF_MSG_GET_INACTIVETIME            19
-#define HOST_IF_MSG_REMAIN_ON_CHAN              20
-#define HOST_IF_MSG_REGISTER_FRAME              21
-#define HOST_IF_MSG_LISTEN_TIMER_FIRED          22
-#define HOST_IF_MSG_SET_WFIDRV_HANDLER          24
-#define HOST_IF_MSG_GET_MAC_ADDRESS             26
-#define HOST_IF_MSG_SET_OPERATION_MODE          27
-#define HOST_IF_MSG_SET_IPADDRESS               28
-#define HOST_IF_MSG_GET_IPADDRESS               29
-#define HOST_IF_MSG_GET_STATISTICS              31
-#define HOST_IF_MSG_SET_MULTICAST_FILTER        32
-#define HOST_IF_MSG_DEL_BA_SESSION              34
-#define HOST_IF_MSG_DEL_ALL_STA                 36
-#define HOST_IF_MSG_SET_TX_POWER		38
-#define HOST_IF_MSG_GET_TX_POWER		39
-#define HOST_IF_MSG_EXIT                        100
+#include "wilc_wfi_netdevice.h"
+#include "linux_wlan.h"
+#include "wilc_wfi_cfgoperations.h"
 
 #define HOST_IF_SCAN_TIMEOUT                    4000
 #define HOST_IF_CONNECT_TIMEOUT                 9500
 
-#define BA_SESSION_DEFAULT_BUFFER_SIZE          16
-#define BA_SESSION_DEFAULT_TIMEOUT              1000
-#define BLOCK_ACK_REQ_SIZE                      0x14
 #define FALSE_FRMWR_CHANNEL			100
 
-#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
-#define DEFAULT_LINK_SPEED			72
+#define REAL_JOIN_REQ				0
+
+#define INVALID_RSSI				100
+
+/* Generic success will return 0 */
+#define WILC_SUCCESS		0	/* Generic success */
+
+/* Negative numbers to indicate failures */
+/* Generic Fail */
+#define	WILC_FAIL		-100
+/* Busy with another operation*/
+#define	WILC_BUSY		-101
+/* A given argument is invalid*/
+#define	WILC_INVALID_ARGUMENT	-102
+/* An API request would violate the Driver state machine
+ * (i.e. to start PID while not camped)
+ */
+#define	WILC_INVALID_STATE	-103
+/* In copy operations if the copied data is larger than the allocated buffer*/
+#define	WILC_BUFFER_OVERFLOW	-104
+/* null pointer is passed or used */
+#define WILC_NULL_PTR		-105
+#define	WILC_EMPTY		-107
+#define WILC_FULL		-108
+#define	WILC_TIMEOUT		-109
+/* The required operation have been canceled by the user*/
+#define WILC_CANCELED		-110
+/* The Loaded file is corruped or having an invalid format */
+#define WILC_INVALID_FILE	-112
+/* Cant find the file to load */
+#define WILC_NOT_FOUND		-113
+#define WILC_NO_MEM		-114
+#define WILC_UNSUPPORTED_VERSION -115
+#define WILC_FILE_EOF		-116
 
 struct host_if_wpa_attr {
 	u8 *key;
@@ -76,7 +65,7 @@ struct host_if_wep_attr {
 	u8 key_len;
 	u8 index;
 	u8 mode;
-	enum AUTHTYPE auth_type;
+	enum authtype auth_type;
 };
 
 union host_if_key_attr {
@@ -91,6 +80,15 @@ struct key_attr {
 	union host_if_key_attr attr;
 };
 
+struct send_buffered_eap {
+	wilc_frmw_to_linux_t frmw_to_linux;
+	free_eap_buf_param eap_buf_param;
+	u8 *buff;
+	unsigned int size;
+	unsigned int pkt_offset;
+	void *user_arg;
+};
+
 struct scan_attr {
 	u8 src;
 	u8 type;
@@ -112,7 +110,7 @@ struct connect_attr {
 	u8 security;
 	wilc_connect_result result;
 	void *arg;
-	enum AUTHTYPE auth_type;
+	enum authtype auth_type;
 	u8 ch;
 	void *params;
 };
@@ -138,6 +136,7 @@ struct beacon_attr {
 struct set_multicast {
 	bool enabled;
 	u32 cnt;
+	u8 *mc_list;
 };
 
 struct del_all_sta {
@@ -154,19 +153,30 @@ struct power_mgmt_param {
 	u32 timeout;
 };
 
-struct set_ip_addr {
-	u8 *ip_addr;
-	u8 idx;
-};
-
 struct sta_inactive_t {
+	u32 inactive_time;
 	u8 mac[6];
 };
 
+struct host_if_wowlan_trigger {
+	u8 wowlan_trigger;
+};
+
 struct tx_power {
 	u8 tx_pwr;
 };
 
+struct bt_coex_mode {
+	u8 bt_coex;
+};
+
+struct host_if_set_ant {
+	u8 mode;
+	u8 antenna1;
+	u8 antenna2;
+	u8 gpio_mode;
+};
+
 union message_body {
 	struct scan_attr scan_info;
 	struct connect_attr con_info;
@@ -181,28 +191,33 @@ union message_body {
 	struct add_sta_param edit_sta_info;
 	struct power_mgmt_param pwr_mgmt_info;
 	struct sta_inactive_t mac_info;
-	struct set_ip_addr ip_info;
 	struct drv_handler drv;
 	struct set_multicast multicast_info;
 	struct op_mode mode;
-	struct get_mac_addr get_mac_info;
+	struct dev_mac_addr dev_mac_info;
 	struct ba_session_info session_info;
 	struct remain_ch remain_on_ch;
 	struct reg_frame reg_frame;
 	char *data;
 	struct del_all_sta del_all_sta_info;
+	struct send_buffered_eap send_buff_eap;
 	struct tx_power tx_power;
+	struct host_if_set_ant set_ant;
+	struct host_if_wowlan_trigger wow_trigger;
+	struct bt_coex_mode bt_coex_mode;
 };
 
 struct host_if_msg {
-	u16 id;
 	union message_body body;
 	struct wilc_vif *vif;
 	struct work_struct work;
+	void (*fn)(struct work_struct *ws);
+	struct completion work_comp;
+	bool is_sync;
 };
 
 struct join_bss_param {
-	BSSTYPE_T bss_type;
+	enum bss_types bss_type;
 	u8 dtim_period;
 	u16 beacon_period;
 	u16 cap_info;
@@ -231,64 +246,44 @@ struct join_bss_param {
 };
 
 static struct host_if_drv *terminated_handle;
-bool wilc_optaining_ip;
-static u8 P2P_LISTEN_STATE;
-static struct workqueue_struct *hif_workqueue;
-static struct completion hif_thread_comp;
-static struct completion hif_driver_comp;
-static struct completion hif_wait_response;
 static struct mutex hif_deinit_lock;
-static struct timer_list periodic_rssi;
-
-u8 wilc_multicast_mac_addr_list[WILC_MULTICAST_TABLE_SIZE][ETH_ALEN];
-
-static u8 rcv_assoc_resp[MAX_ASSOC_RESP_FRAME_SIZE];
-
-static bool scan_while_connected;
-
-static s8 rssi;
-static u8 set_ip[2][4];
-static u8 get_ip[2][4];
-static u32 inactive_time;
-static u8 del_beacon;
-static u32 clients_count;
-
-static u8 *join_req;
-static u8 *info_element;
-static u8 mode_11i;
-static u8 auth_type;
-static u32 join_req_size;
-static u32 info_element_size;
-static struct wilc_vif *join_req_vif;
-#define REAL_JOIN_REQ 0
-#define FLUSHED_JOIN_REQ 1
-#define FLUSHED_BYTE_POS 79
-
-static void *host_int_ParseJoinBssParam(struct network_info *ptstrNetworkInfo);
-static int host_int_get_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx);
-static s32 Handle_ScanDone(struct wilc_vif *vif, enum scan_event enuEvent);
-static void host_if_work(struct work_struct *work);
-
-/*!
- *  @author		syounan
- *  @date		1 Sep 2010
- *  @note		copied from FLO glue implementatuion
- *  @version		1.0
- */
-static int wilc_enqueue_cmd(struct host_if_msg *msg)
+
+/* 'msg' should be free by the caller for syc */
+static struct host_if_msg*
+wilc_alloc_work(struct wilc_vif *vif, void (*work_fun)(struct work_struct *),
+		bool is_sync)
 {
-	struct host_if_msg *new_msg;
+	struct host_if_msg *msg;
 
-	new_msg = kmemdup(msg, sizeof(*new_msg), GFP_ATOMIC);
-	if (!new_msg)
-		return -ENOMEM;
+	if (!work_fun)
+		return ERR_PTR(-EINVAL);
+
+	msg = kzalloc(sizeof(*msg), GFP_ATOMIC);
+	if (!msg)
+		return ERR_PTR(-ENOMEM);
+	msg->fn = work_fun;
+	msg->vif = vif;
+	msg->is_sync = is_sync;
+	if (is_sync)
+		init_completion(&msg->work_comp);
+
+	return msg;
+}
+
+static int wilc_enqueue_work(struct host_if_msg *msg)
+{
+	INIT_WORK(&msg->work, msg->fn);
+
+	if (!msg->vif || !msg->vif->wilc || !msg->vif->wilc->hif_workqueue)
+		return -EINVAL;
+
+	if (!queue_work(msg->vif->wilc->hif_workqueue, &msg->work))
+		return -EINVAL;
 
-	INIT_WORK(&new_msg->work, host_if_work);
-	queue_work(hif_workqueue, &new_msg->work);
 	return 0;
 }
 
-/* The u8IfIdx starts from 0 to NUM_CONCURRENT_IFC -1, but 0 index used as
+/* The idx starts from 0 to (NUM_CONCURRENT_IFC - 1), but 0 index used as
  * special purpose in wilc device, so we add 1 to the index to starts from 1.
  * As a result, the returned index will be 1 to NUM_CONCURRENT_IFC.
  */
@@ -300,7 +295,7 @@ int wilc_get_vif_idx(struct wilc_vif *vif)
 /* We need to minus 1 from idx which is from wilc device to get real index
  * of wilc->vif[], because we add 1 when pass to wilc device in the function
  * wilc_get_vif_idx.
- * As a result, the index should be between 0 and NUM_CONCURRENT_IFC -1.
+ * As a result, the index should be between 0 and (NUM_CONCURRENT_IFC - 1).
  */
 static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
 {
@@ -312,13 +307,79 @@ static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
 	return wilc->vif[index];
 }
 
-static void handle_set_channel(struct wilc_vif *vif,
-			       struct channel_attr *hif_set_ch)
+void filter_shadow_scan(struct wilc_priv *priv, u8 *ch_freq_list,
+			u8 ch_list_len)
+{
+	int i;
+	int ch_index;
+	int j;
+	struct network_info *net_info;
+
+	if (ch_list_len == 0)
+		return;
+
+	for (i = 0; i < priv->scanned_cnt;) {
+		net_info = &priv->scanned_shadow[i];
+
+		for (ch_index = 0; ch_index < ch_list_len; ch_index++)
+			if (net_info->ch == (ch_freq_list[ch_index] + 1))
+				break;
+
+		/* filter only un-matched channels */
+		if (ch_index != ch_list_len) {
+			i++;
+			continue;
+		}
+
+		kfree(net_info->ies);
+		net_info->ies = NULL;
+
+		kfree(net_info->join_params);
+		net_info->join_params = NULL;
+
+		for (j = i; (j < priv->scanned_cnt-1); j++)
+			priv->scanned_shadow[j] = priv->scanned_shadow[j+1];
+
+		priv->scanned_cnt--;
+	}
+}
+
+static void handle_send_buffered_eap(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct send_buffered_eap *hif_buff_eap = &msg->body.send_buff_eap;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending bufferd eapol to WPAS\n");
+	if (!hif_buff_eap->buff)
+		goto out;
+
+	if (hif_buff_eap->frmw_to_linux)
+		hif_buff_eap->frmw_to_linux(vif, hif_buff_eap->buff,
+					    hif_buff_eap->size,
+					    hif_buff_eap->pkt_offset,
+					    PKT_STATUS_BUFFERED);
+	if (hif_buff_eap->eap_buf_param)
+		hif_buff_eap->eap_buf_param(hif_buff_eap->user_arg);
+
+	if (hif_buff_eap->buff != NULL) {
+		kfree(hif_buff_eap->buff);
+		hif_buff_eap->buff = NULL;
+	}
+
+out:
+	kfree(msg);
+}
+
+static void handle_set_channel(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct channel_attr *hif_set_ch = &msg->body.channel_info;
+	int ret;
 	struct wid wid;
 
-	wid.id = (u16)WID_CURRENT_CHANNEL;
+	wid.id = WID_CURRENT_CHANNEL;
 	wid.type = WID_CHAR;
 	wid.val = (char *)&hif_set_ch->set_ch;
 	wid.size = sizeof(char);
@@ -327,31 +388,31 @@ static void handle_set_channel(struct wilc_vif *vif,
 				   wilc_get_vif_idx(vif));
 
 	if (ret)
-		netdev_err(vif->ndev, "Failed to set channel\n");
+		PRINT_ER(vif->ndev, "Failed to set channel\n");
+	kfree(msg);
 }
 
-static int handle_set_wfi_drv_handler(struct wilc_vif *vif,
-				      struct drv_handler *hif_drv_handler)
+static void handle_set_wfi_drv_handler(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct drv_handler *hif_drv_handler = &msg->body.drv;
+	int ret;
 	struct wid wid;
 	u8 *currbyte, *buffer;
-	struct host_if_drv *hif_drv = NULL;
-
-	if (!vif->hif_drv)
-		return -EINVAL;
+	struct host_if_drv *hif_drv;
 
-	if (!hif_drv_handler)
-		return -EINVAL;
+	if (!vif->hif_drv || !hif_drv_handler)
+		goto free_msg;
 
 	hif_drv	= vif->hif_drv;
 
 	buffer = kzalloc(DRV_HANDLER_SIZE, GFP_KERNEL);
 	if (!buffer)
-		return -ENOMEM;
+		goto free_msg;
 
 	currbyte = buffer;
-	*currbyte = hif_drv->driver_handler_id & DRV_HANDLER_MASK;
+	*currbyte = hif_drv_handler->handler & DRV_HANDLER_MASK;
 	currbyte++;
 	*currbyte = (u32)0 & DRV_HANDLER_MASK;
 	currbyte++;
@@ -359,33 +420,34 @@ static int handle_set_wfi_drv_handler(struct wilc_vif *vif,
 	currbyte++;
 	*currbyte = (u32)0 & DRV_HANDLER_MASK;
 	currbyte++;
-	*currbyte = (hif_drv_handler->name | (hif_drv_handler->mode << 1));
+	*currbyte = (hif_drv_handler->ifc_id | (hif_drv_handler->mode << 1));
 
-	wid.id = (u16)WID_SET_DRV_HANDLER;
+	wid.id = WID_SET_DRV_HANDLER;
 	wid.type = WID_STR;
 	wid.val = (s8 *)buffer;
 	wid.size = DRV_HANDLER_SIZE;
 
 	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				   hif_drv->driver_handler_id);
-	if (ret) {
-		netdev_err(vif->ndev, "Failed to set driver handler\n");
-		complete(&hif_driver_comp);
-		kfree(buffer);
-		return ret;
-	}
-	complete(&hif_driver_comp);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set driver handler\n");
 	kfree(buffer);
-	return 0;
+
+free_msg:
+	if (msg->is_sync)
+		complete(&msg->work_comp);
+	kfree(msg);
 }
 
-static void handle_set_operation_mode(struct wilc_vif *vif,
-				      struct op_mode *hif_op_mode)
+static void handle_set_operation_mode(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct op_mode *hif_op_mode = &msg->body.mode;
+	int ret;
 	struct wid wid;
 
-	wid.id = (u16)WID_SET_OPERATION_MODE;
+	wid.id = WID_SET_OPERATION_MODE;
 	wid.type = WID_INT;
 	wid.val = (s8 *)&hif_op_mode->mode;
 	wid.size = sizeof(u32);
@@ -393,345 +455,92 @@ static void handle_set_operation_mode(struct wilc_vif *vif,
 	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				   wilc_get_vif_idx(vif));
 
-	if ((hif_op_mode->mode) == IDLE_MODE)
-		complete(&hif_driver_comp);
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set driver handler\n");
-}
-
-static void handle_set_ip_address(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
-{
-	int ret = 0;
-	struct wid wid;
-	char firmware_ip_addr[4] = {0};
-
-	if (ip_addr[0] < 192)
-		ip_addr[0] = 0;
-
-	memcpy(set_ip[idx], ip_addr, IP_ALEN);
-
-	wid.id = (u16)WID_IP_ADDRESS;
-	wid.type = WID_STR;
-	wid.val = ip_addr;
-	wid.size = IP_ALEN;
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	host_int_get_ipaddress(vif, firmware_ip_addr, idx);
-
 	if (ret)
-		netdev_err(vif->ndev, "Failed to set IP address\n");
+		PRINT_ER(vif->ndev, "Failed to set operation mode\n");
+	kfree(msg);
 }
 
-static void handle_get_ip_address(struct wilc_vif *vif, u8 idx)
+static void handle_get_mac_address(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct dev_mac_addr *dev_mac_addr = &msg->body.dev_mac_info;
+	int ret;
 	struct wid wid;
 
-	wid.id = (u16)WID_IP_ADDRESS;
+	wid.id = WID_MAC_ADDR;
 	wid.type = WID_STR;
-	wid.val = kmalloc(IP_ALEN, GFP_KERNEL);
-	wid.size = IP_ALEN;
+	wid.val = dev_mac_addr->mac_addr;
+	wid.size = ETH_ALEN;
 
 	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
 				   wilc_get_vif_idx(vif));
 
-	memcpy(get_ip[idx], wid.val, IP_ALEN);
-
-	kfree(wid.val);
-
-	if (memcmp(get_ip[idx], set_ip[idx], IP_ALEN) != 0)
-		wilc_setup_ipaddress(vif, set_ip[idx], idx);
-
 	if (ret)
-		netdev_err(vif->ndev, "Failed to get IP address\n");
+		PRINT_ER(vif->ndev, "Failed to get mac address\n");
+	complete(&msg->work_comp);
+	/* free 'msg' in the caller */
 }
 
-static void handle_get_mac_address(struct wilc_vif *vif,
-				   struct get_mac_addr *get_mac_addr)
+static void handle_set_mac_address(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct dev_mac_addr *dev_mac_addr = &msg->body.dev_mac_info;
+	int ret;
 	struct wid wid;
 
-	wid.id = (u16)WID_MAC_ADDR;
+	wid.id = WID_MAC_ADDR;
 	wid.type = WID_STR;
-	wid.val = get_mac_addr->mac_addr;
+	wid.val = dev_mac_addr->mac_addr;
 	wid.size = ETH_ALEN;
 
-	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				   wilc_get_vif_idx(vif));
 
 	if (ret)
-		netdev_err(vif->ndev, "Failed to get mac address\n");
-	complete(&hif_wait_response);
+		PRINT_ER(vif->ndev, "Failed to set mac address\n");
+	complete(&msg->work_comp);
+	/* free 'msg' data later, in caller */
 }
 
-static void handle_cfg_param(struct wilc_vif *vif,
-			     struct cfg_param_attr *cfg_param_attr)
+static void handle_cfg_param(struct work_struct *work)
 {
-	int ret = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct cfg_param_attr *param = &msg->body.cfg_info;
+	int ret;
 	struct wid wid_list[32];
-	struct host_if_drv *hif_drv = vif->hif_drv;
 	int i = 0;
 
-	mutex_lock(&hif_drv->cfg_values_lock);
-
-	if (cfg_param_attr->flag & BSS_TYPE) {
-		u8 bss_type = cfg_param_attr->bss_type;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting CFG params\n");
 
-		if (bss_type < 6) {
-			wid_list[i].id = WID_BSS_TYPE;
-			wid_list[i].val = (s8 *)&bss_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.bss_type = bss_type;
-		} else {
-			netdev_err(vif->ndev, "check value 6 over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & AUTH_TYPE) {
-		if (cfg_param_attr->auth_type == 1 ||
-		    cfg_param_attr->auth_type == 2 ||
-		    cfg_param_attr->auth_type == 5) {
-			wid_list[i].id = WID_AUTH_TYPE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->auth_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.auth_type = (u8)cfg_param_attr->auth_type;
-		} else {
-			netdev_err(vif->ndev, "Impossible value\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & AUTHEN_TIMEOUT) {
-		if (cfg_param_attr->auth_timeout > 0 &&
-		    cfg_param_attr->auth_timeout < 65536) {
-			wid_list[i].id = WID_AUTH_TIMEOUT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->auth_timeout;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.auth_timeout = cfg_param_attr->auth_timeout;
-		} else {
-			netdev_err(vif->ndev, "Range(1 ~ 65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & POWER_MANAGEMENT) {
-		if (cfg_param_attr->power_mgmt_mode < 5) {
-			wid_list[i].id = WID_POWER_MANAGEMENT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->power_mgmt_mode;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.power_mgmt_mode = (u8)cfg_param_attr->power_mgmt_mode;
-		} else {
-			netdev_err(vif->ndev, "Invalid power mode\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & RETRY_SHORT) {
-		if (cfg_param_attr->short_retry_limit > 0 &&
-		    cfg_param_attr->short_retry_limit < 256) {
-			wid_list[i].id = WID_SHORT_RETRY_LIMIT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->short_retry_limit;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.short_retry_limit = cfg_param_attr->short_retry_limit;
-		} else {
-			netdev_err(vif->ndev, "Range(1~256) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & RETRY_LONG) {
-		if (cfg_param_attr->long_retry_limit > 0 &&
-		    cfg_param_attr->long_retry_limit < 256) {
-			wid_list[i].id = WID_LONG_RETRY_LIMIT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->long_retry_limit;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.long_retry_limit = cfg_param_attr->long_retry_limit;
-		} else {
-			netdev_err(vif->ndev, "Range(1~256) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & FRAG_THRESHOLD) {
-		if (cfg_param_attr->frag_threshold > 255 &&
-		    cfg_param_attr->frag_threshold < 7937) {
-			wid_list[i].id = WID_FRAG_THRESHOLD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->frag_threshold;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.frag_threshold = cfg_param_attr->frag_threshold;
-		} else {
-			netdev_err(vif->ndev, "Threshold Range fail\n");
-			goto unlock;
-		}
+	if (param->flag & RETRY_SHORT) {
+		wid_list[i].id = WID_SHORT_RETRY_LIMIT;
+		wid_list[i].val = (s8 *)&param->short_retry_limit;
+		wid_list[i].type = WID_SHORT;
+		wid_list[i].size = sizeof(u16);
 		i++;
 	}
-	if (cfg_param_attr->flag & RTS_THRESHOLD) {
-		if (cfg_param_attr->rts_threshold > 255 &&
-		    cfg_param_attr->rts_threshold < 65536) {
-			wid_list[i].id = WID_RTS_THRESHOLD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->rts_threshold;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.rts_threshold = cfg_param_attr->rts_threshold;
-		} else {
-			netdev_err(vif->ndev, "Threshold Range fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & PREAMBLE) {
-		if (cfg_param_attr->preamble_type < 3) {
-			wid_list[i].id = WID_PREAMBLE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->preamble_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.preamble_type = cfg_param_attr->preamble_type;
-		} else {
-			netdev_err(vif->ndev, "Preamle Range(0~2) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SHORT_SLOT_ALLOWED) {
-		if (cfg_param_attr->short_slot_allowed < 2) {
-			wid_list[i].id = WID_SHORT_SLOT_ALLOWED;
-			wid_list[i].val = (s8 *)&cfg_param_attr->short_slot_allowed;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.short_slot_allowed = (u8)cfg_param_attr->short_slot_allowed;
-		} else {
-			netdev_err(vif->ndev, "Short slot(2) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & TXOP_PROT_DISABLE) {
-		if (cfg_param_attr->txop_prot_disabled < 2) {
-			wid_list[i].id = WID_11N_TXOP_PROT_DISABLE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->txop_prot_disabled;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.txop_prot_disabled = (u8)cfg_param_attr->txop_prot_disabled;
-		} else {
-			netdev_err(vif->ndev, "TXOP prot disable\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & BEACON_INTERVAL) {
-		if (cfg_param_attr->beacon_interval > 0 &&
-		    cfg_param_attr->beacon_interval < 65536) {
-			wid_list[i].id = WID_BEACON_INTERVAL;
-			wid_list[i].val = (s8 *)&cfg_param_attr->beacon_interval;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.beacon_interval = cfg_param_attr->beacon_interval;
-		} else {
-			netdev_err(vif->ndev, "Beacon interval(1~65535)fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & DTIM_PERIOD) {
-		if (cfg_param_attr->dtim_period > 0 &&
-		    cfg_param_attr->dtim_period < 256) {
-			wid_list[i].id = WID_DTIM_PERIOD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->dtim_period;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.dtim_period = cfg_param_attr->dtim_period;
-		} else {
-			netdev_err(vif->ndev, "DTIM range(1~255) fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SITE_SURVEY) {
-		if (cfg_param_attr->site_survey_enabled < 3) {
-			wid_list[i].id = WID_SITE_SURVEY;
-			wid_list[i].val = (s8 *)&cfg_param_attr->site_survey_enabled;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.site_survey_enabled = (u8)cfg_param_attr->site_survey_enabled;
-		} else {
-			netdev_err(vif->ndev, "Site survey disable\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SITE_SURVEY_SCAN_TIME) {
-		if (cfg_param_attr->site_survey_scan_time > 0 &&
-		    cfg_param_attr->site_survey_scan_time < 65536) {
-			wid_list[i].id = WID_SITE_SURVEY_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->site_survey_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.site_survey_scan_time = cfg_param_attr->site_survey_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Site scan time(1~65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & ACTIVE_SCANTIME) {
-		if (cfg_param_attr->active_scan_time > 0 &&
-		    cfg_param_attr->active_scan_time < 65536) {
-			wid_list[i].id = WID_ACTIVE_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->active_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.active_scan_time = cfg_param_attr->active_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Active time(1~65535) over\n");
-			goto unlock;
-		}
+	if (param->flag & RETRY_LONG) {
+		wid_list[i].id = WID_LONG_RETRY_LIMIT;
+		wid_list[i].val = (s8 *)&param->long_retry_limit;
+		wid_list[i].type = WID_SHORT;
+		wid_list[i].size = sizeof(u16);
 		i++;
 	}
-	if (cfg_param_attr->flag & PASSIVE_SCANTIME) {
-		if (cfg_param_attr->passive_scan_time > 0 &&
-		    cfg_param_attr->passive_scan_time < 65536) {
-			wid_list[i].id = WID_PASSIVE_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->passive_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.passive_scan_time = cfg_param_attr->passive_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Passive time(1~65535) over\n");
-			goto unlock;
-		}
+	if (param->flag & FRAG_THRESHOLD) {
+		wid_list[i].id = WID_FRAG_THRESHOLD;
+		wid_list[i].val = (s8 *)&param->frag_threshold;
+		wid_list[i].type = WID_SHORT;
+		wid_list[i].size = sizeof(u16);
 		i++;
 	}
-	if (cfg_param_attr->flag & CURRENT_TX_RATE) {
-		enum CURRENT_TXRATE curr_tx_rate = cfg_param_attr->curr_tx_rate;
-
-		if (curr_tx_rate == AUTORATE || curr_tx_rate == MBPS_1 ||
-		    curr_tx_rate == MBPS_2 || curr_tx_rate == MBPS_5_5 ||
-		    curr_tx_rate == MBPS_11 || curr_tx_rate == MBPS_6 ||
-		    curr_tx_rate == MBPS_9 || curr_tx_rate == MBPS_12 ||
-		    curr_tx_rate == MBPS_18 || curr_tx_rate == MBPS_24 ||
-		    curr_tx_rate == MBPS_36 || curr_tx_rate == MBPS_48 ||
-		    curr_tx_rate == MBPS_54) {
-			wid_list[i].id = WID_CURRENT_TX_RATE;
-			wid_list[i].val = (s8 *)&curr_tx_rate;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.curr_tx_rate = (u8)curr_tx_rate;
-		} else {
-			netdev_err(vif->ndev, "out of TX rate\n");
-			goto unlock;
-		}
+	if (param->flag & RTS_THRESHOLD) {
+		wid_list[i].id = WID_RTS_THRESHOLD;
+		wid_list[i].val = (s8 *)&param->rts_threshold;
+		wid_list[i].type = WID_SHORT;
+		wid_list[i].size = sizeof(u16);
 		i++;
 	}
 
@@ -739,57 +548,102 @@ static void handle_cfg_param(struct wilc_vif *vif,
 				   i, wilc_get_vif_idx(vif));
 
 	if (ret)
-		netdev_err(vif->ndev, "Error in setting CFG params\n");
+		PRINT_ER(vif->ndev, "Error in setting CFG params\n");
 
-unlock:
-	mutex_unlock(&hif_drv->cfg_values_lock);
+	kfree(msg);
 }
 
-static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
+static void handle_scan(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct scan_attr *scan_info = &msg->body.scan_info;
+	struct wiphy *wiphy = vif->ndev->ieee80211_ptr->wiphy;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	int result = 0;
 	struct wid wid_list[5];
 	u32 index = 0;
 	u32 i;
 	u8 *buffer;
 	u8 valuesize = 0;
-	u8 *pu8HdnNtwrksWidVal = NULL;
+	u8 *hdn_ntwk_wid_val = NULL;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct hidden_network *hidden_net = &scan_info->hidden_network;
+	struct host_if_drv *hif_drv_p2p = get_drv_hndl_by_ifc(vif->wilc,
+							      P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = get_drv_hndl_by_ifc(vif->wilc,
+							       WLAN_IFC);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Scanning: In [%d] state\n",
+		   hif_drv->hif_state);
 
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		result = -EFAULT;
+		goto error;
+	}
 	hif_drv->usr_scan_req.scan_result = scan_info->result;
 	hif_drv->usr_scan_req.arg = scan_info->arg;
 
-	if ((hif_drv->hif_state >= HOST_IF_SCANNING) &&
-	    (hif_drv->hif_state < HOST_IF_CONNECTED)) {
-		netdev_err(vif->ndev, "Already scan\n");
-		result = -EBUSY;
-		goto ERRORHANDLER;
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state != HOST_IF_IDLE &&
+		    hif_drv_p2p->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Don't scan. P2P_IFC is in state [%d]\n",
+				   hif_drv_p2p->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
 	}
 
-	if (wilc_optaining_ip || wilc_connecting) {
-		netdev_err(vif->ndev, "Don't do obss scan\n");
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state != HOST_IF_IDLE &&
+	    hif_drv_wlan->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Don't scan. WLAN_IFC is in state [%d]\n",
+				   hif_drv_wlan->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
+	}
+	if (vif->connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
+		result = -EBUSY;
+		goto error;
+	}
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	if (vif->obtaining_ip) {
+		PRINT_ER(vif->ndev, "Don't do obss scan\n");
 		result = -EBUSY;
-		goto ERRORHANDLER;
+		goto error;
 	}
+#endif
 
-	hif_drv->usr_scan_req.rcvd_ch_cnt = 0;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
+	hif_drv->usr_scan_req.ch_cnt = 0;
 
-	wid_list[index].id = (u16)WID_SSID_PROBE_REQ;
+	wid_list[index].id = WID_SSID_PROBE_REQ;
 	wid_list[index].type = WID_STR;
 
-	for (i = 0; i < scan_info->hidden_network.n_ssids; i++)
-		valuesize += ((scan_info->hidden_network.net_info[i].ssid_len) + 1);
-	pu8HdnNtwrksWidVal = kmalloc(valuesize + 1, GFP_KERNEL);
-	wid_list[index].val = pu8HdnNtwrksWidVal;
+	for (i = 0; i < hidden_net->n_ssids; i++)
+		valuesize += ((hidden_net->net_info[i].ssid_len) + 1);
+	hdn_ntwk_wid_val = kmalloc(valuesize + 1, GFP_KERNEL);
+	wid_list[index].val = hdn_ntwk_wid_val;
 	if (wid_list[index].val) {
 		buffer = wid_list[index].val;
 
-		*buffer++ = scan_info->hidden_network.n_ssids;
+		*buffer++ = hidden_net->n_ssids;
 
-		for (i = 0; i < scan_info->hidden_network.n_ssids; i++) {
-			*buffer++ = scan_info->hidden_network.net_info[i].ssid_len;
-			memcpy(buffer, scan_info->hidden_network.net_info[i].ssid, scan_info->hidden_network.net_info[i].ssid_len);
-			buffer += scan_info->hidden_network.net_info[i].ssid_len;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "In Handle_ProbeRequest number of ssid %d\n",
+			 hidden_net->n_ssids);
+		for (i = 0; i < hidden_net->n_ssids; i++) {
+			*buffer++ = hidden_net->net_info[i].ssid_len;
+			memcpy(buffer, hidden_net->net_info[i].ssid,
+			       hidden_net->net_info[i].ssid_len);
+			buffer += hidden_net->net_info[i].ssid_len;
 		}
 
 		wid_list[index].size = (s32)(valuesize + 1);
@@ -815,9 +669,9 @@ static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
 	    scan_info->ch_list_len > 0) {
 		int i;
 
-		for (i = 0; i < scan_info->ch_list_len; i++)	{
+		for (i = 0; i < scan_info->ch_list_len; i++) {
 			if (scan_info->ch_freq_list[i] > 0)
-				scan_info->ch_freq_list[i] = scan_info->ch_freq_list[i] - 1;
+				scan_info->ch_freq_list[i] -= 1;
 		}
 	}
 
@@ -831,22 +685,24 @@ static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
 	wid_list[index].val = (s8 *)&scan_info->src;
 	index++;
 
-	if (hif_drv->hif_state == HOST_IF_CONNECTED)
-		scan_while_connected = true;
-	else if (hif_drv->hif_state == HOST_IF_IDLE)
-		scan_while_connected = false;
+    /*
+     * Remove APs from shadow scan list which are
+     * not in the requested scan channels list
+     */
+	filter_shadow_scan(priv, scan_info->ch_freq_list,
+			   scan_info->ch_list_len);
 
 	result = wilc_send_config_pkt(vif, SET_CFG, wid_list,
 				      index,
 				      wilc_get_vif_idx(vif));
 
 	if (result)
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
 
-ERRORHANDLER:
+error:
 	if (result) {
 		del_timer(&hif_drv->scan_timer);
-		Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
+		handle_scan_done(vif, SCAN_EVENT_ABORTED);
 	}
 
 	kfree(scan_info->ch_freq_list);
@@ -857,367 +713,431 @@ static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
 	kfree(scan_info->hidden_network.net_info);
 	scan_info->hidden_network.net_info = NULL;
 
-	kfree(pu8HdnNtwrksWidVal);
+	kfree(hdn_ntwk_wid_val);
 
-	return result;
+	kfree(msg);
 }
 
-static s32 Handle_ScanDone(struct wilc_vif *vif,
-			   enum scan_event enuEvent)
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
 {
 	s32 result = 0;
-	u8 u8abort_running_scan;
+	u8 abort_running_scan;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct user_scan_req *scan_req;
+	u8 null_bssid[6] = {0};
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "handling scan done\n");
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		return result;
+	}
 
-	if (enuEvent == SCAN_EVENT_ABORTED) {
-		u8abort_running_scan = 1;
-		wid.id = (u16)WID_ABORT_RUNNING_SCAN;
+	if (evt == SCAN_EVENT_DONE) {
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+	} else if (evt == SCAN_EVENT_ABORTED) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Abort running scan\n");
+		abort_running_scan = 1;
+		wid.id = WID_ABORT_RUNNING_SCAN;
 		wid.type = WID_CHAR;
-		wid.val = (s8 *)&u8abort_running_scan;
+		wid.val = (s8 *)&abort_running_scan;
 		wid.size = sizeof(char);
 
 		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 					      wilc_get_vif_idx(vif));
 
 		if (result) {
-			netdev_err(vif->ndev, "Failed to set abort running\n");
+			PRINT_ER(vif->ndev, "Failed to set abort running\n");
 			result = -EFAULT;
 		}
 	}
 
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return result;
-	}
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		hif_drv->usr_scan_req.scan_result(enuEvent, NULL,
-						  hif_drv->usr_scan_req.arg, NULL);
-		hif_drv->usr_scan_req.scan_result = NULL;
+	scan_req = &hif_drv->usr_scan_req;
+	if (scan_req->scan_result) {
+		scan_req->scan_result(evt, NULL, scan_req->arg, NULL);
+		scan_req->scan_result = NULL;
 	}
 
 	return result;
 }
 
-u8 wilc_connected_ssid[6] = {0};
-static s32 Handle_Connect(struct wilc_vif *vif,
-			  struct connect_attr *pstrHostIFconnectAttr)
+static void handle_connect(struct work_struct *work)
 {
-	s32 result = 0;
-	struct wid strWIDList[8];
-	u32 u32WidsCount = 0, dummyval = 0;
-	u8 *pu8CurrByte = NULL;
-	struct join_bss_param *ptstrJoinBssParam;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct connect_attr *conn_attr = &msg->body.con_info;
+	int result = 0;
+	struct wid wid_list[8];
+	u32 wid_cnt = 0, dummyval = 0;
+	u8 *cur_byte = NULL;
+	struct join_bss_param *bss_param;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct host_if_drv *hif_drv_p2p = get_drv_hndl_by_ifc(vif->wilc,
+							      P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = get_drv_hndl_by_ifc(vif->wilc,
+							       WLAN_IFC);
 
-	if (memcmp(pstrHostIFconnectAttr->bssid, wilc_connected_ssid, ETH_ALEN) == 0) {
-		result = 0;
-		netdev_err(vif->ndev, "Discard connect request\n");
-		return result;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		result = -EFAULT;
+		goto error;
 	}
 
-	ptstrJoinBssParam = pstrHostIFconnectAttr->params;
-	if (!ptstrJoinBssParam) {
-		netdev_err(vif->ndev, "Required BSSID not found\n");
-		result = -ENOENT;
-		goto ERRORHANDLER;
-	}
+	if (hif_drv->usr_scan_req.scan_result) {
+		result = wilc_enqueue_work(msg);
+		if (result)
+			goto error;
 
-	if (pstrHostIFconnectAttr->bssid) {
-		hif_drv->usr_conn_req.bssid = kmalloc(6, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.bssid, pstrHostIFconnectAttr->bssid, 6);
+		usleep_range(2 * 1000, 2 * 1000);
+		return;
 	}
 
-	hif_drv->usr_conn_req.ssid_len = pstrHostIFconnectAttr->ssid_len;
-	if (pstrHostIFconnectAttr->ssid) {
-		hif_drv->usr_conn_req.ssid = kmalloc(pstrHostIFconnectAttr->ssid_len + 1, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.ssid,
-		       pstrHostIFconnectAttr->ssid,
-		       pstrHostIFconnectAttr->ssid_len);
-		hif_drv->usr_conn_req.ssid[pstrHostIFconnectAttr->ssid_len] = '\0';
-	}
-
-	hif_drv->usr_conn_req.ies_len = pstrHostIFconnectAttr->ies_len;
-	if (pstrHostIFconnectAttr->ies) {
-		hif_drv->usr_conn_req.ies = kmalloc(pstrHostIFconnectAttr->ies_len, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.ies,
-		       pstrHostIFconnectAttr->ies,
-		       pstrHostIFconnectAttr->ies_len);
-	}
-
-	hif_drv->usr_conn_req.security = pstrHostIFconnectAttr->security;
-	hif_drv->usr_conn_req.auth_type = pstrHostIFconnectAttr->auth_type;
-	hif_drv->usr_conn_req.conn_result = pstrHostIFconnectAttr->result;
-	hif_drv->usr_conn_req.arg = pstrHostIFconnectAttr->arg;
-
-	strWIDList[u32WidsCount].id = WID_SUCCESS_FRAME_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RECEIVED_FRAGMENT_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_FAILED_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	{
-		strWIDList[u32WidsCount].id = WID_INFO_ELEMENT_ASSOCIATE;
-		strWIDList[u32WidsCount].type = WID_BIN_DATA;
-		strWIDList[u32WidsCount].val = hif_drv->usr_conn_req.ies;
-		strWIDList[u32WidsCount].size = hif_drv->usr_conn_req.ies_len;
-		u32WidsCount++;
-
-		if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-			info_element_size = hif_drv->usr_conn_req.ies_len;
-			info_element = kmalloc(info_element_size, GFP_KERNEL);
-			memcpy(info_element, hif_drv->usr_conn_req.ies,
-			       info_element_size);
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Don't scan. P2P_IFC is in state [%d]\n",
+			 hif_drv_p2p->hif_state);
+			 result = -EFAULT;
+			goto error;
+		}
+	}
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Don't scan. WLAN_IFC is in state [%d]\n",
+			 hif_drv_wlan->hif_state);
+			result = -EFAULT;
+			goto error;
 		}
 	}
-	strWIDList[u32WidsCount].id = (u16)WID_11I_MODE;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&hif_drv->usr_conn_req.security;
-	u32WidsCount++;
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7))
-		mode_11i = hif_drv->usr_conn_req.security;
 
-	strWIDList[u32WidsCount].id = (u16)WID_AUTH_TYPE;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&hif_drv->usr_conn_req.auth_type;
-	u32WidsCount++;
+	PRINT_D(vif->ndev, HOSTINF_DBG,
+		"Saving connection parameters in global structure\n");
+	bss_param = conn_attr->params;
+	if (!bss_param) {
+		PRINT_ER(vif->ndev, "Required BSSID not found\n");
+		result = -ENOENT;
+		goto error;
+	}
 
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7))
-		auth_type = (u8)hif_drv->usr_conn_req.auth_type;
+	if (conn_attr->bssid) {
+		hif_drv->usr_conn_req.bssid = kmemdup(conn_attr->bssid, 6,
+						      GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.bssid) {
+			result = -ENOMEM;
+			goto error;
+		}
+	}
 
-	strWIDList[u32WidsCount].id = (u16)WID_JOIN_REQ_EXTENDED;
-	strWIDList[u32WidsCount].type = WID_STR;
-	strWIDList[u32WidsCount].size = 112;
-	strWIDList[u32WidsCount].val = kmalloc(strWIDList[u32WidsCount].size, GFP_KERNEL);
+	hif_drv->usr_conn_req.ssid_len = conn_attr->ssid_len;
+	if (conn_attr->ssid) {
+		hif_drv->usr_conn_req.ssid = kmalloc(conn_attr->ssid_len + 1,
+						     GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.ssid) {
+			result = -ENOMEM;
+			goto error;
+		}
+		memcpy(hif_drv->usr_conn_req.ssid,
+		       conn_attr->ssid,
+		       conn_attr->ssid_len);
+		hif_drv->usr_conn_req.ssid[conn_attr->ssid_len] = '\0';
+	}
 
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-		join_req_size = strWIDList[u32WidsCount].size;
-		join_req = kmalloc(join_req_size, GFP_KERNEL);
+	hif_drv->usr_conn_req.ies_len = conn_attr->ies_len;
+	if (conn_attr->ies) {
+		hif_drv->usr_conn_req.ies = kmemdup(conn_attr->ies,
+						    conn_attr->ies_len,
+						    GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.ies) {
+			result = -ENOMEM;
+			goto error;
+		}
 	}
-	if (!strWIDList[u32WidsCount].val) {
+
+	hif_drv->usr_conn_req.security = conn_attr->security;
+	hif_drv->usr_conn_req.auth_type = conn_attr->auth_type;
+	hif_drv->usr_conn_req.conn_result = conn_attr->result;
+	hif_drv->usr_conn_req.arg = conn_attr->arg;
+
+	wid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_FAILED_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;
+	wid_list[wid_cnt].type = WID_BIN_DATA;
+	wid_list[wid_cnt].val = hif_drv->usr_conn_req.ies;
+	wid_list[wid_cnt].size = hif_drv->usr_conn_req.ies_len;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_11I_MODE;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&hif_drv->usr_conn_req.security;
+	wid_cnt++;
+
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Encrypt Mode = %x\n",
+		hif_drv->usr_conn_req.security);
+	wid_list[wid_cnt].id = WID_AUTH_TYPE;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&hif_drv->usr_conn_req.auth_type;
+	wid_cnt++;
+
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Authentication Type = %x\n",
+		hif_drv->usr_conn_req.auth_type);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Connecting to network of SSID %s on channel %d\n",
+		 hif_drv->usr_conn_req.ssid, conn_attr->ch);
+
+	wid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;
+	wid_list[wid_cnt].type = WID_STR;
+	wid_list[wid_cnt].size = 112;
+	wid_list[wid_cnt].val = kmalloc(wid_list[wid_cnt].size, GFP_KERNEL);
+
+	if (!wid_list[wid_cnt].val) {
 		result = -EFAULT;
-		goto ERRORHANDLER;
+		goto error;
 	}
 
-	pu8CurrByte = strWIDList[u32WidsCount].val;
+	cur_byte = wid_list[wid_cnt].val;
 
-	if (pstrHostIFconnectAttr->ssid) {
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->ssid, pstrHostIFconnectAttr->ssid_len);
-		pu8CurrByte[pstrHostIFconnectAttr->ssid_len] = '\0';
+	if (conn_attr->ssid) {
+		memcpy(cur_byte, conn_attr->ssid, conn_attr->ssid_len);
+		cur_byte[conn_attr->ssid_len] = '\0';
 	}
-	pu8CurrByte += MAX_SSID_LEN;
-	*(pu8CurrByte++) = INFRASTRUCTURE;
+	cur_byte += MAX_SSID_LEN;
+	*(cur_byte++) = INFRASTRUCTURE;
 
-	if ((pstrHostIFconnectAttr->ch >= 1) && (pstrHostIFconnectAttr->ch <= 14)) {
-		*(pu8CurrByte++) = pstrHostIFconnectAttr->ch;
+	if (conn_attr->ch >= 1 && conn_attr->ch <= 14) {
+		*(cur_byte++) = conn_attr->ch;
 	} else {
-		netdev_err(vif->ndev, "Channel out of range\n");
-		*(pu8CurrByte++) = 0xFF;
+		PRINT_ER(vif->ndev, "Channel out of range\n");
+		*(cur_byte++) = 0xFF;
 	}
-	*(pu8CurrByte++)  = (ptstrJoinBssParam->cap_info) & 0xFF;
-	*(pu8CurrByte++)  = ((ptstrJoinBssParam->cap_info) >> 8) & 0xFF;
-
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->bssid, 6);
-	pu8CurrByte += 6;
-
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->bssid, 6);
-	pu8CurrByte += 6;
-
-	*(pu8CurrByte++)  = (ptstrJoinBssParam->beacon_period) & 0xFF;
-	*(pu8CurrByte++)  = ((ptstrJoinBssParam->beacon_period) >> 8) & 0xFF;
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->dtim_period;
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->supp_rates, MAX_RATES_SUPPORTED + 1);
-	pu8CurrByte += (MAX_RATES_SUPPORTED + 1);
-
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->wmm_cap;
-	*(pu8CurrByte++)  = ptstrJoinBssParam->uapsd_cap;
-
-	*(pu8CurrByte++)  = ptstrJoinBssParam->ht_capable;
-	hif_drv->usr_conn_req.ht_capable = ptstrJoinBssParam->ht_capable;
-
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->rsn_found;
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->rsn_grp_policy;
-	*(pu8CurrByte++) =  ptstrJoinBssParam->mode_802_11i;
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_pcip_policy, sizeof(ptstrJoinBssParam->rsn_pcip_policy));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_pcip_policy);
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_auth_policy, sizeof(ptstrJoinBssParam->rsn_auth_policy));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_auth_policy);
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_cap, sizeof(ptstrJoinBssParam->rsn_cap));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_cap);
-
-	*(pu8CurrByte++) = REAL_JOIN_REQ;
-	*(pu8CurrByte++) = ptstrJoinBssParam->noa_enabled;
-
-	if (ptstrJoinBssParam->noa_enabled) {
-		*(pu8CurrByte++) = (ptstrJoinBssParam->tsf) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 8) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 16) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 24) & 0xFF;
-
-		*(pu8CurrByte++) = ptstrJoinBssParam->opp_enabled;
-		*(pu8CurrByte++) = ptstrJoinBssParam->idx;
-
-		if (ptstrJoinBssParam->opp_enabled)
-			*(pu8CurrByte++) = ptstrJoinBssParam->ct_window;
-
-		*(pu8CurrByte++) = ptstrJoinBssParam->cnt;
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->duration, sizeof(ptstrJoinBssParam->duration));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->duration);
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->interval, sizeof(ptstrJoinBssParam->interval));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->interval);
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->start_time, sizeof(ptstrJoinBssParam->start_time));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->start_time);
+	*(cur_byte++)  = (bss_param->cap_info) & 0xFF;
+	*(cur_byte++)  = ((bss_param->cap_info) >> 8) & 0xFF;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* Cap Info %0x*\n",
+		   (*(cur_byte - 2) | ((*(cur_byte - 1)) << 8)));
+
+	if (conn_attr->bssid)
+		memcpy(cur_byte, conn_attr->bssid, 6);
+	cur_byte += 6;
+
+	if (conn_attr->bssid)
+		memcpy(cur_byte, conn_attr->bssid, 6);
+	cur_byte += 6;
+
+	*(cur_byte++)  = (bss_param->beacon_period) & 0xFF;
+	*(cur_byte++)  = ((bss_param->beacon_period) >> 8) & 0xFF;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* Beacon Period %d*\n",
+		   *(cur_byte - 2) | ((*(cur_byte - 1)) << 8));
+	*(cur_byte++)  =  bss_param->dtim_period;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* DTIM Period %d*\n",
+		   *(cur_byte - 1));
+
+	memcpy(cur_byte, bss_param->supp_rates, MAX_RATES_SUPPORTED + 1);
+	cur_byte += (MAX_RATES_SUPPORTED + 1);
+
+	*(cur_byte++)  =  bss_param->wmm_cap;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* wmm cap%d*\n", *(cur_byte - 1));
+	*(cur_byte++)  = bss_param->uapsd_cap;
+
+	*(cur_byte++)  = bss_param->ht_capable;
+	hif_drv->usr_conn_req.ht_capable = bss_param->ht_capable;
+
+	*(cur_byte++)  =  bss_param->rsn_found;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* rsn found %d*\n",
+		   *(cur_byte - 1));
+	*(cur_byte++)  =  bss_param->rsn_grp_policy;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* rsn group policy %0x*\n",
+		   *(cur_byte - 1));
+	*(cur_byte++) =  bss_param->mode_802_11i;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* mode_802_11i %d*\n",
+		   *(cur_byte - 1));
+	memcpy(cur_byte, bss_param->rsn_pcip_policy,
+	       sizeof(bss_param->rsn_pcip_policy));
+	cur_byte += sizeof(bss_param->rsn_pcip_policy);
+
+	memcpy(cur_byte, bss_param->rsn_auth_policy,
+	       sizeof(bss_param->rsn_auth_policy));
+	cur_byte += sizeof(bss_param->rsn_auth_policy);
+
+	memcpy(cur_byte, bss_param->rsn_cap, sizeof(bss_param->rsn_cap));
+	cur_byte += sizeof(bss_param->rsn_cap);
+
+	*(cur_byte++) = REAL_JOIN_REQ;
+	*(cur_byte++) = bss_param->noa_enabled;
+
+	if (bss_param->noa_enabled) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "NOA present\n");
+		*(cur_byte++) = (bss_param->tsf) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 8) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 16) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 24) & 0xFF;
+
+		*(cur_byte++) = bss_param->idx;
+		*(cur_byte++) = bss_param->opp_enabled;
+
+		if (bss_param->opp_enabled)
+			*(cur_byte++) = bss_param->ct_window;
+
+		*(cur_byte++) = bss_param->cnt;
+
+		memcpy(cur_byte, bss_param->duration,
+		       sizeof(bss_param->duration));
+		cur_byte += sizeof(bss_param->duration);
+
+		memcpy(cur_byte, bss_param->interval,
+		       sizeof(bss_param->interval));
+		cur_byte += sizeof(bss_param->interval);
+
+		memcpy(cur_byte, bss_param->start_time,
+		       sizeof(bss_param->start_time));
+		cur_byte += sizeof(bss_param->start_time);
+	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "NOA not present\n");
 	}
 
-	pu8CurrByte = strWIDList[u32WidsCount].val;
-	u32WidsCount++;
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-		memcpy(join_req, pu8CurrByte, join_req_size);
-		join_req_vif = vif;
-	}
+	cur_byte = wid_list[wid_cnt].val;
+	wid_cnt++;
 
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(wilc_connected_ssid,
-		       pstrHostIFconnectAttr->bssid, ETH_ALEN);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "send HOST_IF_WAITING_CONN_RESP\n");
 
-	result = wilc_send_config_pkt(vif, SET_CFG, strWIDList,
-				      u32WidsCount,
+	result = wilc_send_config_pkt(vif, SET_CFG, wid_list,
+				      wid_cnt,
 				      wilc_get_vif_idx(vif));
 	if (result) {
-		netdev_err(vif->ndev, "failed to send config packet\n");
+		PRINT_ER(vif->ndev, "failed to send config packet\n");
 		result = -EFAULT;
-		goto ERRORHANDLER;
+		goto error;
 	} else {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "set HOST_IF_WAITING_CONN_RESP\n");
 		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
 	}
 
-ERRORHANDLER:
+error:
 	if (result) {
-		struct connect_info strConnectInfo;
+		struct connect_info conn_info;
 
 		del_timer(&hif_drv->connect_timer);
 
-		memset(&strConnectInfo, 0, sizeof(struct connect_info));
-
-		if (pstrHostIFconnectAttr->result) {
-			if (pstrHostIFconnectAttr->bssid)
-				memcpy(strConnectInfo.bssid, pstrHostIFconnectAttr->bssid, 6);
-
-			if (pstrHostIFconnectAttr->ies) {
-				strConnectInfo.req_ies_len = pstrHostIFconnectAttr->ies_len;
-				strConnectInfo.req_ies = kmalloc(pstrHostIFconnectAttr->ies_len, GFP_KERNEL);
-				memcpy(strConnectInfo.req_ies,
-				       pstrHostIFconnectAttr->ies,
-				       pstrHostIFconnectAttr->ies_len);
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "could not start connecting to the required network\n");
+		memset(&conn_info, 0, sizeof(struct connect_info));
+
+		if (conn_attr->result) {
+			if (conn_attr->bssid)
+				memcpy(conn_info.bssid, conn_attr->bssid, 6);
+
+			if (conn_attr->ies) {
+				conn_info.req_ies_len = conn_attr->ies_len;
+				conn_info.req_ies = kmalloc(conn_attr->ies_len,
+							    GFP_KERNEL);
+				memcpy(conn_info.req_ies,
+				       conn_attr->ies,
+				       conn_attr->ies_len);
 			}
 
-			pstrHostIFconnectAttr->result(CONN_DISCONN_EVENT_CONN_RESP,
-							       &strConnectInfo,
-							       MAC_DISCONNECTED,
-							       NULL,
-							       pstrHostIFconnectAttr->arg);
+			conn_attr->result(EVENT_CONN_RESP,
+					  &conn_info, MAC_STATUS_DISCONNECTED,
+					  NULL, conn_attr->arg);
 			hif_drv->hif_state = HOST_IF_IDLE;
-			kfree(strConnectInfo.req_ies);
-			strConnectInfo.req_ies = NULL;
+			kfree(conn_info.req_ies);
+			conn_info.req_ies = NULL;
 
 		} else {
-			netdev_err(vif->ndev, "Connect callback is NULL\n");
+			PRINT_ER(vif->ndev, "conn_result is NULL\n");
 		}
 	}
 
-	kfree(pstrHostIFconnectAttr->bssid);
-	pstrHostIFconnectAttr->bssid = NULL;
+	kfree(conn_attr->bssid);
+	conn_attr->bssid = NULL;
 
-	kfree(pstrHostIFconnectAttr->ssid);
-	pstrHostIFconnectAttr->ssid = NULL;
+	kfree(conn_attr->ssid);
+	conn_attr->ssid = NULL;
 
-	kfree(pstrHostIFconnectAttr->ies);
-	pstrHostIFconnectAttr->ies = NULL;
+	kfree(conn_attr->ies);
+	conn_attr->ies = NULL;
 
-	kfree(pu8CurrByte);
-	return result;
+	kfree(cur_byte);
+	kfree(msg);
 }
 
-static s32 Handle_ConnectTimeout(struct wilc_vif *vif)
+static void handle_connect_timeout(struct work_struct *work)
 {
-	s32 result = 0;
-	struct connect_info strConnectInfo;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	int result;
+	struct connect_info info;
 	struct wid wid;
-	u16 u16DummyReasonCode = 0;
+	u16 dummy_reason_code = 0;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return result;
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
 	}
 
 	hif_drv->hif_state = HOST_IF_IDLE;
 
-	scan_while_connected = false;
-
-	memset(&strConnectInfo, 0, sizeof(struct connect_info));
+	memset(&info, 0, sizeof(struct connect_info));
 
 	if (hif_drv->usr_conn_req.conn_result) {
 		if (hif_drv->usr_conn_req.bssid) {
-			memcpy(strConnectInfo.bssid,
+			memcpy(info.bssid,
 			       hif_drv->usr_conn_req.bssid, 6);
 		}
 
 		if (hif_drv->usr_conn_req.ies) {
-			strConnectInfo.req_ies_len = hif_drv->usr_conn_req.ies_len;
-			strConnectInfo.req_ies = kmalloc(hif_drv->usr_conn_req.ies_len, GFP_KERNEL);
-			memcpy(strConnectInfo.req_ies,
-			       hif_drv->usr_conn_req.ies,
-			       hif_drv->usr_conn_req.ies_len);
+			info.req_ies_len = hif_drv->usr_conn_req.ies_len;
+			info.req_ies = kmemdup(hif_drv->usr_conn_req.ies,
+					       hif_drv->usr_conn_req.ies_len,
+					       GFP_KERNEL);
+			if (!info.req_ies)
+				goto out;
 		}
 
-		hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
-						  &strConnectInfo,
-						  MAC_DISCONNECTED,
+		hif_drv->usr_conn_req.conn_result(EVENT_CONN_RESP,
+						  &info,
+						  MAC_STATUS_DISCONNECTED,
 						  NULL,
 						  hif_drv->usr_conn_req.arg);
 
-		kfree(strConnectInfo.req_ies);
-		strConnectInfo.req_ies = NULL;
+		kfree(info.req_ies);
+		info.req_ies = NULL;
 	} else {
-		netdev_err(vif->ndev, "Connect callback is NULL\n");
+		PRINT_ER(vif->ndev, "conn_result is NULL\n");
 	}
 
-	wid.id = (u16)WID_DISCONNECT;
+	wid.id = WID_DISCONNECT;
 	wid.type = WID_CHAR;
-	wid.val = (s8 *)&u16DummyReasonCode;
+	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send disconnect\n");
+		PRINT_ER(vif->ndev, "Failed to send disconect\n");
 
 	hif_drv->usr_conn_req.ssid_len = 0;
 	kfree(hif_drv->usr_conn_req.ssid);
@@ -1228,1583 +1148,2070 @@ static s32 Handle_ConnectTimeout(struct wilc_vif *vif)
 	kfree(hif_drv->usr_conn_req.ies);
 	hif_drv->usr_conn_req.ies = NULL;
 
-	eth_zero_addr(wilc_connected_ssid);
-
-	if (join_req && join_req_vif == vif) {
-		kfree(join_req);
-		join_req = NULL;
-	}
+out:
+	kfree(msg);
+}
 
-	if (info_element && join_req_vif == vif) {
-		kfree(info_element);
-		info_element = NULL;
+static void host_int_fill_join_bss_param(struct join_bss_param *param, u8 *ies,
+					 u16 *out_index, u8 *pcipher_tc,
+					 u8 *auth_total_cnt, u32 tsf_lo,
+					 u8 *rates_no)
+{
+	u8 ext_rates_no;
+	u16 offset;
+	u8 pcipher_cnt;
+	u8 auth_cnt;
+	u8 i, j;
+	u16 index = *out_index;
+
+	if (ies[index] == WLAN_EID_SUPP_RATES) {
+		*rates_no = ies[index + 1];
+		param->supp_rates[0] = *rates_no;
+		index += 2;
+
+		for (i = 0; i < *rates_no; i++)
+			param->supp_rates[i + 1] = ies[index + i];
+
+		index += *rates_no;
+	} else if (ies[index] == WLAN_EID_EXT_SUPP_RATES) {
+		ext_rates_no = ies[index + 1];
+		if (ext_rates_no > (MAX_RATES_SUPPORTED - *rates_no))
+			param->supp_rates[0] = MAX_RATES_SUPPORTED;
+		else
+			param->supp_rates[0] += ext_rates_no;
+		index += 2;
+		for (i = 0; i < (param->supp_rates[0] - *rates_no); i++)
+			param->supp_rates[*rates_no + i + 1] = ies[index + i];
+
+		index += ext_rates_no;
+	} else if (ies[index] == WLAN_EID_HT_CAPABILITY) {
+		param->ht_capable = true;
+		index += ies[index + 1] + 2;
+	} else if ((ies[index] == WLAN_EID_VENDOR_SPECIFIC) &&
+		   (ies[index + 2] == 0x00) && (ies[index + 3] == 0x50) &&
+		   (ies[index + 4] == 0xF2) && (ies[index + 5] == 0x02) &&
+		   ((ies[index + 6] == 0x00) || (ies[index + 6] == 0x01)) &&
+		   (ies[index + 7] == 0x01)) {
+		param->wmm_cap = true;
+
+		if (ies[index + 8] & BIT(7))
+			param->uapsd_cap = true;
+		index += ies[index + 1] + 2;
+	} else if ((ies[index] == WLAN_EID_VENDOR_SPECIFIC) &&
+		 (ies[index + 2] == 0x50) && (ies[index + 3] == 0x6f) &&
+		 (ies[index + 4] == 0x9a) &&
+		 (ies[index + 5] == 0x09) && (ies[index + 6] == 0x0c)) {
+		u16 p2p_cnt;
+
+		param->tsf = tsf_lo;
+		param->noa_enabled = 1;
+		param->idx = ies[index + 9];
+
+		if (ies[index + 10] & BIT(7)) {
+			param->opp_enabled = 1;
+			param->ct_window = ies[index + 10];
+		} else {
+			param->opp_enabled = 0;
+		}
+
+		param->cnt = ies[index + 11];
+		p2p_cnt = index + 12;
+
+		memcpy(param->duration, ies + p2p_cnt, 4);
+		p2p_cnt += 4;
+
+		memcpy(param->interval, ies + p2p_cnt, 4);
+		p2p_cnt += 4;
+
+		memcpy(param->start_time, ies + p2p_cnt, 4);
+
+		index += ies[index + 1] + 2;
+	} else if ((ies[index] == WLAN_EID_RSN) ||
+		 ((ies[index] == WLAN_EID_VENDOR_SPECIFIC) &&
+		  (ies[index + 2] == 0x00) &&
+		  (ies[index + 3] == 0x50) && (ies[index + 4] == 0xF2) &&
+		  (ies[index + 5] == 0x01))) {
+		u16 rsn_idx = index;
+
+		if (ies[rsn_idx] == WLAN_EID_RSN) {
+			param->mode_802_11i = 2;
+		} else {
+			if (param->mode_802_11i == 0)
+				param->mode_802_11i = 1;
+			rsn_idx += 4;
+		}
+
+		rsn_idx += 7;
+		param->rsn_grp_policy = ies[rsn_idx];
+		rsn_idx++;
+		offset = ies[rsn_idx] * 4;
+		pcipher_cnt = (ies[rsn_idx] > 3) ? 3 : ies[rsn_idx];
+		rsn_idx += 2;
+
+		i = *pcipher_tc;
+		j = 0;
+		for (; i < (pcipher_cnt + *pcipher_tc) && i < 3; i++, j++) {
+			u8 *policy =  &param->rsn_pcip_policy[i];
+
+			*policy = ies[rsn_idx + ((j + 1) * 4) - 1];
+		}
+
+		*pcipher_tc += pcipher_cnt;
+		rsn_idx += offset;
+
+		offset = ies[rsn_idx] * 4;
+
+		auth_cnt = (ies[rsn_idx] > 3) ? 3 : ies[rsn_idx];
+		rsn_idx += 2;
+		i = *auth_total_cnt;
+		j = 0;
+		for (; i < (*auth_total_cnt + auth_cnt); i++, j++) {
+			u8 *policy =  &param->rsn_auth_policy[i];
+
+			*policy = ies[rsn_idx + ((j + 1) * 4) - 1];
+		}
+
+		*auth_total_cnt += auth_cnt;
+		rsn_idx += offset;
+
+		if (ies[index] == WLAN_EID_RSN) {
+			param->rsn_cap[0] = ies[rsn_idx];
+			param->rsn_cap[1] = ies[rsn_idx + 1];
+			rsn_idx += 2;
+		}
+		param->rsn_found = true;
+		index += ies[index + 1] + 2;
+	} else {
+		index += ies[index + 1] + 2;
 	}
 
-	return result;
+	*out_index = index;
+}
+
+static void *host_int_parse_join_bss_param(struct network_info *info)
+{
+	struct join_bss_param *param;
+	u16 index = 0;
+	u8 rates_no = 0;
+	u8 pcipher_total_cnt = 0;
+	u8 auth_total_cnt = 0;
+
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param)
+		return NULL;
+
+	param->dtim_period = info->dtim_period;
+	param->beacon_period = info->beacon_period;
+	param->cap_info = info->cap_info;
+	memcpy(param->bssid, info->bssid, 6);
+	memcpy((u8 *)param->ssid, info->ssid, info->ssid_len + 1);
+	param->ssid_len = info->ssid_len;
+	memset(param->rsn_pcip_policy, 0xFF, 3);
+	memset(param->rsn_auth_policy, 0xFF, 3);
+
+	while (index < info->ies_len)
+		host_int_fill_join_bss_param(param, info->ies, &index,
+					     &pcipher_total_cnt,
+					     &auth_total_cnt, info->tsf_lo,
+					     &rates_no);
+
+	return (void *)param;
+}
+
+static inline u8 *get_bssid(struct ieee80211_mgmt *mgmt)
+{
+	if (ieee80211_has_fromds(mgmt->frame_control))
+		return mgmt->sa;
+	else if (ieee80211_has_tods(mgmt->frame_control))
+		return mgmt->da;
+	else
+		return mgmt->bssid;
 }
 
-static s32 Handle_RcvdNtwrkInfo(struct wilc_vif *vif,
-				struct rcvd_net_info *pstrRcvdNetworkInfo)
+static s32 wilc_parse_network_info(struct wilc_vif *vif, u8 *msg_buffer,
+				   struct network_info **ret_network_info)
 {
+	struct network_info *info;
+	struct ieee80211_mgmt *mgt;
+	u8 *wid_val, *msa, *ies;
+	u16 wid_len, rx_len, ies_len;
+	u8 msg_type;
+	size_t offset;
+	const u8 *ch_elm, *tim_elm, *ssid_elm;
+
+	msg_type = msg_buffer[0];
+	if ('N' != msg_type)
+		return -EFAULT;
+
+	wid_len = get_unaligned_le16(&msg_buffer[6]);
+	wid_val = &msg_buffer[8];
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->rssi = wid_val[0];
+
+	msa = &wid_val[1];
+	mgt = (struct ieee80211_mgmt *)&wid_val[1];
+	rx_len = wid_len - 1;
+
+	if (ieee80211_is_probe_resp(mgt->frame_control)) {
+		info->cap_info = le16_to_cpu(mgt->u.probe_resp.capab_info);
+		info->beacon_period = le16_to_cpu(mgt->u.probe_resp.beacon_int);
+		info->tsf_hi = le64_to_cpu(mgt->u.probe_resp.timestamp);
+		info->tsf_lo = (u32)info->tsf_hi;
+		offset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	} else if (ieee80211_is_beacon(mgt->frame_control)) {
+		info->cap_info = le16_to_cpu(mgt->u.beacon.capab_info);
+		info->beacon_period = le16_to_cpu(mgt->u.beacon.beacon_int);
+		info->tsf_hi = le64_to_cpu(mgt->u.beacon.timestamp);
+		info->tsf_lo = (u32)info->tsf_hi;
+		offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
+	} else {
+		/* only process probe response and beacon frame */
+		kfree(info);
+		return -EIO;
+	}
+
+	PRINT_INFO(vif->ndev, CORECONFIG_DBG, "TSF :%x\n", info->tsf_lo);
+
+	ether_addr_copy(info->bssid, get_bssid(mgt));
+
+	ies = mgt->u.beacon.variable;
+	ies_len = rx_len - offset;
+	if (ies_len <= 0) {
+		kfree(info);
+		return -EIO;
+	}
+
+	info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
+	if (!info->ies) {
+		kfree(info);
+		return -ENOMEM;
+	}
+
+	info->ies_len = ies_len;
+
+	ssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies, ies_len);
+	if (ssid_elm) {
+		info->ssid_len = ssid_elm[1];
+		if (info->ssid_len <= IEEE80211_MAX_SSID_LEN)
+			memcpy(info->ssid, ssid_elm + 2, info->ssid_len);
+		else
+			info->ssid_len = 0;
+	}
+
+	ch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);
+	if (ch_elm && ch_elm[1] > 0)
+		info->ch = ch_elm[2];
+
+	tim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies, ies_len);
+	if (tim_elm && tim_elm[1] >= 2)
+		info->dtim_period = tim_elm[3];
+
+	*ret_network_info = info;
+
+	return 0;
+}
+
+static void handle_rcvd_ntwrk_info(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct rcvd_net_info *rcvd_info = &msg->body.net_info;
 	u32 i;
-	bool bNewNtwrkFound;
-	s32 result = 0;
-	struct network_info *pstrNetworkInfo = NULL;
-	void *pJoinParams = NULL;
+	bool found;
+	struct network_info *info = NULL;
+	void *params;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct user_scan_req *scan_req = &hif_drv->usr_scan_req;
+	int ret;
 
-	bNewNtwrkFound = true;
+	found = true;
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Handling received network info\n");
 
-	if (hif_drv->usr_scan_req.scan_result) {
-		wilc_parse_network_info(pstrRcvdNetworkInfo->buffer, &pstrNetworkInfo);
-		if ((!pstrNetworkInfo) ||
-		    (!hif_drv->usr_scan_req.scan_result)) {
-			netdev_err(vif->ndev, "driver is null\n");
-			result = -EINVAL;
-			goto done;
-		}
+	if (!scan_req->scan_result)
+		goto done;
 
-		for (i = 0; i < hif_drv->usr_scan_req.rcvd_ch_cnt; i++) {
-			if (memcmp(hif_drv->usr_scan_req.net_info[i].bssid,
-				   pstrNetworkInfo->bssid, 6) == 0) {
-				if (pstrNetworkInfo->rssi <= hif_drv->usr_scan_req.net_info[i].rssi) {
-					goto done;
-				} else {
-					hif_drv->usr_scan_req.net_info[i].rssi = pstrNetworkInfo->rssi;
-					bNewNtwrkFound = false;
-					break;
-				}
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "State: Scanning, parsing network information received\n");
+	ret = wilc_parse_network_info(vif, rcvd_info->buffer, &info);
+	if (ret || !info || !scan_req->scan_result) {
+		PRINT_ER(vif->ndev, "info or scan result NULL\n");
+		goto done;
+	}
+
+	for (i = 0; i < scan_req->ch_cnt; i++) {
+		if (memcmp(scan_req->net_info[i].bssid, info->bssid, 6) == 0) {
+			if (info->rssi <= scan_req->net_info[i].rssi) {
+				PRINT_INFO(vif->ndev, HOSTINF_DBG,
+					   "Network previously discovered\n");
+				goto done;
+			} else {
+				scan_req->net_info[i].rssi = info->rssi;
+				found = false;
+				break;
 			}
 		}
+	}
 
-		if (bNewNtwrkFound) {
-			if (hif_drv->usr_scan_req.rcvd_ch_cnt < MAX_NUM_SCANNED_NETWORKS) {
-				hif_drv->usr_scan_req.net_info[hif_drv->usr_scan_req.rcvd_ch_cnt].rssi = pstrNetworkInfo->rssi;
+	if (found) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "New network found\n");
+		if (scan_req->ch_cnt < MAX_NUM_SCANNED_NETWORKS) {
+			scan_req->net_info[scan_req->ch_cnt].rssi = info->rssi;
 
-				memcpy(hif_drv->usr_scan_req.net_info[hif_drv->usr_scan_req.rcvd_ch_cnt].bssid,
-				       pstrNetworkInfo->bssid, 6);
+			memcpy(scan_req->net_info[scan_req->ch_cnt].bssid,
+			       info->bssid, 6);
 
-				hif_drv->usr_scan_req.rcvd_ch_cnt++;
+			scan_req->ch_cnt++;
 
-				pstrNetworkInfo->new_network = true;
-				pJoinParams = host_int_ParseJoinBssParam(pstrNetworkInfo);
+			info->new_network = true;
+			params = host_int_parse_join_bss_param(info);
 
-				hif_drv->usr_scan_req.scan_result(SCAN_EVENT_NETWORK_FOUND, pstrNetworkInfo,
-								  hif_drv->usr_scan_req.arg,
-								  pJoinParams);
-			}
+			scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, info,
+					       scan_req->arg, params);
 		} else {
-			pstrNetworkInfo->new_network = false;
-			hif_drv->usr_scan_req.scan_result(SCAN_EVENT_NETWORK_FOUND, pstrNetworkInfo,
-							  hif_drv->usr_scan_req.arg, NULL);
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				   "Discovered networks exceeded max. limit\n");
 		}
+	} else {
+		info->new_network = false;
+		scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, info,
+				      scan_req->arg, NULL);
 	}
 
 done:
-	kfree(pstrRcvdNetworkInfo->buffer);
-	pstrRcvdNetworkInfo->buffer = NULL;
+	kfree(rcvd_info->buffer);
+	rcvd_info->buffer = NULL;
 
-	if (pstrNetworkInfo) {
-		kfree(pstrNetworkInfo->ies);
-		kfree(pstrNetworkInfo);
+	if (info) {
+		kfree(info->ies);
+		kfree(info);
 	}
 
-	return result;
+	kfree(msg);
 }
 
-static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
-				       u8 *pu8AssocRespInfo,
-				       u32 u32MaxAssocRespInfoLen,
-				       u32 *pu32RcvdAssocRespInfoLen);
+static void host_int_get_assoc_res_info(struct wilc_vif *vif,
+				       u8 *assoc_resp_info,
+				       u32 max_assoc_resp_info_len,
+				       u32 *rcvd_assoc_resp_info_len)
+{
+	int result;
+	struct wid wid;
+
+	wid.id = WID_ASSOC_RES_INFO;
+	wid.type = WID_STR;
+	wid.val = assoc_resp_info;
+	wid.size = max_assoc_resp_info_len;
+
+	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result) {
+		*rcvd_assoc_resp_info_len = 0;
+		PRINT_ER(vif->ndev, "Failed to send association response\n");
+		return;
+	}
 
-static s32 Handle_RcvdGnrlAsyncInfo(struct wilc_vif *vif,
-				    struct rcvd_async_info *pstrRcvdGnrlAsyncInfo)
+	*rcvd_assoc_resp_info_len = wid.size;
+}
+
+static inline void host_int_free_user_conn_req(struct host_if_drv *hif_drv)
 {
-	s32 result = 0;
-	u8 u8MsgType = 0;
-	u8 u8MsgID = 0;
-	u16 u16MsgLen = 0;
-	u16 u16WidID = (u16)WID_NIL;
-	u8 u8WidLen  = 0;
-	u8 u8MacStatus;
-	u8 u8MacStatusReasonCode;
-	u8 u8MacStatusAdditionalInfo;
-	struct connect_info strConnectInfo;
-	struct disconnect_info strDisconnectNotifInfo;
-	s32 s32Err = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
+	hif_drv->usr_conn_req.ssid_len = 0;
+	kfree(hif_drv->usr_conn_req.ssid);
+	hif_drv->usr_conn_req.ssid = NULL;
+	kfree(hif_drv->usr_conn_req.bssid);
+	hif_drv->usr_conn_req.bssid = NULL;
+	hif_drv->usr_conn_req.ies_len = 0;
+	kfree(hif_drv->usr_conn_req.ies);
+	hif_drv->usr_conn_req.ies = NULL;
+}
 
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return -ENODEV;
+static s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
+				      struct connect_info *ret_conn_info)
+{
+	u8 *ies;
+	u16 ies_len;
+	struct assoc_resp *res = (struct assoc_resp *)buffer;
+
+	ret_conn_info->status = le16_to_cpu(res->status_code);
+	if (ret_conn_info->status == WLAN_STATUS_SUCCESS) {
+		ies = &buffer[sizeof(*res)];
+		ies_len = buffer_len - sizeof(*res);
+
+		ret_conn_info->resp_ies = kmemdup(ies, ies_len, GFP_KERNEL);
+		if (!ret_conn_info->resp_ies)
+			return -ENOMEM;
+
+		ret_conn_info->resp_ies_len = ies_len;
 	}
 
-	if ((hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) ||
-	    (hif_drv->hif_state == HOST_IF_CONNECTED) ||
-	    hif_drv->usr_scan_req.scan_result) {
-		if (!pstrRcvdGnrlAsyncInfo->buffer ||
-		    !hif_drv->usr_conn_req.conn_result) {
-			netdev_err(vif->ndev, "driver is null\n");
-			return -EINVAL;
+	return 0;
+}
+static inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,
+						  u8 mac_status)
+{
+	struct connect_info conn_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	memset(&conn_info, 0, sizeof(struct connect_info));
+
+	if (mac_status == MAC_STATUS_CONNECTED) {
+		u32 assoc_resp_info_len;
+
+		memset(hif_drv->assoc_resp, 0, MAX_ASSOC_RESP_FRAME_SIZE);
+
+		host_int_get_assoc_res_info(vif, hif_drv->assoc_resp,
+					    MAX_ASSOC_RESP_FRAME_SIZE,
+					    &assoc_resp_info_len);
+
+		PRINT_D(vif->ndev, HOSTINF_DBG,
+			"Received association response = %d\n",
+			assoc_resp_info_len);
+		if (assoc_resp_info_len != 0) {
+			s32 err = 0;
+
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Parsing association response\n");
+			err = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,
+							 assoc_resp_info_len,
+							 &conn_info);
+			if (err)
+				PRINT_ER(vif->ndev,
+					 "wilc_parse_assoc_resp_info() returned error %d\n",
+					 err);
 		}
+	}
 
-		u8MsgType = pstrRcvdGnrlAsyncInfo->buffer[0];
+	if (hif_drv->usr_conn_req.bssid) {
+		memcpy(conn_info.bssid, hif_drv->usr_conn_req.bssid, 6);
 
-		if ('I' != u8MsgType) {
-			netdev_err(vif->ndev, "Received Message incorrect.\n");
-			return -EFAULT;
+		if (mac_status == MAC_STATUS_CONNECTED &&
+		    conn_info.status == WLAN_STATUS_SUCCESS) {
+			memcpy(hif_drv->assoc_bssid,
+			       hif_drv->usr_conn_req.bssid, ETH_ALEN);
 		}
+	}
 
-		u8MsgID = pstrRcvdGnrlAsyncInfo->buffer[1];
-		u16MsgLen = MAKE_WORD16(pstrRcvdGnrlAsyncInfo->buffer[2], pstrRcvdGnrlAsyncInfo->buffer[3]);
-		u16WidID = MAKE_WORD16(pstrRcvdGnrlAsyncInfo->buffer[4], pstrRcvdGnrlAsyncInfo->buffer[5]);
-		u8WidLen = pstrRcvdGnrlAsyncInfo->buffer[6];
-		u8MacStatus  = pstrRcvdGnrlAsyncInfo->buffer[7];
-		u8MacStatusReasonCode = pstrRcvdGnrlAsyncInfo->buffer[8];
-		u8MacStatusAdditionalInfo = pstrRcvdGnrlAsyncInfo->buffer[9];
-		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
-			u32 u32RcvdAssocRespInfoLen = 0;
-			struct connect_resp_info *pstrConnectRespInfo = NULL;
-
-			memset(&strConnectInfo, 0, sizeof(struct connect_info));
-
-			if (u8MacStatus == MAC_CONNECTED) {
-				memset(rcv_assoc_resp, 0, MAX_ASSOC_RESP_FRAME_SIZE);
-
-				host_int_get_assoc_res_info(vif,
-							    rcv_assoc_resp,
-							    MAX_ASSOC_RESP_FRAME_SIZE,
-							    &u32RcvdAssocRespInfoLen);
-
-				if (u32RcvdAssocRespInfoLen != 0) {
-					s32Err = wilc_parse_assoc_resp_info(rcv_assoc_resp, u32RcvdAssocRespInfoLen,
-									    &pstrConnectRespInfo);
-					if (s32Err) {
-						netdev_err(vif->ndev, "wilc_parse_assoc_resp_info() returned error %d\n", s32Err);
-					} else {
-						strConnectInfo.status = pstrConnectRespInfo->status;
-
-						if (strConnectInfo.status == SUCCESSFUL_STATUSCODE && pstrConnectRespInfo->ies) {
-							strConnectInfo.resp_ies_len = pstrConnectRespInfo->ies_len;
-							strConnectInfo.resp_ies = kmalloc(pstrConnectRespInfo->ies_len, GFP_KERNEL);
-							memcpy(strConnectInfo.resp_ies, pstrConnectRespInfo->ies,
-							       pstrConnectRespInfo->ies_len);
-						}
-
-						if (pstrConnectRespInfo) {
-							kfree(pstrConnectRespInfo->ies);
-							kfree(pstrConnectRespInfo);
-						}
-					}
-				}
-			}
+	if (hif_drv->usr_conn_req.ies) {
+		conn_info.req_ies = kmemdup(hif_drv->usr_conn_req.ies,
+					    hif_drv->usr_conn_req.ies_len,
+					    GFP_KERNEL);
+		if (conn_info.req_ies)
+			conn_info.req_ies_len = hif_drv->usr_conn_req.ies_len;
+	}
 
-			if ((u8MacStatus == MAC_CONNECTED) &&
-			    (strConnectInfo.status != SUCCESSFUL_STATUSCODE))	{
-				netdev_err(vif->ndev, "Received MAC status is MAC_CONNECTED while the received status code in Asoc Resp is not SUCCESSFUL_STATUSCODE\n");
-				eth_zero_addr(wilc_connected_ssid);
-			} else if (u8MacStatus == MAC_DISCONNECTED)    {
-				netdev_err(vif->ndev, "Received MAC status is MAC_DISCONNECTED\n");
-				eth_zero_addr(wilc_connected_ssid);
-			}
+	del_timer(&hif_drv->connect_timer);
+	hif_drv->usr_conn_req.conn_result(EVENT_CONN_RESP,
+					  &conn_info, mac_status, NULL,
+					  hif_drv->usr_conn_req.arg);
 
-			if (hif_drv->usr_conn_req.bssid) {
-				memcpy(strConnectInfo.bssid, hif_drv->usr_conn_req.bssid, 6);
+	if (mac_status == MAC_STATUS_CONNECTED &&
+	    conn_info.status == WLAN_STATUS_SUCCESS) {
 
-				if ((u8MacStatus == MAC_CONNECTED) &&
-				    (strConnectInfo.status == SUCCESSFUL_STATUSCODE))	{
-					memcpy(hif_drv->assoc_bssid,
-					       hif_drv->usr_conn_req.bssid, ETH_ALEN);
-				}
-			}
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : CONNECTED and Connect Status : Successful\n");
+		hif_drv->hif_state = HOST_IF_CONNECTED;
 
-			if (hif_drv->usr_conn_req.ies) {
-				strConnectInfo.req_ies_len = hif_drv->usr_conn_req.ies_len;
-				strConnectInfo.req_ies = kmalloc(hif_drv->usr_conn_req.ies_len, GFP_KERNEL);
-				memcpy(strConnectInfo.req_ies,
-				       hif_drv->usr_conn_req.ies,
-				       hif_drv->usr_conn_req.ies_len);
-			}
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_for_IP(vif, IP_STATE_OBTAINING);
+#endif
+	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : %d and Connect Status : %d\n",
+			   mac_status, conn_info.status);
+		hif_drv->hif_state = HOST_IF_IDLE;
+	}
 
-			del_timer(&hif_drv->connect_timer);
-			hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
-							  &strConnectInfo,
-							  u8MacStatus,
-							  NULL,
-							  hif_drv->usr_conn_req.arg);
+	kfree(conn_info.resp_ies);
+	conn_info.resp_ies = NULL;
 
-			if ((u8MacStatus == MAC_CONNECTED) &&
-			    (strConnectInfo.status == SUCCESSFUL_STATUSCODE))	{
-				wilc_set_power_mgmt(vif, 0, 0);
+	kfree(conn_info.req_ies);
+	conn_info.req_ies = NULL;
+	host_int_free_user_conn_req(hif_drv);
+}
 
-				hif_drv->hif_state = HOST_IF_CONNECTED;
+static inline void host_int_handle_disconnect(struct wilc_vif *vif)
+{
+	struct disconnect_info disconn_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	wilc_connect_result conn_result = hif_drv->usr_conn_req.conn_result;
 
-				wilc_optaining_ip = true;
-				mod_timer(&wilc_during_ip_timer,
-					  jiffies + msecs_to_jiffies(10000));
-			} else {
-				hif_drv->hif_state = HOST_IF_IDLE;
-				scan_while_connected = false;
-			}
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received MAC_STATUS_DISCONNECTED from the FW\n");
+	memset(&disconn_info, 0, sizeof(struct disconnect_info));
 
-			kfree(strConnectInfo.resp_ies);
-			strConnectInfo.resp_ies = NULL;
-
-			kfree(strConnectInfo.req_ies);
-			strConnectInfo.req_ies = NULL;
-			hif_drv->usr_conn_req.ssid_len = 0;
-			kfree(hif_drv->usr_conn_req.ssid);
-			hif_drv->usr_conn_req.ssid = NULL;
-			kfree(hif_drv->usr_conn_req.bssid);
-			hif_drv->usr_conn_req.bssid = NULL;
-			hif_drv->usr_conn_req.ies_len = 0;
-			kfree(hif_drv->usr_conn_req.ies);
-			hif_drv->usr_conn_req.ies = NULL;
-		} else if ((u8MacStatus == MAC_DISCONNECTED) &&
-			   (hif_drv->hif_state == HOST_IF_CONNECTED)) {
-			memset(&strDisconnectNotifInfo, 0, sizeof(struct disconnect_info));
+	if (hif_drv->usr_scan_req.scan_result) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "\n\n<< Abort the running OBSS Scan >>\n\n");
+		del_timer(&hif_drv->scan_timer);
+		handle_scan_done(vif, SCAN_EVENT_ABORTED);
+	}
 
-			if (hif_drv->usr_scan_req.scan_result) {
-				del_timer(&hif_drv->scan_timer);
-				Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
-			}
+	disconn_info.reason = 0;
+	disconn_info.ie = NULL;
+	disconn_info.ie_len = 0;
 
-			strDisconnectNotifInfo.reason = 0;
-			strDisconnectNotifInfo.ie = NULL;
-			strDisconnectNotifInfo.ie_len = 0;
+	if (conn_result) {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_for_IP(vif, IP_STATE_DEFAULT);
+#endif
 
-			if (hif_drv->usr_conn_req.conn_result) {
-				wilc_optaining_ip = false;
-				wilc_set_power_mgmt(vif, 0, 0);
+		conn_result(EVENT_DISCONN_NOTIF,
+			    NULL, 0, &disconn_info, hif_drv->usr_conn_req.arg);
+	} else {
+		PRINT_ER(vif->ndev, "Connect result NULL\n");
+	}
 
-				hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
-								  NULL,
-								  0,
-								  &strDisconnectNotifInfo,
-								  hif_drv->usr_conn_req.arg);
-			} else {
-				netdev_err(vif->ndev, "Connect result NULL\n");
-			}
+	eth_zero_addr(hif_drv->assoc_bssid);
 
-			eth_zero_addr(hif_drv->assoc_bssid);
+	host_int_free_user_conn_req(hif_drv);
+	hif_drv->hif_state = HOST_IF_IDLE;
+}
 
-			hif_drv->usr_conn_req.ssid_len = 0;
-			kfree(hif_drv->usr_conn_req.ssid);
-			hif_drv->usr_conn_req.ssid = NULL;
-			kfree(hif_drv->usr_conn_req.bssid);
-			hif_drv->usr_conn_req.bssid = NULL;
-			hif_drv->usr_conn_req.ies_len = 0;
-			kfree(hif_drv->usr_conn_req.ies);
-			hif_drv->usr_conn_req.ies = NULL;
+static void handle_rcvd_gnrl_async_info(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct rcvd_async_info *rcvd_info = &msg->body.async_info;
+	u8 msg_type;
+	u8 mac_status;
+	u8 mac_status_reason_code;
+	u8 mac_status_additional_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
 
-			if (join_req && join_req_vif == vif) {
-				kfree(join_req);
-				join_req = NULL;
-			}
+	if (!rcvd_info->buffer) {
+		netdev_err(vif->ndev, "buffer is NULL\n");
+		goto free_msg;
+	}
 
-			if (info_element && join_req_vif == vif) {
-				kfree(info_element);
-				info_element = NULL;
-			}
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto free_rcvd_info;
+	}
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Current State = %d,Received state = %d\n",
+		   hif_drv->hif_state,
+		   rcvd_info->buffer[7]);
 
-			hif_drv->hif_state = HOST_IF_IDLE;
-			scan_while_connected = false;
+	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
+	    hif_drv->hif_state == HOST_IF_CONNECTED ||
+	    hif_drv->usr_scan_req.scan_result) {
+		if (!hif_drv->usr_conn_req.conn_result) {
+			PRINT_ER(vif->ndev, "conn_result is NULL\n");
+			goto free_rcvd_info;
+		}
+
+		msg_type = rcvd_info->buffer[0];
+
+		if ('I' != msg_type) {
+			PRINT_ER(vif->ndev, "Received Message incorrect.\n");
+			goto free_rcvd_info;
+		}
 
-		} else if ((u8MacStatus == MAC_DISCONNECTED) &&
+		mac_status  = rcvd_info->buffer[7];
+		mac_status_reason_code = rcvd_info->buffer[8];
+		mac_status_additional_info = rcvd_info->buffer[9];
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "Recieved MAC status= %d Reason= %d Info = %d\n",
+			   mac_status, mac_status_reason_code,
+			   mac_status_additional_info);
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+			host_int_parse_assoc_resp_info(vif, mac_status);
+		} else if ((mac_status == MAC_STATUS_DISCONNECTED) &&
+			   (hif_drv->hif_state == HOST_IF_CONNECTED)) {
+			host_int_handle_disconnect(vif);
+		} else if ((mac_status == MAC_STATUS_DISCONNECTED) &&
 			   (hif_drv->usr_scan_req.scan_result)) {
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				  "Received MAC_STATUS_DISCONNECTED. Abort the running Scan");
 			del_timer(&hif_drv->scan_timer);
 			if (hif_drv->usr_scan_req.scan_result)
-				Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
+				handle_scan_done(vif, SCAN_EVENT_ABORTED);
 		}
 	}
 
-	kfree(pstrRcvdGnrlAsyncInfo->buffer);
-	pstrRcvdGnrlAsyncInfo->buffer = NULL;
+free_rcvd_info:
+	kfree(rcvd_info->buffer);
+	rcvd_info->buffer = NULL;
 
-	return result;
+free_msg:
+	kfree(msg);
 }
 
-static int Handle_Key(struct wilc_vif *vif,
-		      struct key_attr *pstrHostIFkeyAttr)
+static int wilc_pmksa_key_copy(struct wilc_vif *vif, struct key_attr *hif_key)
 {
-	s32 result = 0;
+	int i;
+	int ret;
 	struct wid wid;
-	struct wid strWIDList[5];
-	u8 i;
-	u8 *pu8keybuf;
-	s8 s8idxarray[1];
-	s8 ret = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 *key_buf;
 
-	switch (pstrHostIFkeyAttr->type) {
-	case WEP:
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling PMKSA key\n");
+	key_buf = kmalloc((hif_key->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1,
+			  GFP_KERNEL);
+	if (!key_buf) {
+		PRINT_ER(vif->ndev, "No buffer to send PMKSA Key\n");
+		return -ENOMEM;
+	}
 
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wep.mode;
+	key_buf[0] = hif_key->attr.pmkid.numpmkid;
 
-			strWIDList[1].id = WID_AUTH_TYPE;
-			strWIDList[1].type = WID_CHAR;
-			strWIDList[1].size = sizeof(char);
-			strWIDList[1].val = (s8 *)&pstrHostIFkeyAttr->attr.wep.auth_type;
+	for (i = 0; i < hif_key->attr.pmkid.numpmkid; i++) {
+		memcpy(key_buf + ((PMKSA_KEY_LEN * i) + 1),
+		       hif_key->attr.pmkid.pmkidlist[i].bssid, ETH_ALEN);
+		memcpy(key_buf + ((PMKSA_KEY_LEN * i) + ETH_ALEN + 1),
+		       hif_key->attr.pmkid.pmkidlist[i].pmkid, PMKID_LEN);
+	}
 
-			pu8keybuf = kmalloc(pstrHostIFkeyAttr->attr.wep.key_len + 2,
-					    GFP_KERNEL);
-			if (!pu8keybuf)
-				return -ENOMEM;
+	wid.id = WID_PMKID_INFO;
+	wid.type = WID_STR;
+	wid.val = (s8 *)key_buf;
+	wid.size = (hif_key->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1;
 
-			pu8keybuf[0] = pstrHostIFkeyAttr->attr.wep.index;
-			pu8keybuf[1] = pstrHostIFkeyAttr->attr.wep.key_len;
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
 
-			memcpy(&pu8keybuf[2], pstrHostIFkeyAttr->attr.wep.key,
-			       pstrHostIFkeyAttr->attr.wep.key_len);
+	kfree(key_buf);
 
-			kfree(pstrHostIFkeyAttr->attr.wep.key);
+	return ret;
+}
 
-			strWIDList[2].id = (u16)WID_WEP_KEY_VALUE;
-			strWIDList[2].type = WID_STR;
-			strWIDList[2].size = pstrHostIFkeyAttr->attr.wep.key_len + 2;
-			strWIDList[2].val = (s8 *)pu8keybuf;
+static void handle_key(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct key_attr *hif_key = &msg->body.key_info;
+	int result = 0;
+	struct wid wid;
+	struct wid wid_list[5];
+	u8 *key_buf;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	switch (hif_key->type) {
+	case WEP:
+
+		if (hif_key->action & ADDKEY_AP) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Handling WEP key index: %d\n",
+				   hif_key->attr.wep.index);
+			wid_list[0].id = WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wep.mode;
+
+			wid_list[1].id = WID_AUTH_TYPE;
+			wid_list[1].type = WID_CHAR;
+			wid_list[1].size = sizeof(char);
+			wid_list[1].val = (s8 *)&hif_key->attr.wep.auth_type;
+
+			key_buf = kmalloc(hif_key->attr.wep.key_len + 2,
+					  GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send Key\n");
+				result = -ENOMEM;
+				goto out_wep;
+			}
+
+			key_buf[0] = hif_key->attr.wep.index;
+			key_buf[1] = hif_key->attr.wep.key_len;
+
+			memcpy(&key_buf[2], hif_key->attr.wep.key,
+			       hif_key->attr.wep.key_len);
+
+			wid_list[2].id = WID_WEP_KEY_VALUE;
+			wid_list[2].type = WID_STR;
+			wid_list[2].size = hif_key->attr.wep.key_len + 2;
+			wid_list[2].val = (s8 *)key_buf;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 3,
+						      wid_list, 3,
 						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kmalloc(pstrHostIFkeyAttr->attr.wep.key_len + 2, GFP_KERNEL);
-			if (!pu8keybuf)
-				return -ENOMEM;
-			pu8keybuf[0] = pstrHostIFkeyAttr->attr.wep.index;
-			memcpy(pu8keybuf + 1, &pstrHostIFkeyAttr->attr.wep.key_len, 1);
-			memcpy(pu8keybuf + 2, pstrHostIFkeyAttr->attr.wep.key,
-			       pstrHostIFkeyAttr->attr.wep.key_len);
-			kfree(pstrHostIFkeyAttr->attr.wep.key);
-
-			wid.id = (u16)WID_ADD_WEP_KEY;
+			kfree(key_buf);
+		} else if (hif_key->action & ADDKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Handling WEP key\n");
+			key_buf = kmalloc(hif_key->attr.wep.key_len + 2,
+					  GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send Key\n");
+				result = -ENOMEM;
+				goto out_wep;
+			}
+			key_buf[0] = hif_key->attr.wep.index;
+			memcpy(key_buf + 1, &hif_key->attr.wep.key_len, 1);
+			memcpy(key_buf + 2, hif_key->attr.wep.key,
+			       hif_key->attr.wep.key_len);
+
+			wid.id = WID_ADD_WEP_KEY;
 			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
-			wid.size = pstrHostIFkeyAttr->attr.wep.key_len + 2;
+			wid.val = (s8 *)key_buf;
+			wid.size = hif_key->attr.wep.key_len + 2;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
 						      &wid, 1,
 						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-		} else if (pstrHostIFkeyAttr->action & REMOVEKEY) {
-			wid.id = (u16)WID_REMOVE_WEP_KEY;
+			kfree(key_buf);
+		} else if (hif_key->action & REMOVEKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, "Removing key\n");
+			wid.id = WID_REMOVE_WEP_KEY;
 			wid.type = WID_STR;
 
-			s8idxarray[0] = (s8)pstrHostIFkeyAttr->attr.wep.index;
-			wid.val = s8idxarray;
+			wid.val = (s8 *)&hif_key->attr.wep.index;
 			wid.size = 1;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
 						      &wid, 1,
 						      wilc_get_vif_idx(vif));
-		} else if (pstrHostIFkeyAttr->action & DEFAULTKEY) {
-			wid.id = (u16)WID_KEY_ID;
+		} else if (hif_key->action & DEFAULTKEY) {
+			wid.id = WID_KEY_ID;
 			wid.type = WID_CHAR;
-			wid.val = (s8 *)&pstrHostIFkeyAttr->attr.wep.index;
+			wid.val = (s8 *)&hif_key->attr.wep.index;
 			wid.size = sizeof(char);
 
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Setting default key index\n");
 			result = wilc_send_config_pkt(vif, SET_CFG,
 						      &wid, 1,
 						      wilc_get_vif_idx(vif));
 		}
-		complete(&hif_drv->comp_test_key_block);
+out_wep:
+		complete(&msg->work_comp);
 		break;
 
 	case WPA_RX_GTK:
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			pu8keybuf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPARxGtk_end_case_;
+		if (hif_key->action & ADDKEY_AP) {
+			key_buf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev,
+					 "No buffer to send RxGTK Key\n");
+				result = -ENOMEM;
+				goto out_wpa_rx_gtk;
 			}
 
-			if (pstrHostIFkeyAttr->attr.wpa.seq)
-				memcpy(pu8keybuf + 6, pstrHostIFkeyAttr->attr.wpa.seq, 8);
+			if (hif_key->attr.wpa.seq)
+				memcpy(key_buf + 6, hif_key->attr.wpa.seq, 8);
 
-			memcpy(pu8keybuf + 14, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 15, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 16, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
+			memcpy(key_buf + 14, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 15, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 16, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
 
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wpa.mode;
+			wid_list[0].id = WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wpa.mode;
 
-			strWIDList[1].id = (u16)WID_ADD_RX_GTK;
-			strWIDList[1].type = WID_STR;
-			strWIDList[1].val = (s8 *)pu8keybuf;
-			strWIDList[1].size = RX_MIC_KEY_MSG_LEN;
+			wid_list[1].id = WID_ADD_RX_GTK;
+			wid_list[1].type = WID_STR;
+			wid_list[1].val = (s8 *)key_buf;
+			wid_list[1].size = RX_MIC_KEY_MSG_LEN;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 2,
+						      wid_list, 2,
 						      wilc_get_vif_idx(vif));
 
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPARxGtk_end_case_;
+			kfree(key_buf);
+		} else if (hif_key->action & ADDKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Handling group key(Rx) function\n");
+			key_buf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev,
+					 "No buffer to send RxGTK Key\n");
+				result = -ENOMEM;
+				goto out_wpa_rx_gtk;
 			}
 
 			if (hif_drv->hif_state == HOST_IF_CONNECTED)
-				memcpy(pu8keybuf, hif_drv->assoc_bssid, ETH_ALEN);
+				memcpy(key_buf, hif_drv->assoc_bssid, ETH_ALEN);
 			else
-				netdev_err(vif->ndev, "Couldn't handle\n");
+				PRINT_ER(vif->ndev, "Couldn't handle\n");
 
-			memcpy(pu8keybuf + 6, pstrHostIFkeyAttr->attr.wpa.seq, 8);
-			memcpy(pu8keybuf + 14, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 15, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 16, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
+			memcpy(key_buf + 6, hif_key->attr.wpa.seq, 8);
+			memcpy(key_buf + 14, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 15, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 16, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
 
-			wid.id = (u16)WID_ADD_RX_GTK;
+			wid.id = WID_ADD_RX_GTK;
 			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
+			wid.val = (s8 *)key_buf;
 			wid.size = RX_MIC_KEY_MSG_LEN;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
 						      &wid, 1,
 						      wilc_get_vif_idx(vif));
 
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
+			kfree(key_buf);
 		}
-_WPARxGtk_end_case_:
-		kfree(pstrHostIFkeyAttr->attr.wpa.key);
-		kfree(pstrHostIFkeyAttr->attr.wpa.seq);
-		if (ret)
-			return ret;
-
+out_wpa_rx_gtk:
+		complete(&msg->work_comp);
 		break;
 
 	case WPA_PTK:
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			pu8keybuf = kmalloc(PTK_KEY_MSG_LEN + 1, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPAPtk_end_case_;
+		if (hif_key->action & ADDKEY_AP) {
+			key_buf = kmalloc(PTK_KEY_MSG_LEN + 1, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev,
+					 "No buffer to send PTK Key\n");
+				result = -ENOMEM;
+				goto out_wpa_ptk;
 			}
 
-			memcpy(pu8keybuf, pstrHostIFkeyAttr->attr.wpa.mac_addr, 6);
-			memcpy(pu8keybuf + 6, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 7, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 8, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
+			memcpy(key_buf, hif_key->attr.wpa.mac_addr, 6);
+			memcpy(key_buf + 6, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 7, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 8, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
 
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wpa.mode;
+			wid_list[0].id = WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wpa.mode;
 
-			strWIDList[1].id = (u16)WID_ADD_PTK;
-			strWIDList[1].type = WID_STR;
-			strWIDList[1].val = (s8 *)pu8keybuf;
-			strWIDList[1].size = PTK_KEY_MSG_LEN + 1;
+			wid_list[1].id = WID_ADD_PTK;
+			wid_list[1].type = WID_STR;
+			wid_list[1].val = (s8 *)key_buf;
+			wid_list[1].size = PTK_KEY_MSG_LEN + 1;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 2,
+						      wid_list, 2,
 						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kmalloc(PTK_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				netdev_err(vif->ndev, "No buffer send PTK\n");
-				ret = -ENOMEM;
-				goto _WPAPtk_end_case_;
+			kfree(key_buf);
+		} else if (hif_key->action & ADDKEY) {
+			key_buf = kmalloc(PTK_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				result = -ENOMEM;
+				goto out_wpa_ptk;
 			}
 
-			memcpy(pu8keybuf, pstrHostIFkeyAttr->attr.wpa.mac_addr, 6);
-			memcpy(pu8keybuf + 6, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 7, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
+			memcpy(key_buf, hif_key->attr.wpa.mac_addr, 6);
+			memcpy(key_buf + 6, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 7, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
 
-			wid.id = (u16)WID_ADD_PTK;
+			wid.id = WID_ADD_PTK;
 			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
+			wid.val = (s8 *)key_buf;
 			wid.size = PTK_KEY_MSG_LEN;
 
 			result = wilc_send_config_pkt(vif, SET_CFG,
 						      &wid, 1,
 						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
+			kfree(key_buf);
 		}
 
-_WPAPtk_end_case_:
-		kfree(pstrHostIFkeyAttr->attr.wpa.key);
-		if (ret)
-			return ret;
-
+out_wpa_ptk:
+		complete(&msg->work_comp);
 		break;
 
 	case PMKSA:
-		pu8keybuf = kmalloc((pstrHostIFkeyAttr->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1, GFP_KERNEL);
-		if (!pu8keybuf)
-			return -ENOMEM;
-
-		pu8keybuf[0] = pstrHostIFkeyAttr->attr.pmkid.numpmkid;
-
-		for (i = 0; i < pstrHostIFkeyAttr->attr.pmkid.numpmkid; i++) {
-			memcpy(pu8keybuf + ((PMKSA_KEY_LEN * i) + 1), pstrHostIFkeyAttr->attr.pmkid.pmkidlist[i].bssid, ETH_ALEN);
-			memcpy(pu8keybuf + ((PMKSA_KEY_LEN * i) + ETH_ALEN + 1), pstrHostIFkeyAttr->attr.pmkid.pmkidlist[i].pmkid, PMKID_LEN);
-		}
-
-		wid.id = (u16)WID_PMKID_INFO;
-		wid.type = WID_STR;
-		wid.val = (s8 *)pu8keybuf;
-		wid.size = (pstrHostIFkeyAttr->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1;
-
-		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-					      wilc_get_vif_idx(vif));
-
-		kfree(pu8keybuf);
+		result = wilc_pmksa_key_copy(vif, hif_key);
+		/*free 'msg', this case it not a sync call*/
+		kfree(msg);
 		break;
 	}
 
 	if (result)
-		netdev_err(vif->ndev, "Failed to send key config packet\n");
+		PRINT_ER(vif->ndev, "Failed to send key config packet\n");
 
-	return result;
+	/* free 'msg' data in caller sync call */
 }
 
-static void Handle_Disconnect(struct wilc_vif *vif)
+static void handle_disconnect(struct work_struct *work)
 {
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct disconnect_info disconn_info;
+	struct user_scan_req *scan_req;
+	struct user_conn_req *conn_req;
+	int result;
+	u16 dummy_reason_code = 0;
+	struct host_if_drv *hif_drv_p2p = get_drv_hndl_by_ifc(vif->wilc,
+							      P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = get_drv_hndl_by_ifc(vif->wilc,
+							       WLAN_IFC);
 
-	s32 result = 0;
-	u16 u16DummyReasonCode = 0;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
+	}
 
-	wid.id = (u16)WID_DISCONNECT;
+	if (hif_drv_wlan != NULL)	{
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Abort Scan. WLAN_IFC is in state [%d]\n",
+				   hif_drv_wlan->hif_state);
+			del_timer(&(hif_drv_wlan->scan_timer));
+			handle_scan_done(vif, SCAN_EVENT_ABORTED);
+		}
+	}
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Abort Scan. P2P_IFC is in state [%d]\n",
+				   hif_drv_p2p->hif_state);
+			del_timer(&(hif_drv_p2p->scan_timer));
+			handle_scan_done(vif, SCAN_EVENT_ABORTED);
+		}
+	}
+	wid.id = WID_DISCONNECT;
 	wid.type = WID_CHAR;
-	wid.val = (s8 *)&u16DummyReasonCode;
+	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
-	wilc_optaining_ip = false;
-	wilc_set_power_mgmt(vif, 0, 0);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
 
-	eth_zero_addr(wilc_connected_ssid);
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	handle_pwrsave_for_IP(vif, IP_STATE_DEFAULT);
+#endif
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send dissconect\n");
-	} else {
-		struct disconnect_info strDisconnectNotifInfo;
+		PRINT_ER(vif->ndev, "Failed to send dissconect\n");
+		goto out;
+	}
 
-		memset(&strDisconnectNotifInfo, 0, sizeof(struct disconnect_info));
+	memset(&disconn_info, 0, sizeof(struct disconnect_info));
 
-		strDisconnectNotifInfo.reason = 0;
-		strDisconnectNotifInfo.ie = NULL;
-		strDisconnectNotifInfo.ie_len = 0;
+	disconn_info.reason = 0;
+	disconn_info.ie = NULL;
+	disconn_info.ie_len = 0;
+	scan_req = &hif_drv->usr_scan_req;
+	conn_req = &hif_drv->usr_conn_req;
 
-		if (hif_drv->usr_scan_req.scan_result) {
-			del_timer(&hif_drv->scan_timer);
-			hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED,
-							  NULL,
-							  hif_drv->usr_scan_req.arg,
-							  NULL);
-			hif_drv->usr_scan_req.scan_result = NULL;
-		}
-
-		if (hif_drv->usr_conn_req.conn_result) {
-			if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
-				del_timer(&hif_drv->connect_timer);
+	if (scan_req->scan_result) {
+		del_timer(&hif_drv->scan_timer);
+		scan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->arg,
+				      NULL);
+		scan_req->scan_result = NULL;
+	}
 
-			hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
-							  NULL,
-							  0,
-							  &strDisconnectNotifInfo,
-							  hif_drv->usr_conn_req.arg);
-		} else {
-			netdev_err(vif->ndev, "conn_result = NULL\n");
-		}
+	if (conn_req->conn_result) {
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+			struct connect_info connect;
 
-		scan_while_connected = false;
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "supplicant requested disconnection\n");
+			memset(&connect, 0, sizeof(struct connect_info));
+			del_timer(&hif_drv->connect_timer);
+			if (conn_req->bssid != NULL)
+				memcpy(connect.bssid, conn_req->bssid, 6);
+			if (conn_req->ies != NULL) {
+				connect.req_ies_len = conn_req->ies_len;
+				connect.req_ies = kmalloc(conn_req->ies_len,
+							  GFP_ATOMIC);
+				memcpy(connect.req_ies,
+				       conn_req->ies,
+				       conn_req->ies_len);
+			}
+			conn_req->conn_result(EVENT_CONN_RESP,
+					      &connect,
+					      MAC_STATUS_DISCONNECTED, NULL,
+					      conn_req->arg);
+
+			if (connect.req_ies != NULL) {
+				kfree(connect.req_ies);
+				connect.req_ies = NULL;
+			}
 
-		hif_drv->hif_state = HOST_IF_IDLE;
+		} else if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			conn_req->conn_result(EVENT_DISCONN_NOTIF,
+					      NULL, 0, &disconn_info,
+					      conn_req->arg);
+		}
+	} else {
+		PRINT_ER(vif->ndev, "conn_result = NULL\n");
+	}
 
-		eth_zero_addr(hif_drv->assoc_bssid);
+	hif_drv->hif_state = HOST_IF_IDLE;
 
-		hif_drv->usr_conn_req.ssid_len = 0;
-		kfree(hif_drv->usr_conn_req.ssid);
-		hif_drv->usr_conn_req.ssid = NULL;
-		kfree(hif_drv->usr_conn_req.bssid);
-		hif_drv->usr_conn_req.bssid = NULL;
-		hif_drv->usr_conn_req.ies_len = 0;
-		kfree(hif_drv->usr_conn_req.ies);
-		hif_drv->usr_conn_req.ies = NULL;
+	eth_zero_addr(hif_drv->assoc_bssid);
 
-		if (join_req && join_req_vif == vif) {
-			kfree(join_req);
-			join_req = NULL;
-		}
+	conn_req->ssid_len = 0;
+	kfree(conn_req->ssid);
+	conn_req->ssid = NULL;
+	kfree(conn_req->bssid);
+	conn_req->bssid = NULL;
+	conn_req->ies_len = 0;
+	kfree(conn_req->ies);
+	conn_req->ies = NULL;
 
-		if (info_element && join_req_vif == vif) {
-			kfree(info_element);
-			info_element = NULL;
-		}
-	}
+out:
 
-	complete(&hif_drv->comp_test_disconn_block);
+	complete(&msg->work_comp);
+	/* free 'msg' in caller after receiving completion */
 }
 
 void wilc_resolve_disconnect_aberration(struct wilc_vif *vif)
 {
 	if (!vif->hif_drv)
 		return;
-	if ((vif->hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) ||
-	    (vif->hif_drv->hif_state == HOST_IF_CONNECTING))
+	if (vif->hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
+	    vif->hif_drv->hif_state == HOST_IF_CONNECTING) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "\n\n<< correcting Supplicant state machine >>\n\n");
 		wilc_disconnect(vif, 1);
+	}
 }
 
-static void Handle_GetRssi(struct wilc_vif *vif)
+static void handle_get_rssi(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	int result;
 	struct wid wid;
 
-	wid.id = (u16)WID_RSSI;
+	wid.id = WID_RSSI;
 	wid.type = WID_CHAR;
-	wid.val = &rssi;
+	wid.val = msg->body.data;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Getting RSSI value\n");
 	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result) {
-		netdev_err(vif->ndev, "Failed to get RSSI value\n");
-		result = -EFAULT;
+		PRINT_ER(vif->ndev, "Failed to get RSSI value\n");
+		*msg->body.data = INVALID_RSSI;
 	}
 
-	complete(&vif->hif_drv->comp_get_rssi);
+	complete(&msg->work_comp);
+	/* free 'msg' data in caller */
 }
 
-static s32 Handle_GetStatistics(struct wilc_vif *vif,
-				struct rf_info *pstrStatistics)
+static void handle_get_statistics(struct work_struct *work)
 {
-	struct wid strWIDList[5];
-	u32 u32WidsCount = 0, result = 0;
-
-	strWIDList[u32WidsCount].id = WID_LINKSPEED;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->link_speed;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RSSI;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->rssi;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_SUCCESS_FRAME_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->tx_cnt;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RECEIVED_FRAGMENT_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->rx_cnt;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_FAILED_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->tx_fail_cnt;
-	u32WidsCount++;
-
-	result = wilc_send_config_pkt(vif, GET_CFG, strWIDList,
-				      u32WidsCount,
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct wid wid_list[5];
+	u32 wid_cnt = 0, result;
+	struct rf_info *stats = (struct rf_info *)msg->body.data;
+
+	wid_list[wid_cnt].id = WID_LINKSPEED;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&stats->link_speed;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RSSI;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&stats->rssi;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->tx_cnt;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->rx_cnt;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_FAILED_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->tx_fail_cnt;
+	wid_cnt++;
+
+	result = wilc_send_config_pkt(vif, GET_CFG, wid_list,
+				      wid_cnt,
 				      wilc_get_vif_idx(vif));
 
 	if (result)
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
-
-	if (pstrStatistics->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
-	    pstrStatistics->link_speed != DEFAULT_LINK_SPEED)
-		wilc_enable_tcp_ack_filter(true);
-	else if (pstrStatistics->link_speed != DEFAULT_LINK_SPEED)
-		wilc_enable_tcp_ack_filter(false);
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
+
+	if (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
+	    stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Enable TCP filter\n");
+		wilc_enable_tcp_ack_filter(vif, true);
+	} else if (stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Disable TCP filter %d\n",
+			   stats->link_speed);
+		wilc_enable_tcp_ack_filter(vif, false);
+	}
 
-	if (pstrStatistics != &vif->wilc->dummy_statistics)
-		complete(&hif_wait_response);
-	return 0;
+	/* free 'msg' for async command, for sync caller will free it */
+	if (msg->is_sync)
+		complete(&msg->work_comp);
+	else
+		kfree(msg);
 }
 
-static s32 Handle_Get_InActiveTime(struct wilc_vif *vif,
-				   struct sta_inactive_t *strHostIfStaInactiveT)
+static void handle_get_inactive_time(struct work_struct *work)
 {
-	s32 result = 0;
-	u8 *stamac;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct sta_inactive_t *hif_sta_inactive = &msg->body.mac_info;
+	int result;
 	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
 
-	wid.id = (u16)WID_SET_STA_MAC_INACTIVE_TIME;
+	wid.id = WID_SET_STA_MAC_INACTIVE_TIME;
 	wid.type = WID_STR;
 	wid.size = ETH_ALEN;
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto out;
 
-	stamac = wid.val;
-	ether_addr_copy(stamac, strHostIfStaInactiveT->mac);
+	ether_addr_copy(wid.val, hif_sta_inactive->mac);
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "SETING STA inactive time\n");
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
+	kfree(wid.val);
 
 	if (result) {
-		netdev_err(vif->ndev, "Failed to SET inactive time\n");
-		return -EFAULT;
+		PRINT_ER(vif->ndev, "Failed to SET inactive time\n");
+		goto out;
 	}
 
-	wid.id = (u16)WID_GET_INACTIVE_TIME;
+	wid.id = WID_GET_INACTIVE_TIME;
 	wid.type = WID_INT;
-	wid.val = (s8 *)&inactive_time;
+	wid.val = (s8 *)&hif_sta_inactive->inactive_time;
 	wid.size = sizeof(u32);
 
 	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 
-	if (result) {
-		netdev_err(vif->ndev, "Failed to get inactive time\n");
-		return -EFAULT;
-	}
-
-	complete(&hif_drv->comp_inactive_time);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to get inactive time\n");
 
-	return result;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting inactive time : %d\n",
+		   hif_sta_inactive->inactive_time);
+out:
+	/* free 'msg' data in caller */
+	complete(&msg->work_comp);
 }
 
-static void Handle_AddBeacon(struct wilc_vif *vif,
-			     struct beacon_attr *pstrSetBeaconParam)
+static void handle_add_beacon(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct beacon_attr *param = &msg->body.beacon_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
 
-	wid.id = (u16)WID_ADD_BEACON;
+	wid.id = WID_ADD_BEACON;
 	wid.type = WID_BIN;
-	wid.size = pstrSetBeaconParam->head_len + pstrSetBeaconParam->tail_len + 16;
+	wid.size = param->head_len + param->tail_len + 16;
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
+		goto error;
 
-	pu8CurrByte = wid.val;
-	*pu8CurrByte++ = (pstrSetBeaconParam->interval & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 24) & 0xFF);
+	cur_byte = wid.val;
+	*cur_byte++ = (param->interval & 0xFF);
+	*cur_byte++ = ((param->interval >> 8) & 0xFF);
+	*cur_byte++ = ((param->interval >> 16) & 0xFF);
+	*cur_byte++ = ((param->interval >> 24) & 0xFF);
 
-	*pu8CurrByte++ = (pstrSetBeaconParam->dtim_period & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 24) & 0xFF);
+	*cur_byte++ = (param->dtim_period & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 8) & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 16) & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 24) & 0xFF);
 
-	*pu8CurrByte++ = (pstrSetBeaconParam->head_len & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 24) & 0xFF);
+	*cur_byte++ = (param->head_len & 0xFF);
+	*cur_byte++ = ((param->head_len >> 8) & 0xFF);
+	*cur_byte++ = ((param->head_len >> 16) & 0xFF);
+	*cur_byte++ = ((param->head_len >> 24) & 0xFF);
 
-	memcpy(pu8CurrByte, pstrSetBeaconParam->head, pstrSetBeaconParam->head_len);
-	pu8CurrByte += pstrSetBeaconParam->head_len;
+	memcpy(cur_byte, param->head, param->head_len);
+	cur_byte += param->head_len;
 
-	*pu8CurrByte++ = (pstrSetBeaconParam->tail_len & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 24) & 0xFF);
+	*cur_byte++ = (param->tail_len & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 8) & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 16) & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 24) & 0xFF);
 
-	if (pstrSetBeaconParam->tail)
-		memcpy(pu8CurrByte, pstrSetBeaconParam->tail, pstrSetBeaconParam->tail_len);
-	pu8CurrByte += pstrSetBeaconParam->tail_len;
+	if (param->tail)
+		memcpy(cur_byte, param->tail, param->tail_len);
+	cur_byte += param->tail_len;
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send add beacon\n");
+		PRINT_ER(vif->ndev, "Failed to send add beacon\n");
 
-ERRORHANDLER:
+error:
 	kfree(wid.val);
-	kfree(pstrSetBeaconParam->head);
-	kfree(pstrSetBeaconParam->tail);
+	kfree(param->head);
+	kfree(param->tail);
+	kfree(msg);
 }
 
-static void Handle_DelBeacon(struct wilc_vif *vif)
+static void handle_del_beacon(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 del_beacon = 0;
 
-	wid.id = (u16)WID_DEL_BEACON;
+	wid.id = WID_DEL_BEACON;
 	wid.type = WID_CHAR;
 	wid.size = sizeof(char);
 	wid.val = &del_beacon;
 
-	if (!wid.val)
-		return;
-
-	pu8CurrByte = wid.val;
-
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Deleting BEACON\n");
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send delete beacon\n");
+		PRINT_ER(vif->ndev, "Failed to send delete beacon\n");
+	kfree(msg);
 }
 
-static u32 WILC_HostIf_PackStaParam(u8 *pu8Buffer,
-				    struct add_sta_param *pstrStationParam)
+static u32 wilc_hif_pack_sta_param(struct wilc_vif *vif, u8 *buff,
+				    struct add_sta_param *param)
 {
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
 
-	pu8CurrByte = pu8Buffer;
+	cur_byte = buff;
 
-	memcpy(pu8CurrByte, pstrStationParam->bssid, ETH_ALEN);
-	pu8CurrByte +=  ETH_ALEN;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Packing STA params\n");
+	memcpy(cur_byte, param->bssid, ETH_ALEN);
+	cur_byte +=  ETH_ALEN;
 
-	*pu8CurrByte++ = pstrStationParam->aid & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->aid >> 8) & 0xFF;
+	*cur_byte++ = param->aid & 0xFF;
+	*cur_byte++ = (param->aid >> 8) & 0xFF;
 
-	*pu8CurrByte++ = pstrStationParam->rates_len;
-	if (pstrStationParam->rates_len > 0)
-		memcpy(pu8CurrByte, pstrStationParam->rates,
-		       pstrStationParam->rates_len);
-	pu8CurrByte += pstrStationParam->rates_len;
+	*cur_byte++ = param->rates_len;
+	if (param->rates_len > 0)
+		memcpy(cur_byte, param->rates, param->rates_len);
+	cur_byte += param->rates_len;
 
-	*pu8CurrByte++ = pstrStationParam->ht_supported;
-	memcpy(pu8CurrByte, &pstrStationParam->ht_capa,
-	       sizeof(struct ieee80211_ht_cap));
-	pu8CurrByte += sizeof(struct ieee80211_ht_cap);
+	*cur_byte++ = param->ht_supported;
+	memcpy(cur_byte, &param->ht_capa, sizeof(struct ieee80211_ht_cap));
+	cur_byte += sizeof(struct ieee80211_ht_cap);
 
-	*pu8CurrByte++ = pstrStationParam->flags_mask & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->flags_mask >> 8) & 0xFF;
+	*cur_byte++ = param->flags_mask & 0xFF;
+	*cur_byte++ = (param->flags_mask >> 8) & 0xFF;
 
-	*pu8CurrByte++ = pstrStationParam->flags_set & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->flags_set >> 8) & 0xFF;
+	*cur_byte++ = param->flags_set & 0xFF;
+	*cur_byte++ = (param->flags_set >> 8) & 0xFF;
 
-	return pu8CurrByte - pu8Buffer;
+	return cur_byte - buff;
 }
 
-static void Handle_AddStation(struct wilc_vif *vif,
-			      struct add_sta_param *pstrStationParam)
+static void handle_add_station(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *param = &msg->body.add_sta_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
 
-	wid.id = (u16)WID_ADD_STA;
+	wid.id = WID_ADD_STA;
 	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH + pstrStationParam->rates_len;
+	wid.size = WILC_ADD_STA_LENGTH + param->rates_len;
 
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
+		goto error;
 
-	pu8CurrByte = wid.val;
-	pu8CurrByte += WILC_HostIf_PackStaParam(pu8CurrByte, pstrStationParam);
+	cur_byte = wid.val;
+	cur_byte += wilc_hif_pack_sta_param(vif, cur_byte, param);
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result != 0)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
-ERRORHANDLER:
-	kfree(pstrStationParam->rates);
+error:
+	kfree(param->rates);
 	kfree(wid.val);
+	kfree(msg);
 }
 
-static void Handle_DelAllSta(struct wilc_vif *vif,
-			     struct del_all_sta *pstrDelAllStaParam)
+static void handle_del_all_sta(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct del_all_sta *param = &msg->body.del_all_sta_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *curr_byte;
 	u8 i;
-	u8 au8Zero_Buff[6] = {0};
+	u8 zero_buff[6] = {0};
 
-	wid.id = (u16)WID_DEL_ALL_STA;
+	wid.id = WID_DEL_ALL_STA;
 	wid.type = WID_STR;
-	wid.size = (pstrDelAllStaParam->assoc_sta * ETH_ALEN) + 1;
+	wid.size = (param->assoc_sta * ETH_ALEN) + 1;
 
-	wid.val = kmalloc((pstrDelAllStaParam->assoc_sta * ETH_ALEN) + 1, GFP_KERNEL);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling delete station\n");
+	wid.val = kmalloc((param->assoc_sta * ETH_ALEN) + 1, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
+		goto error;
 
-	pu8CurrByte = wid.val;
+	curr_byte = wid.val;
 
-	*(pu8CurrByte++) = pstrDelAllStaParam->assoc_sta;
+	*(curr_byte++) = param->assoc_sta;
 
 	for (i = 0; i < MAX_NUM_STA; i++) {
-		if (memcmp(pstrDelAllStaParam->del_all_sta[i], au8Zero_Buff, ETH_ALEN))
-			memcpy(pu8CurrByte, pstrDelAllStaParam->del_all_sta[i], ETH_ALEN);
+		if (memcmp(param->del_all_sta[i], zero_buff, ETH_ALEN))
+			memcpy(curr_byte, param->del_all_sta[i], ETH_ALEN);
 		else
 			continue;
 
-		pu8CurrByte += ETH_ALEN;
+		curr_byte += ETH_ALEN;
 	}
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
-ERRORHANDLER:
+error:
 	kfree(wid.val);
 
-	complete(&hif_wait_response);
+	/* free 'msg' data in caller */
+	complete(&msg->work_comp);
 }
 
-static void Handle_DelStation(struct wilc_vif *vif,
-			      struct del_sta *pstrDelStaParam)
+static void handle_del_station(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct del_sta *param = &msg->body.del_sta_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
 
-	wid.id = (u16)WID_REMOVE_STA;
+	wid.id = WID_REMOVE_STA;
 	wid.type = WID_BIN;
 	wid.size = ETH_ALEN;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling delete station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
+		goto error;
 
-	ether_addr_copy(pu8CurrByte, pstrDelStaParam->mac_addr);
+	ether_addr_copy(wid.val, param->mac_addr);
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
-ERRORHANDLER:
+error:
 	kfree(wid.val);
+	kfree(msg);
 }
 
-static void Handle_EditStation(struct wilc_vif *vif,
-			       struct add_sta_param *pstrStationParam)
+static void handle_edit_station(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *param = &msg->body.edit_sta_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
 
-	wid.id = (u16)WID_EDIT_STA;
+	wid.id = WID_EDIT_STA;
 	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH + pstrStationParam->rates_len;
+	wid.size = WILC_ADD_STA_LENGTH + param->rates_len;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling edit station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
+		goto error;
 
-	pu8CurrByte = wid.val;
-	pu8CurrByte += WILC_HostIf_PackStaParam(pu8CurrByte, pstrStationParam);
+	cur_byte = wid.val;
+	cur_byte += wilc_hif_pack_sta_param(vif, cur_byte, param);
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
 	if (result)
-		netdev_err(vif->ndev, "Failed to send edit station\n");
+		PRINT_ER(vif->ndev, "Failed to send edit station\n");
 
-ERRORHANDLER:
-	kfree(pstrStationParam->rates);
+error:
+	kfree(param->rates);
 	kfree(wid.val);
+	kfree(msg);
 }
 
-static int Handle_RemainOnChan(struct wilc_vif *vif,
-			       struct remain_ch *pstrHostIfRemainOnChan)
+static int handle_remain_on_chan(struct wilc_vif *vif,
+				 struct remain_ch *hif_remain_ch)
 {
-	s32 result = 0;
-	u8 u8remain_on_chan_flag;
+	int result;
+	u8 remain_on_chan_flag;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct host_if_drv *hif_drv_p2p = get_drv_hndl_by_ifc(vif->wilc,
+							      P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = get_drv_hndl_by_ifc(vif->wilc,
+							       WLAN_IFC);
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
 
 	if (!hif_drv->remain_on_ch_pending) {
-		hif_drv->remain_on_ch.arg = pstrHostIfRemainOnChan->arg;
-		hif_drv->remain_on_ch.expired = pstrHostIfRemainOnChan->expired;
-		hif_drv->remain_on_ch.ready = pstrHostIfRemainOnChan->ready;
-		hif_drv->remain_on_ch.ch = pstrHostIfRemainOnChan->ch;
-		hif_drv->remain_on_ch.id = pstrHostIfRemainOnChan->id;
+		hif_drv->remain_on_ch.arg = hif_remain_ch->arg;
+		hif_drv->remain_on_ch.expired = hif_remain_ch->expired;
+		hif_drv->remain_on_ch.ready = hif_remain_ch->ready;
+		hif_drv->remain_on_ch.ch = hif_remain_ch->ch;
+		hif_drv->remain_on_ch.id = hif_remain_ch->id;
 	} else {
-		pstrHostIfRemainOnChan->ch = hif_drv->remain_on_ch.ch;
+		hif_remain_ch->ch = hif_drv->remain_on_ch.ch;
 	}
 
-	if (hif_drv->usr_scan_req.scan_result) {
-		hif_drv->remain_on_ch_pending = 1;
-		result = -EBUSY;
-		goto ERRORHANDLER;
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "IFC busy scanning P2P_IFC state %d\n",
+				   hif_drv_p2p->hif_state);
+			hif_drv->remain_on_ch_pending = 1;
+			result = -EBUSY;
+			goto error;
+		} else if ((hif_drv_p2p->hif_state != HOST_IF_IDLE) &&
+		(hif_drv_p2p->hif_state != HOST_IF_CONNECTED)) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "IFC busy connecting. P2P_IFC state %d\n",
+				   hif_drv_p2p->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
 	}
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
-		result = -EBUSY;
-		goto ERRORHANDLER;
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "IFC busy scanning. WLAN_IFC state %d\n",
+				   hif_drv_wlan->hif_state);
+			hif_drv->remain_on_ch_pending = 1;
+			result = -EBUSY;
+			goto error;
+		} else if ((hif_drv_wlan->hif_state != HOST_IF_IDLE) &&
+		(hif_drv_wlan->hif_state != HOST_IF_CONNECTED)) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "IFC busy connecting. WLAN_IFC %d\n",
+				   hif_drv_wlan->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
 	}
 
-	if (wilc_optaining_ip || wilc_connecting) {
+	if (vif->connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
+		result = -EBUSY;
+		goto error;
+	}
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	if (vif->obtaining_ip) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't obss scan until IP adresss is obtained\n");
 		result = -EBUSY;
-		goto ERRORHANDLER;
+		goto error;
 	}
+#endif
 
-	u8remain_on_chan_flag = true;
-	wid.id = (u16)WID_REMAIN_ON_CHAN;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting channel :%d\n",
+		   hif_remain_ch->ch);
+	remain_on_chan_flag = true;
+	wid.id = WID_REMAIN_ON_CHAN;
 	wid.type = WID_STR;
 	wid.size = 2;
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val) {
 		result = -ENOMEM;
-		goto ERRORHANDLER;
+		goto error;
 	}
 
-	wid.val[0] = u8remain_on_chan_flag;
-	wid.val[1] = (s8)pstrHostIfRemainOnChan->ch;
+	wid.val[0] = remain_on_chan_flag;
+	wid.val[1] = (s8)hif_remain_ch->ch;
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
+	kfree(wid.val);
 	if (result != 0)
-		netdev_err(vif->ndev, "Failed to set remain on channel\n");
+		PRINT_ER(vif->ndev, "Failed to set remain on channel\n");
+
+	hif_drv->hif_state = HOST_IF_P2P_LISTEN;
+error:
 
-ERRORHANDLER:
-	{
-		P2P_LISTEN_STATE = 1;
-		hif_drv->remain_on_ch_timer.data = (unsigned long)vif;
-		mod_timer(&hif_drv->remain_on_ch_timer,
+	hif_drv->remain_on_ch_timer_vif = vif;
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	hif_drv->remain_on_ch_timer.data = (unsigned long)hif_drv;
+#endif
+	mod_timer(&hif_drv->remain_on_ch_timer,
 			  jiffies +
-			  msecs_to_jiffies(pstrHostIfRemainOnChan->duration));
+			  msecs_to_jiffies(hif_remain_ch->duration));
 
-		if (hif_drv->remain_on_ch.ready)
-			hif_drv->remain_on_ch.ready(hif_drv->remain_on_ch.arg);
+	if (hif_drv->remain_on_ch.ready)
+		hif_drv->remain_on_ch.ready(hif_drv->remain_on_ch.arg);
 
-		if (hif_drv->remain_on_ch_pending)
-			hif_drv->remain_on_ch_pending = 0;
-	}
+	if (hif_drv->remain_on_ch_pending)
+		hif_drv->remain_on_ch_pending = 0;
 
 	return result;
 }
 
-static int Handle_RegisterFrame(struct wilc_vif *vif,
-				struct reg_frame *pstrHostIfRegisterFrame)
+static void handle_register_frame(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct reg_frame *hif_reg_frame = &msg->body.reg_frame;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
 
-	wid.id = (u16)WID_REGISTER_FRAME;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Handling frame register Flag : %d FrameType: %d\n",
+		   hif_reg_frame->reg, hif_reg_frame->frame_type);
+	wid.id = WID_REGISTER_FRAME;
 	wid.type = WID_STR;
 	wid.val = kmalloc(sizeof(u16) + 2, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto out;
 
-	pu8CurrByte = wid.val;
+	cur_byte = wid.val;
 
-	*pu8CurrByte++ = pstrHostIfRegisterFrame->reg;
-	*pu8CurrByte++ = pstrHostIfRegisterFrame->reg_id;
-	memcpy(pu8CurrByte, &pstrHostIfRegisterFrame->frame_type, sizeof(u16));
+	*cur_byte++ = hif_reg_frame->reg;
+	*cur_byte++ = hif_reg_frame->reg_id;
+	memcpy(cur_byte, &hif_reg_frame->frame_type, sizeof(u16));
 
 	wid.size = sizeof(u16) + 2;
 
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
-	if (result) {
-		netdev_err(vif->ndev, "Failed to frame register\n");
-		result = -EINVAL;
-	}
+	kfree(wid.val);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to frame register\n");
 
-	return result;
+out:
+	kfree(msg);
 }
 
-static u32 Handle_ListenStateExpired(struct wilc_vif *vif,
-				     struct remain_ch *pstrHostIfRemainOnChan)
+static void handle_listen_state_expired(struct work_struct *work)
 {
-	u8 u8remain_on_chan_flag;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct remain_ch *hif_remain_ch = &msg->body.remain_on_ch;
+	u8 remain_on_chan_flag;
 	struct wid wid;
-	s32 result = 0;
+	int result;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 null_bssid[6] = {0};
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "CANCEL REMAIN ON CHAN\n");
 
-	if (P2P_LISTEN_STATE) {
-		u8remain_on_chan_flag = false;
-		wid.id = (u16)WID_REMAIN_ON_CHAN;
+	if (hif_drv->hif_state == HOST_IF_P2P_LISTEN) {
+		remain_on_chan_flag = false;
+		wid.id = WID_REMAIN_ON_CHAN;
 		wid.type = WID_STR;
 		wid.size = 2;
 		wid.val = kmalloc(wid.size, GFP_KERNEL);
 
-		if (!wid.val)
-			return -ENOMEM;
+		if (!wid.val) {
+			PRINT_ER(vif->ndev, "Failed to allocate memory\n");
+			goto free_msg;
+		}
 
-		wid.val[0] = u8remain_on_chan_flag;
+		wid.val[0] = remain_on_chan_flag;
 		wid.val[1] = FALSE_FRMWR_CHANNEL;
 
 		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 					      wilc_get_vif_idx(vif));
+		kfree(wid.val);
 		if (result != 0) {
-			netdev_err(vif->ndev, "Failed to set remain channel\n");
-			goto _done_;
+			PRINT_ER(vif->ndev, "Failed to set remain channel\n");
+			goto free_msg;
 		}
 
-		if (hif_drv->remain_on_ch.expired) {
+		if (hif_drv->remain_on_ch.expired)
 			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
-						      pstrHostIfRemainOnChan->id);
-		}
-		P2P_LISTEN_STATE = 0;
+						      hif_remain_ch->id);
+
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
-		netdev_dbg(vif->ndev, "Not in listen state\n");
-		result = -EFAULT;
+		PRINT_D(vif->ndev, GENERIC_DBG,  "Not in listen state\n");
 	}
 
-_done_:
-	return result;
+free_msg:
+	kfree(msg);
 }
 
-static void ListenTimerCB(unsigned long arg)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+static void listen_timer_cb(struct timer_list *t)
+#else
+static void listen_timer_cb(unsigned long arg)
+#endif
 {
-	s32 result = 0;
-	struct host_if_msg msg;
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
+						      remain_on_ch_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;
+	int result;
+	struct host_if_msg *msg;
 
 	del_timer(&vif->hif_drv->remain_on_ch_timer);
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
-	msg.vif = vif;
-	msg.body.remain_on_ch.id = vif->hif_drv->remain_on_ch.id;
+	msg = wilc_alloc_work(vif, handle_listen_state_expired, false);
+	if (IS_ERR(msg))
+		return;
+
+	msg->body.remain_on_ch.id = vif->hif_drv->remain_on_ch.id;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+		kfree(msg);
+	}
 }
 
-static void Handle_PowerManagement(struct wilc_vif *vif,
-				   struct power_mgmt_param *strPowerMgmtParam)
+static void handle_power_management(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct power_mgmt_param *pm_param = &msg->body.pwr_mgmt_info;
+	int result;
 	struct wid wid;
-	s8 s8PowerMode;
+	s8 power_mode;
 
-	wid.id = (u16)WID_POWER_MANAGEMENT;
+	wid.id = WID_POWER_MANAGEMENT;
 
-	if (strPowerMgmtParam->enabled)
-		s8PowerMode = MIN_FAST_PS;
+	if (pm_param->enabled)
+		power_mode = MIN_FAST_PS;
 	else
-		s8PowerMode = NO_POWERSAVE;
-
-	wid.val = &s8PowerMode;
+		power_mode = NO_POWERSAVE;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling power mgmt to %d\n",
+		   power_mode);
+	wid.val = &power_mode;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling Power Management\n");
 	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
 				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send power management\n");
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send power management\n");
+		goto out;
+	}
+	store_power_save_current_state(vif, power_mode);
+out:
+	kfree(msg);
 }
 
-static void Handle_SetMulticastFilter(struct wilc_vif *vif,
-				      struct set_multicast *strHostIfSetMulti)
+static void handle_set_mcast_filter(struct work_struct *work)
 {
-	s32 result = 0;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct set_multicast *hif_set_mc = &msg->body.multicast_info;
+	int result;
 	struct wid wid;
-	u8 *pu8CurrByte;
+	u8 *cur_byte;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setup Multicast Filter\n");
 
-	wid.id = (u16)WID_SETUP_MULTICAST_FILTER;
+	wid.id = WID_SETUP_MULTICAST_FILTER;
 	wid.type = WID_BIN;
-	wid.size = sizeof(struct set_multicast) + ((strHostIfSetMulti->cnt) * ETH_ALEN);
+	wid.size = sizeof(struct set_multicast) + (hif_set_mc->cnt * ETH_ALEN);
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-	*pu8CurrByte++ = (strHostIfSetMulti->enabled & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 8) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 16) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 24) & 0xFF);
-
-	*pu8CurrByte++ = (strHostIfSetMulti->cnt & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 8) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 16) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 24) & 0xFF);
-
-	if ((strHostIfSetMulti->cnt) > 0)
-		memcpy(pu8CurrByte, wilc_multicast_mac_addr_list,
-		       ((strHostIfSetMulti->cnt) * ETH_ALEN));
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send setup multicast\n");
-
-ERRORHANDLER:
-	kfree(wid.val);
-}
-
-static void handle_set_tx_pwr(struct wilc_vif *vif, u8 tx_pwr)
-{
-	int ret;
-	struct wid wid;
-
-	wid.id = (u16)WID_TX_POWER;
-	wid.type = WID_CHAR;
-	wid.val = &tx_pwr;
-	wid.size = sizeof(char);
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set TX PWR\n");
-}
-
-static void handle_get_tx_pwr(struct wilc_vif *vif, u8 *tx_pwr)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_TX_POWER;
-	wid.type = WID_CHAR;
-	wid.val = (s8 *)tx_pwr;
-	wid.size = sizeof(char);
-
-	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get TX PWR\n");
-
-	complete(&hif_wait_response);
-}
-
-static void host_if_work(struct work_struct *work)
-{
-	struct host_if_msg *msg;
-	struct wilc *wilc;
-	int ret = 0;
-
-	msg = container_of(work, struct host_if_msg, work);
-	wilc = msg->vif->wilc;
-
-	if (msg->id == HOST_IF_MSG_CONNECT &&
-	    msg->vif->hif_drv->usr_scan_req.scan_result) {
-		wilc_enqueue_cmd(msg);
-		usleep_range(2 * 1000, 2 * 1000);
-		goto free_msg;
-	}
-	switch (msg->id) {
-	case HOST_IF_MSG_SCAN:
-		handle_scan(msg->vif, &msg->body.scan_info);
-		break;
-
-	case HOST_IF_MSG_CONNECT:
-		Handle_Connect(msg->vif, &msg->body.con_info);
-		break;
-
-	case HOST_IF_MSG_RCVD_NTWRK_INFO:
-		Handle_RcvdNtwrkInfo(msg->vif, &msg->body.net_info);
-		break;
-
-	case HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO:
-		Handle_RcvdGnrlAsyncInfo(msg->vif,
-					 &msg->body.async_info);
-		break;
-
-	case HOST_IF_MSG_KEY:
-		Handle_Key(msg->vif, &msg->body.key_info);
-		break;
-
-	case HOST_IF_MSG_CFG_PARAMS:
-		handle_cfg_param(msg->vif, &msg->body.cfg_info);
-		break;
-
-	case HOST_IF_MSG_SET_CHANNEL:
-		handle_set_channel(msg->vif, &msg->body.channel_info);
-		break;
-
-	case HOST_IF_MSG_DISCONNECT:
-		Handle_Disconnect(msg->vif);
-		break;
-
-	case HOST_IF_MSG_RCVD_SCAN_COMPLETE:
-		del_timer(&msg->vif->hif_drv->scan_timer);
+		goto error;
 
-		if (!wilc_wlan_get_num_conn_ifcs(wilc))
-			wilc_chip_sleep_manually(wilc);
+	cur_byte = wid.val;
+	*cur_byte++ = (hif_set_mc->enabled & 0xFF);
+	*cur_byte++ = 0;
+	*cur_byte++ = 0;
+	*cur_byte++ = 0;
 
-		Handle_ScanDone(msg->vif, SCAN_EVENT_DONE);
+	*cur_byte++ = (hif_set_mc->cnt & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 8) & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 16) & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 24) & 0xFF);
 
-		if (msg->vif->hif_drv->remain_on_ch_pending)
-			Handle_RemainOnChan(msg->vif,
-					    &msg->body.remain_on_ch);
+	if (hif_set_mc->cnt > 0 && hif_set_mc->mc_list)
+		memcpy(cur_byte, hif_set_mc->mc_list,
+		       ((hif_set_mc->cnt) * ETH_ALEN));
 
-		break;
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send setup multicast\n");
 
-	case HOST_IF_MSG_GET_RSSI:
-		Handle_GetRssi(msg->vif);
-		break;
+error:
+	kfree(hif_set_mc->mc_list);
+	kfree(wid.val);
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_GET_STATISTICS:
-		Handle_GetStatistics(msg->vif,
-				     (struct rf_info *)msg->body.data);
-		break;
+static void handle_set_wowlan_trigger(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	int ret;
+	struct wid wid;
 
-	case HOST_IF_MSG_ADD_BEACON:
-		Handle_AddBeacon(msg->vif, &msg->body.beacon_info);
-		break;
+	wid.id = WID_WOWLAN_TRIGGER;
+	wid.type = WID_CHAR;
+	wid.val = &msg->body.wow_trigger.wowlan_trigger;
+	wid.size = sizeof(s8);
 
-	case HOST_IF_MSG_DEL_BEACON:
-		Handle_DelBeacon(msg->vif);
-		break;
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
 
-	case HOST_IF_MSG_ADD_STATION:
-		Handle_AddStation(msg->vif, &msg->body.add_sta_info);
-		break;
+	if (ret)
+		PRINT_ER(vif->ndev,
+			 "Failed to send wowlan trigger config packet\n");
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_DEL_STATION:
-		Handle_DelStation(msg->vif, &msg->body.del_sta_info);
-		break;
+static void handle_set_tx_pwr(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	u8 tx_pwr = msg->body.tx_power.tx_pwr;
+	int ret;
+	struct wid wid;
 
-	case HOST_IF_MSG_EDIT_STATION:
-		Handle_EditStation(msg->vif, &msg->body.edit_sta_info);
-		break;
+	wid.id = WID_TX_POWER;
+	wid.type = WID_CHAR;
+	wid.val = &tx_pwr;
+	wid.size = sizeof(char);
 
-	case HOST_IF_MSG_GET_INACTIVETIME:
-		Handle_Get_InActiveTime(msg->vif, &msg->body.mac_info);
-		break;
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set TX PWR\n");
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_SCAN_TIMER_FIRED:
-		Handle_ScanDone(msg->vif, SCAN_EVENT_ABORTED);
-		break;
+/* Note: 'msg' will be free after using data */
+static void handle_get_tx_pwr(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	u8 *tx_pwr = &msg->body.tx_power.tx_pwr;
+	int ret;
+	struct wid wid;
 
-	case HOST_IF_MSG_CONNECT_TIMER_FIRED:
-		Handle_ConnectTimeout(msg->vif);
-		break;
+	wid.id = WID_TX_POWER;
+	wid.type = WID_CHAR;
+	wid.val = (s8 *)tx_pwr;
+	wid.size = sizeof(char);
 
-	case HOST_IF_MSG_POWER_MGMT:
-		Handle_PowerManagement(msg->vif,
-				       &msg->body.pwr_mgmt_info);
-		break;
+	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get TX PWR\n");
 
-	case HOST_IF_MSG_SET_WFIDRV_HANDLER:
-		ret = handle_set_wfi_drv_handler(msg->vif, &msg->body.drv);
-		break;
+	complete(&msg->work_comp);
+}
 
-	case HOST_IF_MSG_SET_OPERATION_MODE:
-		handle_set_operation_mode(msg->vif, &msg->body.mode);
-		break;
+static void handle_scan_timer(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	int ret;
 
-	case HOST_IF_MSG_SET_IPADDRESS:
-		handle_set_ip_address(msg->vif,
-				      msg->body.ip_info.ip_addr,
-				      msg->body.ip_info.idx);
-		break;
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "handling scan timer\n");
+	ret = handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+	if (ret)
+		PRINT_ER(msg->vif->ndev, "Failed to handle scan done\n");
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_GET_IPADDRESS:
-		handle_get_ip_address(msg->vif, msg->body.ip_info.idx);
-		break;
+static void handle_remain_on_chan_work(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	int ret;
 
-	case HOST_IF_MSG_GET_MAC_ADDRESS:
-		handle_get_mac_address(msg->vif,
-				       &msg->body.get_mac_info);
-		break;
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "handling remain on channel\n");
+	ret = handle_remain_on_chan(msg->vif, &msg->body.remain_on_ch);
+	if (ret)
+		PRINT_ER(msg->vif->ndev,
+			 "Failed to handle remain on channel\n");
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_REMAIN_ON_CHAN:
-		Handle_RemainOnChan(msg->vif, &msg->body.remain_on_ch);
-		break;
+static void handle_scan_complete(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 
-	case HOST_IF_MSG_REGISTER_FRAME:
-		Handle_RegisterFrame(msg->vif, &msg->body.reg_frame);
-		break;
+	del_timer(&msg->vif->hif_drv->scan_timer);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "scan completed\n");
 
-	case HOST_IF_MSG_LISTEN_TIMER_FIRED:
-		Handle_ListenStateExpired(msg->vif, &msg->body.remain_on_ch);
-		break;
+	handle_scan_done(msg->vif, SCAN_EVENT_DONE);
 
-	case HOST_IF_MSG_SET_MULTICAST_FILTER:
-		Handle_SetMulticastFilter(msg->vif, &msg->body.multicast_info);
-		break;
+	if (msg->vif->hif_drv->remain_on_ch_pending)
+		handle_remain_on_chan(msg->vif, &msg->body.remain_on_ch);
+	kfree(msg);
+}
 
-	case HOST_IF_MSG_DEL_ALL_STA:
-		Handle_DelAllSta(msg->vif, &msg->body.del_all_sta_info);
-		break;
+static void handle_set_antenna_mode(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	int ret;
+	struct wid wid;
+	struct sysfs_attr_group *attr_syfs_p = &vif->attr_sysfs;
+	struct host_if_set_ant *set_ant = &msg->body.set_ant;
 
-	case HOST_IF_MSG_SET_TX_POWER:
-		handle_set_tx_pwr(msg->vif, msg->body.tx_power.tx_pwr);
-		break;
+	wid.id = WID_ANTENNA_SELECTION;
+	wid.type = WID_BIN;
+	wid.val = (u8 *)set_ant;
+	wid.size = sizeof(struct host_if_set_ant);
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_SNGL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIO %d\n", set_ant->mode,
+			   set_ant->antenna1);
+	else if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIOs %d and %d\n",
+			   set_ant->mode, set_ant->antenna1,
+			   set_ant->antenna2);
 
-	case HOST_IF_MSG_GET_TX_POWER:
-		handle_get_tx_pwr(msg->vif, &msg->body.tx_power.tx_pwr);
-		break;
-	default:
-		netdev_err(msg->vif->ndev, "[Host Interface] undefined\n");
-		break;
-	}
-free_msg:
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
 	if (ret)
-		netdev_err(msg->vif->ndev, "Host cmd %d failed\n", msg->id);
+		PRINT_ER(vif->ndev, "Failed to set antenna mode\n");
 	kfree(msg);
-	complete(&hif_thread_comp);
 }
 
-static void TimerCB_Scan(unsigned long arg)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+static void timer_scan_cb(struct timer_list *t)
+#else
+static void timer_scan_cb(unsigned long arg)
+#endif
 {
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-	struct host_if_msg msg;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->scan_timer_vif;
+	struct host_if_msg *msg;
+	int result;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.vif = vif;
-	msg.id = HOST_IF_MSG_SCAN_TIMER_FIRED;
+	msg = wilc_alloc_work(vif, handle_scan_timer, false);
+	if (IS_ERR(msg))
+		return;
 
-	wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
+	if (result)
+		kfree(msg);
 }
 
-static void TimerCB_Connect(unsigned long arg)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+static void timer_connect_cb(struct timer_list *t)
+#else
+static void timer_connect_cb(unsigned long arg)
+#endif
 {
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-	struct host_if_msg msg;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, connect_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->connect_timer_vif;
+	struct host_if_msg *msg;
+	int result;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.vif = vif;
-	msg.id = HOST_IF_MSG_CONNECT_TIMER_FIRED;
+	msg = wilc_alloc_work(vif, handle_connect_timeout, false);
+	if (IS_ERR(msg))
+		return;
 
-	wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
+	if (result)
+		kfree(msg);
 }
 
-s32 wilc_remove_key(struct host_if_drv *hif_drv, const u8 *pu8StaAddress)
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  wilc_frmw_to_linux_t frmw_to_linux,
+				  free_eap_buf_param eap_buf_param,
+				  u8 *buff, unsigned int size,
+				  unsigned int pkt_offset,
+				  void *user_arg)
 {
-	struct wid wid;
+	int result;
+	struct host_if_msg *msg;
 
-	wid.id = (u16)WID_REMOVE_KEY;
-	wid.type = WID_STR;
-	wid.val = (s8 *)pu8StaAddress;
-	wid.size = 6;
+	if (!vif || !frmw_to_linux || !eap_buf_param)
+		return -EFAULT;
 
-	return 0;
+	msg = wilc_alloc_work(vif, handle_send_buffered_eap, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+	msg->body.send_buff_eap.frmw_to_linux = frmw_to_linux;
+	msg->body.send_buff_eap.eap_buf_param = eap_buf_param;
+	msg->body.send_buff_eap.size = size;
+	msg->body.send_buff_eap.pkt_offset = pkt_offset;
+	msg->body.send_buff_eap.buff = kmalloc(size + pkt_offset,
+						  GFP_ATOMIC);
+	memcpy(msg->body.send_buff_eap.buff, buff, size + pkt_offset);
+	msg->body.send_buff_eap.user_arg = user_arg;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg->body.send_buff_eap.buff);
+		kfree(msg);
+	}
+	return result;
 }
 
 int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
 		result = -EFAULT;
-		netdev_err(vif->ndev, "Failed to send setup multicast\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return result;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = REMOVEKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.index = index;
+	msg->body.key_info.type = WEP;
+	msg->body.key_info.action = REMOVEKEY;
+	msg->body.key_info.attr.wep.index = index;
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result)
-		netdev_err(vif->ndev, "Request to remove WEP key\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
+		wait_for_completion(&msg->work_comp);
 
+	kfree(msg);
 	return result;
 }
 
 int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
 		result = -EFAULT;
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return result;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = DEFAULTKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.index = index;
+	msg->body.key_info.type = WEP;
+	msg->body.key_info.action = DEFAULTKEY;
+	msg->body.key_info.attr.wep.index = index;
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result)
-		netdev_err(vif->ndev, "Default key index\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
+		wait_for_completion(&msg->work_comp);
 
+	kfree(msg);
 	return result;
 }
 
 int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
 			     u8 index)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = ADDKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wep.key)
-		return -ENOMEM;
+	msg->body.key_info.type = WEP;
+	msg->body.key_info.action = ADDKEY;
+	msg->body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
+	if (!msg->body.key_info.attr.wep.key) {
+		result = -ENOMEM;
+		goto free_msg;
+	}
 
-	msg.body.key_info.attr.wep.key_len = len;
-	msg.body.key_info.attr.wep.index = index;
+	msg->body.key_info.attr.wep.key_len = len;
+	msg->body.key_info.attr.wep.index = index;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "STA - WEP Key\n");
-	wait_for_completion(&hif_drv->comp_test_key_block);
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_key;
+	}
 
+	wait_for_completion(&msg->work_comp);
+
+free_key:
+	/*free key only here when work is completed or error in posting work*/
+	kfree(msg->body.key_info.attr.wep.key);
+
+free_msg:
+	kfree(msg);
 	return result;
 }
 
 int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
-			    u8 index, u8 mode, enum AUTHTYPE auth_type)
+			    u8 index, u8 mode, enum authtype auth_type)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = ADDKEY_AP;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wep.key)
-		return -ENOMEM;
+	msg->body.key_info.type = WEP;
+	msg->body.key_info.action = ADDKEY_AP;
+	msg->body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
+	if (!msg->body.key_info.attr.wep.key) {
+		result = -ENOMEM;
+		goto free_msg;
+	}
+
+	msg->body.key_info.attr.wep.key_len = len;
+	msg->body.key_info.attr.wep.index = index;
+	msg->body.key_info.attr.wep.mode = mode;
+	msg->body.key_info.attr.wep.auth_type = auth_type;
 
-	msg.body.key_info.attr.wep.key_len = len;
-	msg.body.key_info.attr.wep.index = index;
-	msg.body.key_info.attr.wep.mode = mode;
-	msg.body.key_info.attr.wep.auth_type = auth_type;
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_key;
+	}
 
-	result = wilc_enqueue_cmd(&msg);
+	wait_for_completion(&msg->work_comp);
 
-	if (result)
-		netdev_err(vif->ndev, "AP - WEP Key\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
+free_key:
+	kfree(msg->body.key_info.attr.wep.key);
 
+free_msg:
+	kfree(msg);
 	return result;
 }
 
@@ -2812,13 +3219,13 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	u8 key_len = ptk_key_len;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
@@ -2828,39 +3235,49 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 	if (tx_mic)
 		key_len += TX_MIC_KEY_LEN;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WPA_PTK;
+	msg->body.key_info.type = WPA_PTK;
 	if (mode == AP_MODE) {
-		msg.body.key_info.action = ADDKEY_AP;
-		msg.body.key_info.attr.wpa.index = index;
+		msg->body.key_info.action = ADDKEY_AP;
+		msg->body.key_info.attr.wpa.index = index;
 	}
 	if (mode == STATION_MODE)
-		msg.body.key_info.action = ADDKEY;
+		msg->body.key_info.action = ADDKEY;
 
-	msg.body.key_info.attr.wpa.key = kmemdup(ptk, ptk_key_len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wpa.key)
-		return -ENOMEM;
+	msg->body.key_info.attr.wpa.key = kmemdup(ptk, ptk_key_len, GFP_KERNEL);
+	if (!msg->body.key_info.attr.wpa.key) {
+		result = -ENOMEM;
+		goto free_msg;
+	}
 
 	if (rx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic, RX_MIC_KEY_LEN);
+		memcpy(msg->body.key_info.attr.wpa.key + 16, rx_mic,
+		       RX_MIC_KEY_LEN);
 
 	if (tx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic, TX_MIC_KEY_LEN);
+		memcpy(msg->body.key_info.attr.wpa.key + 24, tx_mic,
+		       TX_MIC_KEY_LEN);
+
+	msg->body.key_info.attr.wpa.key_len = key_len;
+	msg->body.key_info.attr.wpa.mac_addr = mac_addr;
+	msg->body.key_info.attr.wpa.mode = cipher_mode;
 
-	msg.body.key_info.attr.wpa.key_len = key_len;
-	msg.body.key_info.attr.wpa.mac_addr = mac_addr;
-	msg.body.key_info.attr.wpa.mode = cipher_mode;
-	msg.vif = vif;
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_key;
+	}
 
-	result = wilc_enqueue_cmd(&msg);
+	wait_for_completion(&msg->work_comp);
 
-	if (result)
-		netdev_err(vif->ndev, "PTK Key\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
+free_key:
+	kfree(msg->body.key_info.attr.wpa.key);
 
+free_msg:
+	kfree(msg);
 	return result;
 }
 
@@ -2869,16 +3286,19 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
 		    u8 cipher_mode)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	u8 key_len = gtk_key_len;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
-	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg = wilc_alloc_work(vif, handle_key, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
 	if (rx_mic)
 		key_len += RX_MIC_KEY_LEN;
@@ -2887,352 +3307,410 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		key_len += TX_MIC_KEY_LEN;
 
 	if (key_rsc) {
-		msg.body.key_info.attr.wpa.seq = kmemdup(key_rsc,
-							 key_rsc_len,
-							 GFP_KERNEL);
-		if (!msg.body.key_info.attr.wpa.seq)
-			return -ENOMEM;
+		msg->body.key_info.attr.wpa.seq = kmemdup(key_rsc,
+							  key_rsc_len,
+							  GFP_KERNEL);
+		if (!msg->body.key_info.attr.wpa.seq) {
+			result = -ENOMEM;
+			goto free_msg;
+		}
 	}
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WPA_RX_GTK;
-	msg.vif = vif;
+	msg->body.key_info.type = WPA_RX_GTK;
 
 	if (mode == AP_MODE) {
-		msg.body.key_info.action = ADDKEY_AP;
-		msg.body.key_info.attr.wpa.mode = cipher_mode;
+		msg->body.key_info.action = ADDKEY_AP;
+		msg->body.key_info.attr.wpa.mode = cipher_mode;
 	}
 	if (mode == STATION_MODE)
-		msg.body.key_info.action = ADDKEY;
+		msg->body.key_info.action = ADDKEY;
 
-	msg.body.key_info.attr.wpa.key = kmemdup(rx_gtk,
-						 key_len,
-						 GFP_KERNEL);
-	if (!msg.body.key_info.attr.wpa.key)
-		return -ENOMEM;
+	msg->body.key_info.attr.wpa.key = kmemdup(rx_gtk, key_len, GFP_KERNEL);
+	if (!msg->body.key_info.attr.wpa.key) {
+		result = -ENOMEM;
+		goto free_seq;
+	}
 
 	if (rx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic,
+		memcpy(msg->body.key_info.attr.wpa.key + 16, rx_mic,
 		       RX_MIC_KEY_LEN);
 
 	if (tx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic,
+		memcpy(msg->body.key_info.attr.wpa.key + 24, tx_mic,
 		       TX_MIC_KEY_LEN);
 
-	msg.body.key_info.attr.wpa.index = index;
-	msg.body.key_info.attr.wpa.key_len = key_len;
-	msg.body.key_info.attr.wpa.seq_len = key_rsc_len;
+	msg->body.key_info.attr.wpa.index = index;
+	msg->body.key_info.attr.wpa.key_len = key_len;
+	msg->body.key_info.attr.wpa.seq_len = key_rsc_len;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "RX GTK\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_key;
+	}
 
+	wait_for_completion(&msg->work_comp);
+
+free_key:
+	kfree(msg->body.key_info.attr.wpa.key);
+
+free_seq:
+	kfree(msg->body.key_info.attr.wpa.seq);
+
+free_msg:
+	kfree(msg);
 	return result;
 }
 
 int wilc_set_pmkid_info(struct wilc_vif *vif,
 			struct host_if_pmkid_attr *pmkid)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	int i;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_key, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = PMKSA;
-	msg.body.key_info.action = ADDKEY;
-	msg.vif = vif;
+	msg->body.key_info.type = PMKSA;
+	msg->body.key_info.action = ADDKEY;
 
 	for (i = 0; i < pmkid->numpmkid; i++) {
-		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].bssid,
+		memcpy(msg->body.key_info.attr.pmkid.pmkidlist[i].bssid,
 		       &pmkid->pmkidlist[i].bssid, ETH_ALEN);
-		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].pmkid,
+		memcpy(msg->body.key_info.attr.pmkid.pmkidlist[i].pmkid,
 		       &pmkid->pmkidlist[i].pmkid, PMKID_LEN);
 	}
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "PMKID Info\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 
 	return result;
 }
 
 int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
+
+	msg = wilc_alloc_work(vif, handle_get_mac_address, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	msg->body.dev_mac_info.mac_addr = mac_addr;
+
+	result = wilc_enqueue_work(msg);
+	if (result)
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+	else
+		wait_for_completion(&msg->work_comp);
+
+	kfree(msg);
+
+	return result;
+}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)
+{
+	int result;
+	struct host_if_msg *msg;
+
+	msg = wilc_alloc_work(vif, handle_set_mac_address, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_GET_MAC_ADDRESS;
-	msg.body.get_mac_info.mac_addr = mac_addr;
-	msg.vif = vif;
+	msg->body.dev_mac_info.mac_addr = mac_addr;
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send get mac address\n");
-		return -EFAULT;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		result = -EFAULT;
+	} else {
+		wait_for_completion(&msg->work_comp);
 	}
-
-	wait_for_completion(&hif_wait_response);
+	kfree(msg);
 	return result;
 }
 
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ssid,
 		      size_t ssid_len, const u8 *ies, size_t ies_len,
 		      wilc_connect_result connect_result, void *user_arg,
-		      u8 security, enum AUTHTYPE auth_type,
+		      u8 security, enum authtype auth_type,
 		      u8 channel, void *join_params)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv || !connect_result) {
-		netdev_err(vif->ndev, "Driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver or connect result is NULL\n");
 		return -EFAULT;
 	}
 
 	if (!join_params) {
-		netdev_err(vif->ndev, "Unable to Join - JoinParams is NULL\n");
+		PRINT_ER(vif->ndev, "joinparams is NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_connect, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_CONNECT;
-
-	msg.body.con_info.security = security;
-	msg.body.con_info.auth_type = auth_type;
-	msg.body.con_info.ch = channel;
-	msg.body.con_info.result = connect_result;
-	msg.body.con_info.arg = user_arg;
-	msg.body.con_info.params = join_params;
-	msg.vif = vif;
+	msg->body.con_info.security = security;
+	msg->body.con_info.auth_type = auth_type;
+	msg->body.con_info.ch = channel;
+	msg->body.con_info.result = connect_result;
+	msg->body.con_info.arg = user_arg;
+	msg->body.con_info.params = join_params;
 
 	if (bssid) {
-		msg.body.con_info.bssid = kmemdup(bssid, 6, GFP_KERNEL);
-		if (!msg.body.con_info.bssid)
-			return -ENOMEM;
+		msg->body.con_info.bssid = kmemdup(bssid, 6, GFP_KERNEL);
+		if (!msg->body.con_info.bssid) {
+			result = -ENOMEM;
+			goto free_msg;
+		}
 	}
 
 	if (ssid) {
-		msg.body.con_info.ssid_len = ssid_len;
-		msg.body.con_info.ssid = kmemdup(ssid, ssid_len, GFP_KERNEL);
-		if (!msg.body.con_info.ssid)
-			return -ENOMEM;
+		msg->body.con_info.ssid_len = ssid_len;
+		msg->body.con_info.ssid = kmemdup(ssid, ssid_len, GFP_KERNEL);
+		if (!msg->body.con_info.ssid) {
+			result = -ENOMEM;
+			goto free_bssid;
+		}
 	}
 
 	if (ies) {
-		msg.body.con_info.ies_len = ies_len;
-		msg.body.con_info.ies = kmemdup(ies, ies_len, GFP_KERNEL);
-		if (!msg.body.con_info.ies)
-			return -ENOMEM;
+		msg->body.con_info.ies_len = ies_len;
+		msg->body.con_info.ies = kmemdup(ies, ies_len, GFP_KERNEL);
+		if (!msg->body.con_info.ies) {
+			result = -ENOMEM;
+			goto free_ssid;
+		}
 	}
 	if (hif_drv->hif_state < HOST_IF_CONNECTING)
 		hif_drv->hif_state = HOST_IF_CONNECTING;
+	else
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't set state to 'connecting' as state is %d\n",
+			   hif_drv->hif_state);
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "send message: Set join request\n");
-		return -EFAULT;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_ies;
 	}
-
-	hif_drv->connect_timer.data = (unsigned long)vif;
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	hif_drv->connect_timer.data = (unsigned long)hif_drv;
+#endif
+	hif_drv->connect_timer_vif = vif;
 	mod_timer(&hif_drv->connect_timer,
 		  jiffies + msecs_to_jiffies(HOST_IF_CONNECT_TIMEOUT));
 
+	return 0;
+
+free_ies:
+	kfree(msg->body.con_info.ies);
+
+free_ssid:
+	kfree(msg->body.con_info.ssid);
+
+free_bssid:
+	kfree(msg->body.con_info.bssid);
+
+free_msg:
+	kfree(msg);
 	return result;
 }
 
 int wilc_disconnect(struct wilc_vif *vif, u16 reason_code)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_DISCONNECT;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_disconnect, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send message: disconnect\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 	else
-		wait_for_completion(&hif_drv->comp_test_disconn_block);
-
-	return result;
-}
-
-static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
-				       u8 *pu8AssocRespInfo,
-				       u32 u32MaxAssocRespInfoLen,
-				       u32 *pu32RcvdAssocRespInfoLen)
-{
-	s32 result = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_ASSOC_RES_INFO;
-	wid.type = WID_STR;
-	wid.val = pu8AssocRespInfo;
-	wid.size = u32MaxAssocRespInfoLen;
-
-	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result) {
-		*pu32RcvdAssocRespInfoLen = 0;
-		netdev_err(vif->ndev, "Failed to send association response\n");
-		return -EINVAL;
-	}
+		wait_for_completion(&msg->work_comp);
 
-	*pu32RcvdAssocRespInfoLen = wid.size;
+	kfree(msg);
 	return result;
 }
 
 int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)
 {
 	int result;
-	struct host_if_msg msg;
+	struct host_if_msg *msg;
+
+	msg = wilc_alloc_work(vif, handle_set_channel, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_CHANNEL;
-	msg.body.channel_info.set_ch = channel;
-	msg.vif = vif;
+	msg->body.channel_info.set_ch = channel;
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		return -EINVAL;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
 	}
 
-	return 0;
+	return result;
 }
 
 int wilc_set_wfi_drv_handler(struct wilc_vif *vif, int index, u8 mode,
-			     u8 ifc_id)
+			     u8 ifc_id, bool is_sync)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_WFIDRV_HANDLER;
-	msg.body.drv.handler = index;
-	msg.body.drv.mode = mode;
-	msg.body.drv.name = ifc_id;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_set_wfi_drv_handler, is_sync);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
+	msg->body.drv.handler = index;
+	msg->body.drv.mode = mode;
+	msg->body.drv.ifc_id = ifc_id;
+
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		result = -EINVAL;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+		return result;
 	}
 
+	if (is_sync)
+		wait_for_completion(&msg->work_comp);
+
 	return result;
 }
 
 int wilc_set_operation_mode(struct wilc_vif *vif, u32 mode)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_OPERATION_MODE;
-	msg.body.mode.mode = mode;
-	msg.vif = vif;
+	msg  = wilc_alloc_work(vif, handle_set_operation_mode, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
+	msg->body.mode.mode = mode;
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		result = -EINVAL;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
 	}
 
 	return result;
 }
 
 s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
-			   u32 *pu32InactiveTime)
+			   u32 *out_val)
 {
-	s32 result = 0;
-	struct host_if_msg msg;
+	s32 result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	memcpy(msg.body.mac_info.mac, mac, ETH_ALEN);
+	msg = wilc_alloc_work(vif, handle_get_inactive_time, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_GET_INACTIVETIME;
-	msg.vif = vif;
+	memcpy(msg->body.mac_info.mac, mac, ETH_ALEN);
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send get host ch param\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 	else
-		wait_for_completion(&hif_drv->comp_inactive_time);
+		wait_for_completion(&msg->work_comp);
 
-	*pu32InactiveTime = inactive_time;
+	*out_val = msg->body.mac_info.inactive_time;
+	kfree(msg);
 
 	return result;
 }
 
 int wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_GET_RSSI;
-	msg.vif = vif;
+	int result;
+	struct host_if_msg *msg;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "Failed to send get host ch param\n");
+	if (!rssi_level) {
+		PRINT_ER(vif->ndev, "RSS pointer value is null\n");
 		return -EFAULT;
 	}
 
-	wait_for_completion(&hif_drv->comp_get_rssi);
+	msg = wilc_alloc_work(vif, handle_get_rssi, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	if (!rssi_level) {
-		netdev_err(vif->ndev, "RSS pointer value is null\n");
-		return -EFAULT;
+	msg->body.data = kzalloc(sizeof(s8), GFP_KERNEL);
+	if (!msg->body.data) {
+		kfree(msg);
+		return -ENOMEM;
+	}
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+	} else {
+		wait_for_completion(&msg->work_comp);
+
+		if (*msg->body.data == INVALID_RSSI)
+			result = -EFAULT;
+		else
+			*rssi_level = *msg->body.data;
 	}
 
-	*rssi_level = rssi;
+	kfree(msg->body.data);
+	kfree(msg);
 
 	return result;
 }
 
-int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)
+int
+wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats, bool is_sync)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_GET_STATISTICS;
-	msg.body.data = (char *)stats;
-	msg.vif = vif;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, " getting statistics\n");
+	msg = wilc_alloc_work(vif, handle_get_statistics, is_sync);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
+	msg->body.data = (char *)stats;
+
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send get host channel\n");
-		return -EFAULT;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+		return result;
+	}
+
+	if (is_sync) {
+		wait_for_completion(&msg->work_comp);
+		kfree(msg);
 	}
 
-	if (stats != &vif->wilc->dummy_statistics)
-		wait_for_completion(&hif_wait_response);
 	return result;
 }
 
@@ -3241,26 +3719,30 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	      size_t ies_len, wilc_scan_result scan_result, void *user_arg,
 	      struct hidden_network *hidden_network)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct scan_attr *scan_info = &msg.body.scan_info;
+	int result;
+	struct host_if_msg *msg;
+	struct scan_attr *scan_info;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv || !scan_result) {
-		netdev_err(vif->ndev, "hif_drv or scan_result = NULL\n");
+		PRINT_ER(vif->ndev, "hif_drv or scan_result = NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_scan, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_SCAN;
+	scan_info = &msg->body.scan_info;
 
 	if (hidden_network) {
 		scan_info->hidden_network.net_info = hidden_network->net_info;
 		scan_info->hidden_network.n_ssids = hidden_network->n_ssids;
+	} else {
+		PRINT_WRN(vif->ndev, HOSTINF_DBG,
+			  "hidden_network IS EQUAL TO NULL\n");
 	}
 
-	msg.vif = vif;
 	scan_info->src = scan_source;
 	scan_info->type = scan_type;
 	scan_info->result = scan_result;
@@ -3270,191 +3752,187 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	scan_info->ch_freq_list = kmemdup(ch_freq_list,
 					  ch_list_len,
 					  GFP_KERNEL);
-	if (!scan_info->ch_freq_list)
-		return -ENOMEM;
+	if (!scan_info->ch_freq_list) {
+		result = -ENOMEM;
+		goto free_msg;
+	}
 
 	scan_info->ies_len = ies_len;
 	scan_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-	if (!scan_info->ies)
-		return -ENOMEM;
+	if (!scan_info->ies) {
+		result = -ENOMEM;
+		goto free_freq_list;
+	}
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "Error in sending message queue\n");
-		return -EINVAL;
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		goto free_ies;
 	}
 
-	hif_drv->scan_timer.data = (unsigned long)vif;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, ">> Starting the SCAN timer\n");
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	hif_drv->scan_timer.data = (unsigned long)hif_drv;
+#endif
+	hif_drv->scan_timer_vif = vif;
 	mod_timer(&hif_drv->scan_timer,
 		  jiffies + msecs_to_jiffies(HOST_IF_SCAN_TIMEOUT));
 
+	return 0;
+
+free_ies:
+	kfree(scan_info->ies);
+
+free_freq_list:
+	kfree(scan_info->ch_freq_list);
+
+free_msg:
+	kfree(msg);
 	return result;
 }
 
 int wilc_hif_set_cfg(struct wilc_vif *vif,
 		     struct cfg_param_attr *cfg_param)
 {
-	struct host_if_msg msg;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	int result;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "hif_drv NULL\n");
+		PRINT_ER(vif->ndev, "hif_drv NULL\n");
 		return -EFAULT;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_CFG_PARAMS;
-	msg.body.cfg_info = *cfg_param;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_cfg_param, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	msg->body.cfg_info = *cfg_param;
+	result = wilc_enqueue_work(msg);
+	if (result)
+		kfree(msg);
 
-	return wilc_enqueue_cmd(&msg);
+	return result;
 }
 
-static void GetPeriodicRSSI(unsigned long arg)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+static void get_periodic_rssi(struct timer_list *t)
+#else
+static void get_periodic_rssi(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_vif *vif = from_timer(vif, t, periodic_rssi);
+#else
 	struct wilc_vif *vif = (struct wilc_vif *)arg;
+#endif
 
 	if (!vif->hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return;
 	}
 
 	if (vif->hif_drv->hif_state == HOST_IF_CONNECTED)
-		wilc_get_statistics(vif, &vif->wilc->dummy_statistics);
+		wilc_get_statistics(vif, &vif->periodic_stats, false);
 
-	periodic_rssi.data = (unsigned long)vif;
-	mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
+	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
 }
 
 int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)
 {
-	int result = 0;
 	struct host_if_drv *hif_drv;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 	int i;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	scan_while_connected = false;
-
-	init_completion(&hif_wait_response);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Initializing host interface for client %d\n",
+		   wilc->clients_count + 1);
 
 	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
 	if (!hif_drv) {
-		result = -ENOMEM;
-		goto _fail_;
+		PRINT_ER(dev, "hif driver is NULL\n");
+		return -ENOMEM;
 	}
 	*hif_drv_handler = hif_drv;
-	for (i = 0; i < wilc->vif_num; i++)
+	for (i = 0; i <= wilc->vif_num; i++)
 		if (dev == wilc->vif[i]->ndev) {
 			wilc->vif[i]->hif_drv = hif_drv;
 			hif_drv->driver_handler_id = i + 1;
 			break;
 		}
 
-	wilc_optaining_ip = false;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	vif->obtaining_ip = false;
+#endif
 
-	if (clients_count == 0)	{
-		init_completion(&hif_thread_comp);
-		init_completion(&hif_driver_comp);
+	if (wilc->clients_count == 0)
 		mutex_init(&hif_deinit_lock);
-	}
-
-	init_completion(&hif_drv->comp_test_key_block);
-	init_completion(&hif_drv->comp_test_disconn_block);
-	init_completion(&hif_drv->comp_get_rssi);
-	init_completion(&hif_drv->comp_inactive_time);
 
-	if (clients_count == 0)	{
-		hif_workqueue = create_singlethread_workqueue("WILC_wq");
-		if (!hif_workqueue) {
-			netdev_err(vif->ndev, "Failed to create workqueue\n");
-			result = -ENOMEM;
-			goto _fail_;
-		}
-
-		setup_timer(&periodic_rssi, GetPeriodicRSSI,
+	#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+		timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
+	#else
+		setup_timer(&vif->periodic_rssi, get_periodic_rssi,
 			    (unsigned long)vif);
-		mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
-	}
-
-	setup_timer(&hif_drv->scan_timer, TimerCB_Scan, 0);
-	setup_timer(&hif_drv->connect_timer, TimerCB_Connect, 0);
-	setup_timer(&hif_drv->remain_on_ch_timer, ListenTimerCB, 0);
-
-	mutex_init(&hif_drv->cfg_values_lock);
-	mutex_lock(&hif_drv->cfg_values_lock);
+	#endif
+		mod_timer(&vif->periodic_rssi,
+			  jiffies + msecs_to_jiffies(5000));
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	timer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);
+	timer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);
+	timer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+#else
+	setup_timer(&hif_drv->scan_timer, timer_scan_cb, 0);
+	setup_timer(&hif_drv->connect_timer, timer_connect_cb, 0);
+	setup_timer(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+#endif
 
 	hif_drv->hif_state = HOST_IF_IDLE;
-	hif_drv->cfg_values.site_survey_enabled = SITE_SURVEY_OFF;
-	hif_drv->cfg_values.scan_source = DEFAULT_SCAN;
-	hif_drv->cfg_values.active_scan_time = ACTIVE_SCAN_TIME;
-	hif_drv->cfg_values.passive_scan_time = PASSIVE_SCAN_TIME;
-	hif_drv->cfg_values.curr_tx_rate = AUTORATE;
 
 	hif_drv->p2p_timeout = 0;
 
-	mutex_unlock(&hif_drv->cfg_values_lock);
+	wilc->clients_count++;
 
-	clients_count++;
-
-_fail_:
-	return result;
+	return 0;
 }
 
 int wilc_deinit(struct wilc_vif *vif)
 {
 	int result = 0;
-	struct host_if_msg msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
-	if (!hif_drv)	{
-		netdev_err(vif->ndev, "hif_drv = NULL\n");
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
 	mutex_lock(&hif_deinit_lock);
 
 	terminated_handle = hif_drv;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "De-initializing host interface for client %d\n",
+		   vif->wilc->clients_count);
 
 	del_timer_sync(&hif_drv->scan_timer);
 	del_timer_sync(&hif_drv->connect_timer);
-	del_timer_sync(&periodic_rssi);
+	del_timer_sync(&vif->periodic_rssi);
 	del_timer_sync(&hif_drv->remain_on_ch_timer);
 
-	wilc_set_wfi_drv_handler(vif, 0, 0, 0);
-	wait_for_completion(&hif_driver_comp);
+	wilc_set_wfi_drv_handler(vif, 0, 0, 0, true);
 
 	if (hif_drv->usr_scan_req.scan_result) {
 		hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,
-						  hif_drv->usr_scan_req.arg, NULL);
+						  hif_drv->usr_scan_req.arg,
+						  NULL);
 		hif_drv->usr_scan_req.scan_result = NULL;
 	}
 
 	hif_drv->hif_state = HOST_IF_IDLE;
 
-	scan_while_connected = false;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	if (clients_count == 1)	{
-		msg.id = HOST_IF_MSG_EXIT;
-		msg.vif = vif;
-
-		result = wilc_enqueue_cmd(&msg);
-		if (result != 0)
-			netdev_err(vif->ndev, "deinit : Error(%d)\n", result);
-		else
-			wait_for_completion(&hif_thread_comp);
-
-		destroy_workqueue(hif_workqueue);
-	}
-
 	kfree(hif_drv);
 
-	clients_count--;
+	vif->wilc->clients_count--;
 	terminated_handle = NULL;
 	mutex_unlock(&hif_deinit_lock);
 	return result;
@@ -3462,109 +3940,139 @@ int wilc_deinit(struct wilc_vif *vif)
 
 void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 {
-	s32 result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	int id;
-	struct host_if_drv *hif_drv = NULL;
+	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
 
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
+	id = buffer[length - 4];
+	id |= (buffer[length - 3] << 8);
+	id |= (buffer[length - 2] << 16);
+	id |= (buffer[length - 1] << 24);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
 		return;
 	hif_drv = vif->hif_drv;
 
-	if (!hif_drv || hif_drv == terminated_handle)	{
-		netdev_err(vif->ndev, "driver not init[%p]\n", hif_drv);
+	if (!hif_drv || hif_drv == terminated_handle) {
+		PRINT_ER(vif->ndev, "driver not init[%p]\n", hif_drv);
 		return;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_RCVD_NTWRK_INFO;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);
+	if (IS_ERR(msg))
+		return;
 
-	msg.body.net_info.len = length;
-	msg.body.net_info.buffer = kmalloc(length, GFP_KERNEL);
-	memcpy(msg.body.net_info.buffer, buffer, length);
+	msg->body.net_info.len = length;
+	msg->body.net_info.buffer = kmemdup(buffer, length, GFP_KERNEL);
+	if (!msg->body.net_info.buffer) {
+		kfree(msg);
+		return;
+	}
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "message parameters (%d)\n", result);
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "message parameters (%d)\n", result);
+		kfree(msg->body.net_info.buffer);
+		kfree(msg);
+	}
 }
 
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 {
-	s32 result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	int id;
-	struct host_if_drv *hif_drv = NULL;
+	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
 
 	mutex_lock(&hif_deinit_lock);
 
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
+	id = buffer[length - 4];
+	id |= (buffer[length - 3] << 8);
+	id |= (buffer[length - 2] << 16);
+	id |= (buffer[length - 1] << 24);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif) {
 		mutex_unlock(&hif_deinit_lock);
 		return;
 	}
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "General asynchronous info packet received\n");
 
 	hif_drv = vif->hif_drv;
 
 	if (!hif_drv || hif_drv == terminated_handle) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		mutex_unlock(&hif_deinit_lock);
 		return;
 	}
 
 	if (!hif_drv->usr_conn_req.conn_result) {
-		netdev_err(vif->ndev, "there is no current Connect Request\n");
+		PRINT_ER(vif->ndev, "there is no current Connect Request\n");
 		mutex_unlock(&hif_deinit_lock);
 		return;
 	}
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);
+	if (IS_ERR(msg)) {
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
 
-	msg.body.async_info.len = length;
-	msg.body.async_info.buffer = kmalloc(length, GFP_KERNEL);
-	memcpy(msg.body.async_info.buffer, buffer, length);
+	msg->body.async_info.len = length;
+	msg->body.async_info.buffer = kmemdup(buffer, length, GFP_KERNEL);
+	if (!msg->body.async_info.buffer) {
+		kfree(msg);
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "synchronous info (%d)\n", result);
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg->body.async_info.buffer);
+		kfree(msg);
+	}
 
 	mutex_unlock(&hif_deinit_lock);
 }
 
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
 {
-	s32 result = 0;
-	struct host_if_msg msg;
+	int result;
 	int id;
-	struct host_if_drv *hif_drv = NULL;
+	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
 
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
+	id = buffer[length - 4];
+	id |= buffer[length - 3] << 8;
+	id |= buffer[length - 2] << 16;
+	id |= buffer[length - 1] << 24;
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
 		return;
 	hif_drv = vif->hif_drv;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Scan notification received\n");
 
-	if (!hif_drv || hif_drv == terminated_handle)
+	if (!hif_drv || hif_drv == terminated_handle) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return;
+	}
 
 	if (hif_drv->usr_scan_req.scan_result) {
-		memset(&msg, 0, sizeof(struct host_if_msg));
+		struct host_if_msg *msg;
 
-		msg.id = HOST_IF_MSG_RCVD_SCAN_COMPLETE;
-		msg.vif = vif;
+		msg = wilc_alloc_work(vif, handle_scan_complete, false);
+		if (IS_ERR(msg))
+			return;
 
-		result = wilc_enqueue_cmd(&msg);
-		if (result)
-			netdev_err(vif->ndev, "complete param (%d)\n", result);
+		result = wilc_enqueue_work(msg);
+		if (result) {
+			PRINT_ER(vif->ndev, "enqueue work failed\n");
+			kfree(msg);
+		}
 	}
 }
 
@@ -3574,101 +4082,112 @@ int wilc_remain_on_channel(struct wilc_vif *vif, u32 session_id,
 			   wilc_remain_on_chan_ready ready,
 			   void *user_arg)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_remain_on_chan_work, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_REMAIN_ON_CHAN;
-	msg.body.remain_on_ch.ch = chan;
-	msg.body.remain_on_ch.expired = expired;
-	msg.body.remain_on_ch.ready = ready;
-	msg.body.remain_on_ch.arg = user_arg;
-	msg.body.remain_on_ch.duration = duration;
-	msg.body.remain_on_ch.id = session_id;
-	msg.vif = vif;
+	msg->body.remain_on_ch.ch = chan;
+	msg->body.remain_on_ch.expired = expired;
+	msg->body.remain_on_ch.ready = ready;
+	msg->body.remain_on_ch.arg = user_arg;
+	msg->body.remain_on_ch.duration = duration;
+	msg->body.remain_on_ch.id = session_id;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 
 	return result;
 }
 
 int wilc_listen_state_expired(struct wilc_vif *vif, u32 session_id)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
 	del_timer(&hif_drv->remain_on_ch_timer);
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
-	msg.vif = vif;
-	msg.body.remain_on_ch.id = session_id;
+	msg = wilc_alloc_work(vif, handle_listen_state_expired, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
+	msg->body.remain_on_ch.id = session_id;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 
 	return result;
 }
 
-int wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
+void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_register_frame, false);
+	if (IS_ERR(msg))
+		return;
 
-	msg.id = HOST_IF_MSG_REGISTER_FRAME;
 	switch (frame_type) {
 	case ACTION:
-		msg.body.reg_frame.reg_id = ACTION_FRM_IDX;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "ACTION\n");
+		msg->body.reg_frame.reg_id = ACTION_FRM_IDX;
 		break;
 
 	case PROBE_REQ:
-		msg.body.reg_frame.reg_id = PROBE_REQ_IDX;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "PROBE REQ\n");
+		msg->body.reg_frame.reg_id = PROBE_REQ_IDX;
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Not valid frame type\n");
 		break;
 	}
-	msg.body.reg_frame.frame_type = frame_type;
-	msg.body.reg_frame.reg = reg;
-	msg.vif = vif;
+	msg->body.reg_frame.frame_type = frame_type;
+	msg->body.reg_frame.reg = reg;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-
-	return result;
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 }
 
 int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 		    u32 head_len, u8 *head, u32 tail_len, u8 *tail)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct beacon_attr *beacon_info = &msg.body.beacon_info;
+	int result;
+	struct host_if_msg *msg;
+	struct beacon_attr *beacon_info;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding beacon message queue params\n");
+	msg = wilc_alloc_work(vif, handle_add_beacon, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_ADD_BEACON;
-	msg.vif = vif;
+	beacon_info = &msg->body.beacon_info;
 	beacon_info->interval = interval;
 	beacon_info->dtim_period = dtim_period;
 	beacon_info->head_len = head_len;
 	beacon_info->head = kmemdup(head, head_len, GFP_KERNEL);
 	if (!beacon_info->head) {
 		result = -ENOMEM;
-		goto ERRORHANDLER;
+		goto error;
 	}
 	beacon_info->tail_len = tail_len;
 
@@ -3676,21 +4195,22 @@ int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 		beacon_info->tail = kmemdup(tail, tail_len, GFP_KERNEL);
 		if (!beacon_info->tail) {
 			result = -ENOMEM;
-			goto ERRORHANDLER;
+			goto error;
 		}
 	} else {
 		beacon_info->tail = NULL;
 	}
 
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 
-ERRORHANDLER:
+error:
 	if (result) {
 		kfree(beacon_info->head);
 
 		kfree(beacon_info->tail);
+		kfree(msg);
 	}
 
 	return result;
@@ -3698,97 +4218,133 @@ int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 
 int wilc_del_beacon(struct wilc_vif *vif)
 {
-	int result = 0;
-	struct host_if_msg msg;
+	int result;
+	struct host_if_msg *msg;
 
-	msg.id = HOST_IF_MSG_DEL_BEACON;
-	msg.vif = vif;
+	msg = wilc_alloc_work(vif, handle_del_beacon, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting beacon message queue params\n");
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 
 	return result;
 }
 
 int wilc_add_station(struct wilc_vif *vif, struct add_sta_param *sta_param)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *add_sta_info;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_add_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_ADD_STATION;
-	msg.vif = vif;
+	add_sta_info = &msg->body.add_sta_info;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding station message queue params\n");
 
 	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
 	if (add_sta_info->rates_len > 0) {
 		add_sta_info->rates = kmemdup(sta_param->rates,
-				      add_sta_info->rates_len,
-				      GFP_KERNEL);
-		if (!add_sta_info->rates)
+					      add_sta_info->rates_len,
+					      GFP_KERNEL);
+		if (!add_sta_info->rates) {
+			kfree(msg);
 			return -ENOMEM;
+		}
 	}
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(add_sta_info->rates);
+		kfree(msg);
+	}
 	return result;
 }
 
 int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct del_sta *del_sta_info = &msg.body.del_sta_info;
+	int result;
+	struct host_if_msg *msg;
+	struct del_sta *del_sta_info;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_del_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_DEL_STATION;
-	msg.vif = vif;
+	del_sta_info = &msg->body.del_sta_info;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting station message queue params\n");
 
 	if (!mac_addr)
 		eth_broadcast_addr(del_sta_info->mac_addr);
 	else
 		memcpy(del_sta_info->mac_addr, mac_addr, ETH_ALEN);
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 	return result;
 }
 
 int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct del_all_sta *del_all_sta_info = &msg.body.del_all_sta_info;
+	int result;
+	struct host_if_msg *msg;
+	struct del_all_sta *del_all_sta_info;
 	u8 zero_addr[ETH_ALEN] = {0};
 	int i;
 	u8 assoc_sta = 0;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deauthenticating station message queue params\n");
+	msg = wilc_alloc_work(vif, handle_del_all_sta, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_DEL_ALL_STA;
-	msg.vif = vif;
+	del_all_sta_info = &msg->body.del_all_sta_info;
 
 	for (i = 0; i < MAX_NUM_STA; i++) {
 		if (memcmp(mac_addr[i], zero_addr, ETH_ALEN)) {
-			memcpy(del_all_sta_info->del_all_sta[i], mac_addr[i], ETH_ALEN);
+			memcpy(del_all_sta_info->del_all_sta[i], mac_addr[i],
+			       ETH_ALEN);
+			PRINT_INFO(vif->ndev,
+				   CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+				   del_all_sta_info->del_all_sta[i][0],
+				   del_all_sta_info->del_all_sta[i][1],
+				   del_all_sta_info->del_all_sta[i][2],
+				   del_all_sta_info->del_all_sta[i][3],
+				   del_all_sta_info->del_all_sta[i][4],
+				   del_all_sta_info->del_all_sta[i][5]);
 			assoc_sta++;
 		}
 	}
-	if (!assoc_sta)
-		return result;
+	if (!assoc_sta) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "NO ASSOCIATED STAS\n");
+		kfree(msg);
+		return 0;
+	}
 
 	del_all_sta_info->assoc_sta = assoc_sta;
-	result = wilc_enqueue_cmd(&msg);
+	result = wilc_enqueue_work(msg);
 
 	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 	else
-		wait_for_completion(&hif_wait_response);
+		wait_for_completion(&msg->work_comp);
+
+	kfree(msg);
 
 	return result;
 }
@@ -3796,297 +4352,210 @@ int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 int wilc_edit_station(struct wilc_vif *vif,
 		      struct add_sta_param *sta_param)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *add_sta_info;
 
-	msg.id = HOST_IF_MSG_EDIT_STATION;
-	msg.vif = vif;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting editing station message queue params\n");
+	msg = wilc_alloc_work(vif, handle_edit_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
+	add_sta_info = &msg->body.add_sta_info;
+	memcpy(add_sta_info, sta_param, sizeof(*add_sta_info));
 	if (add_sta_info->rates_len > 0) {
 		add_sta_info->rates = kmemdup(sta_param->rates,
 					      add_sta_info->rates_len,
 					      GFP_KERNEL);
-		if (!add_sta_info->rates)
+		if (!add_sta_info->rates) {
+			kfree(msg);
 			return -ENOMEM;
+		}
 	}
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(add_sta_info->rates);
+		kfree(msg);
+	}
 
 	return result;
 }
 
 int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct power_mgmt_param *pwr_mgmt_info = &msg.body.pwr_mgmt_info;
+	int result;
+	struct host_if_msg *msg;
 
 	if (wilc_wlan_get_num_conn_ifcs(vif->wilc) == 2 && enabled)
 		return 0;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n>> Setting PS to %d <<\n\n",
+		   enabled);
+	msg = wilc_alloc_work(vif, handle_power_management, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_POWER_MGMT;
-	msg.vif = vif;
+	msg->body.pwr_mgmt_info.enabled = enabled;
+	msg->body.pwr_mgmt_info.timeout = timeout;
 
-	pwr_mgmt_info->enabled = enabled;
-	pwr_mgmt_info->timeout = timeout;
+	if (!vif->wilc->hif_workqueue)
+		return 0;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 	return result;
 }
 
 int wilc_setup_multicast_filter(struct wilc_vif *vif, bool enabled,
-				u32 count)
+				u32 count, u8 *mc_list)
 {
-	int result = 0;
-	struct host_if_msg msg;
-	struct set_multicast *multicast_filter_param = &msg.body.multicast_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	int result;
+	struct host_if_msg *msg;
 
-	msg.id = HOST_IF_MSG_SET_MULTICAST_FILTER;
-	msg.vif = vif;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting Multicast Filter params\n");
+	msg = wilc_alloc_work(vif, handle_set_mcast_filter, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	multicast_filter_param->enabled = enabled;
-	multicast_filter_param->cnt = count;
+	msg->body.multicast_info.enabled = enabled;
+	msg->body.multicast_info.cnt = count;
+	msg->body.multicast_info.mc_list = mc_list;
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 	return result;
 }
 
-static void *host_int_ParseJoinBssParam(struct network_info *ptstrNetworkInfo)
+int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)
 {
-	struct join_bss_param *pNewJoinBssParam = NULL;
-	u8 *pu8IEs;
-	u16 u16IEsLen;
-	u16 index = 0;
-	u8 suppRatesNo = 0;
-	u8 extSuppRatesNo;
-	u16 jumpOffset;
-	u8 pcipherCount;
-	u8 authCount;
-	u8 pcipherTotalCount = 0;
-	u8 authTotalCount = 0;
-	u8 i, j;
+	int ret;
+	struct host_if_msg *msg;
 
-	pu8IEs = ptstrNetworkInfo->ies;
-	u16IEsLen = ptstrNetworkInfo->ies_len;
-
-	pNewJoinBssParam = kzalloc(sizeof(*pNewJoinBssParam), GFP_KERNEL);
-	if (pNewJoinBssParam) {
-		pNewJoinBssParam->dtim_period = ptstrNetworkInfo->dtim_period;
-		pNewJoinBssParam->beacon_period = ptstrNetworkInfo->beacon_period;
-		pNewJoinBssParam->cap_info = ptstrNetworkInfo->cap_info;
-		memcpy(pNewJoinBssParam->bssid, ptstrNetworkInfo->bssid, 6);
-		memcpy((u8 *)pNewJoinBssParam->ssid, ptstrNetworkInfo->ssid,
-		       ptstrNetworkInfo->ssid_len + 1);
-		pNewJoinBssParam->ssid_len = ptstrNetworkInfo->ssid_len;
-		memset(pNewJoinBssParam->rsn_pcip_policy, 0xFF, 3);
-		memset(pNewJoinBssParam->rsn_auth_policy, 0xFF, 3);
-
-		while (index < u16IEsLen) {
-			if (pu8IEs[index] == SUPP_RATES_IE) {
-				suppRatesNo = pu8IEs[index + 1];
-				pNewJoinBssParam->supp_rates[0] = suppRatesNo;
-				index += 2;
-
-				for (i = 0; i < suppRatesNo; i++)
-					pNewJoinBssParam->supp_rates[i + 1] = pu8IEs[index + i];
-
-				index += suppRatesNo;
-			} else if (pu8IEs[index] == EXT_SUPP_RATES_IE) {
-				extSuppRatesNo = pu8IEs[index + 1];
-				if (extSuppRatesNo > (MAX_RATES_SUPPORTED - suppRatesNo))
-					pNewJoinBssParam->supp_rates[0] = MAX_RATES_SUPPORTED;
-				else
-					pNewJoinBssParam->supp_rates[0] += extSuppRatesNo;
-				index += 2;
-				for (i = 0; i < (pNewJoinBssParam->supp_rates[0] - suppRatesNo); i++)
-					pNewJoinBssParam->supp_rates[suppRatesNo + i + 1] = pu8IEs[index + i];
-
-				index += extSuppRatesNo;
-			} else if (pu8IEs[index] == HT_CAPABILITY_IE) {
-				pNewJoinBssParam->ht_capable = true;
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == WMM_IE) &&
-				   (pu8IEs[index + 2] == 0x00) && (pu8IEs[index + 3] == 0x50) &&
-				   (pu8IEs[index + 4] == 0xF2) &&
-				   (pu8IEs[index + 5] == 0x02) &&
-				   ((pu8IEs[index + 6] == 0x00) || (pu8IEs[index + 6] == 0x01)) &&
-				   (pu8IEs[index + 7] == 0x01)) {
-				pNewJoinBssParam->wmm_cap = true;
-
-				if (pu8IEs[index + 8] & BIT(7))
-					pNewJoinBssParam->uapsd_cap = true;
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == P2P_IE) &&
-				 (pu8IEs[index + 2] == 0x50) && (pu8IEs[index + 3] == 0x6f) &&
-				 (pu8IEs[index + 4] == 0x9a) &&
-				 (pu8IEs[index + 5] == 0x09) && (pu8IEs[index + 6] == 0x0c)) {
-				u16 u16P2P_count;
-
-				pNewJoinBssParam->tsf = ptstrNetworkInfo->tsf_lo;
-				pNewJoinBssParam->noa_enabled = 1;
-				pNewJoinBssParam->idx = pu8IEs[index + 9];
-
-				if (pu8IEs[index + 10] & BIT(7)) {
-					pNewJoinBssParam->opp_enabled = 1;
-					pNewJoinBssParam->ct_window = pu8IEs[index + 10];
-				} else {
-					pNewJoinBssParam->opp_enabled = 0;
-				}
-
-				pNewJoinBssParam->cnt = pu8IEs[index + 11];
-				u16P2P_count = index + 12;
-
-				memcpy(pNewJoinBssParam->duration, pu8IEs + u16P2P_count, 4);
-				u16P2P_count += 4;
-
-				memcpy(pNewJoinBssParam->interval, pu8IEs + u16P2P_count, 4);
-				u16P2P_count += 4;
-
-				memcpy(pNewJoinBssParam->start_time, pu8IEs + u16P2P_count, 4);
-
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == RSN_IE) ||
-				 ((pu8IEs[index] == WPA_IE) && (pu8IEs[index + 2] == 0x00) &&
-				  (pu8IEs[index + 3] == 0x50) && (pu8IEs[index + 4] == 0xF2) &&
-				  (pu8IEs[index + 5] == 0x01)))	{
-				u16 rsnIndex = index;
-
-				if (pu8IEs[rsnIndex] == RSN_IE)	{
-					pNewJoinBssParam->mode_802_11i = 2;
-				} else {
-					if (pNewJoinBssParam->mode_802_11i == 0)
-						pNewJoinBssParam->mode_802_11i = 1;
-					rsnIndex += 4;
-				}
-
-				rsnIndex += 7;
-				pNewJoinBssParam->rsn_grp_policy = pu8IEs[rsnIndex];
-				rsnIndex++;
-				jumpOffset = pu8IEs[rsnIndex] * 4;
-				pcipherCount = (pu8IEs[rsnIndex] > 3) ? 3 : pu8IEs[rsnIndex];
-				rsnIndex += 2;
-
-				for (i = pcipherTotalCount, j = 0; i < pcipherCount + pcipherTotalCount && i < 3; i++, j++)
-					pNewJoinBssParam->rsn_pcip_policy[i] = pu8IEs[rsnIndex + ((j + 1) * 4) - 1];
-
-				pcipherTotalCount += pcipherCount;
-				rsnIndex += jumpOffset;
-
-				jumpOffset = pu8IEs[rsnIndex] * 4;
-
-				authCount = (pu8IEs[rsnIndex] > 3) ? 3 : pu8IEs[rsnIndex];
-				rsnIndex += 2;
-
-				for (i = authTotalCount, j = 0; i < authTotalCount + authCount; i++, j++)
-					pNewJoinBssParam->rsn_auth_policy[i] = pu8IEs[rsnIndex + ((j + 1) * 4) - 1];
-
-				authTotalCount += authCount;
-				rsnIndex += jumpOffset;
-
-				if (pu8IEs[index] == RSN_IE) {
-					pNewJoinBssParam->rsn_cap[0] = pu8IEs[rsnIndex];
-					pNewJoinBssParam->rsn_cap[1] = pu8IEs[rsnIndex + 1];
-					rsnIndex += 2;
-				}
-				pNewJoinBssParam->rsn_found = true;
-				index += pu8IEs[index + 1] + 2;
-			} else {
-				index += pu8IEs[index + 1] + 2;
-			}
-		}
+	msg = wilc_alloc_work(vif, handle_set_tx_pwr, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	msg->body.tx_power.tx_pwr = tx_power;
+
+	ret = wilc_enqueue_work(msg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
 	}
 
-	return (void *)pNewJoinBssParam;
+	return ret;
 }
 
-int wilc_setup_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
+int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
 {
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_SET_IPADDRESS;
+	int ret;
+	struct host_if_msg *msg;
 
-	msg.body.ip_info.ip_addr = ip_addr;
-	msg.vif = vif;
-	msg.body.ip_info.idx = idx;
+	msg = wilc_alloc_work(vif, handle_get_tx_pwr, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	ret = wilc_enqueue_work(msg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+	} else {
+		wait_for_completion(&msg->work_comp);
+		*tx_power = msg->body.tx_power.tx_pwr;
+	}
 
-	return result;
+	/* free 'msg' after copying data */
+	kfree(msg);
+	return ret;
 }
 
-static int host_int_get_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
+bool is_valid_gpio(struct wilc_vif *vif, u8 gpio)
 {
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_GET_IPADDRESS;
-
-	msg.body.ip_info.ip_addr = ip_addr;
-	msg.vif = vif;
-	msg.body.ip_info.idx = idx;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return result;
+	switch (vif->wilc->chip) {
+	case WILC_1000:
+		if (gpio == 0 || gpio == 1 || gpio == 4 || gpio == 6)
+			return true;
+		else
+			return false;
+	case WILC_3000:
+		if (gpio == 0 || gpio == 3 || gpio == 4 ||
+			(gpio >= 17 && gpio <= 20))
+			return true;
+		else
+			return false;
+	default:
+		return false;
+	}
 }
 
-int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode)
 {
-	int ret = 0;
-	struct host_if_msg msg;
+	int ret;
+	struct host_if_msg *msg;
+	struct sysfs_attr_group *attr_syfs_p;
 
-	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg = wilc_alloc_work(vif, handle_set_antenna_mode, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
 
-	msg.id = HOST_IF_MSG_SET_TX_POWER;
-	msg.body.tx_power.tx_pwr = tx_power;
-	msg.vif = vif;
+	msg->body.set_ant.mode = mode;
+	attr_syfs_p = &vif->attr_sysfs;
 
-	ret = wilc_enqueue_cmd(&msg);
-	if (ret)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_INVALID_GPIO_CTRL) {
+		PRINT_ER(vif->ndev, "Ant switch GPIO mode is invalid.\n");
+		PRINT_ER(vif->ndev, "Set it using /sys/wilc1000/ant_swtch_mode\n");
+		return WILC_FAIL;
+	}
+
+	if (is_valid_gpio(vif, attr_syfs_p->antenna1)) {
+		msg->body.set_ant.antenna1 = attr_syfs_p->antenna1;
+	} else {
+		PRINT_ER(vif->ndev, "Invalid GPIO%d\n", attr_syfs_p->antenna1);
+		return WILC_FAIL;
+	}
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL) {
+		if ((attr_syfs_p->antenna2 != attr_syfs_p->antenna1) &&
+			is_valid_gpio(vif, attr_syfs_p->antenna2)) {
+			msg->body.set_ant.antenna2 = attr_syfs_p->antenna2;
+		} else {
+			PRINT_ER(vif->ndev, "Invalid GPIO %d\n",
+				 attr_syfs_p->antenna2);
+			return WILC_FAIL;
+		}
+	}
 
+	msg->body.set_ant.gpio_mode = attr_syfs_p->ant_swtch_mode;
+	ret = wilc_enqueue_work(msg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+		return -EINVAL;
+	}
 	return ret;
 }
 
-int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+int host_int_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger)
 {
-	int ret = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_GET_TX_POWER;
-	msg.vif = vif;
-
-	ret = wilc_enqueue_cmd(&msg);
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get TX PWR\n");
+	int result;
+	struct host_if_msg *msg;
 
-	wait_for_completion(&hif_wait_response);
-	*tx_power = msg.body.tx_power.tx_pwr;
+	msg = wilc_alloc_work(vif, handle_set_wowlan_trigger, false);
+	msg->body.wow_trigger.wowlan_trigger = wowlan_trigger;
 
-	return ret;
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
+	return result;
 }
diff --git a/drivers/staging/wilc1000/host_interface.h b/drivers/staging/wilc1000/host_interface.h
index 44a2f4b595c5..7dfb900dd2ab 100644
--- a/drivers/staging/wilc1000/host_interface.h
+++ b/drivers/staging/wilc1000/host_interface.h
@@ -1,20 +1,32 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
 #ifndef HOST_INT_H
 #define HOST_INT_H
 #include <linux/ieee80211.h>
-#include "coreconfigurator.h"
-
-#define IP_ALEN  4
+#include "wilc_wlan_if.h"
 
 #define IDLE_MODE	0x00
 #define AP_MODE		0x01
 #define STATION_MODE	0x02
 #define GO_MODE		0x03
 #define CLIENT_MODE	0x04
+#define MONITOR_MODE	0x05
+
 #define ACTION		0xD0
 #define PROBE_REQ	0x40
 #define PROBE_RESP	0x50
 
+#define P2P_IFC		0x00
+#define WLAN_IFC	0x01
+#define DEFAULT_IFC	0x03
+
+#define IFC_0 "wlan0"
+#define IFC_1 "p2p0"
+
 #define ACTION_FRM_IDX				0
 #define PROBE_REQ_IDX				1
 #define MAX_NUM_STA				9
@@ -49,11 +61,66 @@
 #define PMKID_LEN				16
 #define WILC_MAX_NUM_PMKIDS			16
 #define WILC_ADD_STA_LENGTH			40
-#define SCAN_EVENT_DONE_ABORTED
 #define NUM_CONCURRENT_IFC			2
 #define DRV_HANDLER_SIZE			5
 #define DRV_HANDLER_MASK			0x000000FF
 
+#define NUM_RSSI                5
+
+#define SET_CFG              0
+#define GET_CFG              1
+
+#define MAX_ASSOC_RESP_FRAME_SIZE   256
+extern uint32_t cfg_packet_timeout;
+
+struct rssi_history_buffer {
+	bool full;
+	u8 index;
+	s8 samples[NUM_RSSI];
+};
+
+struct network_info {
+	s8 rssi;
+	u16 cap_info;
+	u8 ssid[MAX_SSID_LEN];
+	u8 ssid_len;
+	u8 bssid[6];
+	u16 beacon_period;
+	u8 dtim_period;
+	u8 ch;
+	unsigned long time_scan_cached;
+	unsigned long time_scan;
+	bool new_network;
+	u8 found;
+	u32 tsf_lo;
+	u8 *ies;
+	u16 ies_len;
+	void *join_params;
+	struct rssi_history_buffer rssi_history;
+	u64 tsf_hi;
+};
+
+struct connect_info {
+	u8 bssid[6];
+	u8 *req_ies;
+	size_t req_ies_len;
+	u8 *resp_ies;
+	u16 resp_ies_len;
+	u16 status;
+};
+
+struct disconnect_info {
+	u16 reason;
+	u8 *ie;
+	size_t ie_len;
+};
+
+struct assoc_resp {
+	__le16 capab_info;
+	__le16 status_code;
+	__le16 aid;
+} __packed;
+
 struct rf_info {
 	u8 link_speed;
 	s8 rssi;
@@ -82,7 +149,7 @@ struct host_if_pmkid_attr {
 	struct host_if_pmkid pmkidlist[WILC_MAX_NUM_PMKIDS];
 };
 
-enum CURRENT_TXRATE {
+enum current_tx_rate {
 	AUTORATE	= 0,
 	MBPS_1		= 1,
 	MBPS_2		= 2,
@@ -101,26 +168,11 @@ enum CURRENT_TXRATE {
 struct cfg_param_attr {
 	u32 flag;
 	u8 ht_enable;
-	u8 bss_type;
-	u8 auth_type;
-	u16 auth_timeout;
-	u8 power_mgmt_mode;
 	u16 short_retry_limit;
 	u16 long_retry_limit;
 	u16 frag_threshold;
 	u16 rts_threshold;
-	u16 preamble_type;
-	u8 short_slot_allowed;
-	u8 txop_prot_disabled;
-	u16 beacon_interval;
-	u16 dtim_period;
-	enum SITESURVEY site_survey_enabled;
-	u16 site_survey_scan_time;
 	u8 scan_source;
-	u16 active_scan_time;
-	u16 passive_scan_time;
-	enum CURRENT_TXRATE curr_tx_rate;
-
 };
 
 enum cfg_param {
@@ -128,20 +180,6 @@ enum cfg_param {
 	RETRY_LONG		= BIT(1),
 	FRAG_THRESHOLD		= BIT(2),
 	RTS_THRESHOLD		= BIT(3),
-	BSS_TYPE		= BIT(4),
-	AUTH_TYPE		= BIT(5),
-	AUTHEN_TIMEOUT		= BIT(6),
-	POWER_MANAGEMENT	= BIT(7),
-	PREAMBLE		= BIT(8),
-	SHORT_SLOT_ALLOWED	= BIT(9),
-	TXOP_PROT_DISABLE	= BIT(10),
-	BEACON_INTERVAL		= BIT(11),
-	DTIM_PERIOD		= BIT(12),
-	SITE_SURVEY		= BIT(13),
-	SITE_SURVEY_SCAN_TIME	= BIT(14),
-	ACTIVE_SCANTIME		= BIT(15),
-	PASSIVE_SCANTIME	= BIT(16),
-	CURRENT_TX_RATE		= BIT(17),
 	HT_ENABLE		= BIT(18),
 };
 
@@ -158,9 +196,9 @@ enum scan_event {
 };
 
 enum conn_event {
-	CONN_DISCONN_EVENT_CONN_RESP		= 0,
-	CONN_DISCONN_EVENT_DISCONN_NOTIF	= 1,
-	CONN_DISCONN_EVENT_FORCE_32BIT		= 0xFFFFFFFF
+	EVENT_CONN_RESP		= 0,
+	EVENT_DISCONN_NOTIF	= 1,
+	EVENT_FORCE_32BIT		= 0xFFFFFFFF
 };
 
 enum KEY_TYPE {
@@ -182,6 +220,10 @@ typedef void (*wilc_connect_result)(enum conn_event,
 typedef void (*wilc_remain_on_chan_expired)(void *, u32);
 typedef void (*wilc_remain_on_chan_ready)(void *);
 
+typedef void (*wilc_frmw_to_linux_t)(struct wilc_vif *, u8 *, unsigned int,
+				     unsigned int, u8);
+typedef void (*free_eap_buf_param)(void *);
+
 struct rcvd_net_info {
 	u8 *buffer;
 	u32 len;
@@ -200,7 +242,7 @@ struct hidden_network {
 struct user_scan_req {
 	wilc_scan_result scan_result;
 	void *arg;
-	u32 rcvd_ch_cnt;
+	u32 ch_cnt;
 	struct found_net_info net_info[MAX_NUM_SCANNED_NETWORKS];
 };
 
@@ -208,7 +250,7 @@ struct user_conn_req {
 	u8 *bssid;
 	u8 *ssid;
 	u8 security;
-	enum AUTHTYPE auth_type;
+	enum authtype auth_type;
 	size_t ssid_len;
 	u8 *ies;
 	size_t ies_len;
@@ -220,14 +262,14 @@ struct user_conn_req {
 struct drv_handler {
 	u32 handler;
 	u8 mode;
-	u8 name;
+	u8 ifc_id;
 };
 
 struct op_mode {
 	u32 mode;
 };
 
-struct get_mac_addr {
+struct dev_mac_addr {
 	u8 *mac_addr;
 };
 
@@ -253,13 +295,6 @@ struct reg_frame {
 	u8 reg_id;
 };
 
-enum p2p_listen_state {
-	P2P_IDLE,
-	P2P_LISTEN,
-	P2P_GRP_FORMATION
-};
-
-struct wilc;
 struct host_if_drv {
 	struct user_scan_req usr_scan_req;
 	struct user_conn_req usr_conn_req;
@@ -271,20 +306,23 @@ struct host_if_drv {
 	enum host_if_state hif_state;
 
 	u8 assoc_bssid[ETH_ALEN];
-	struct cfg_param_attr cfg_values;
-
-	struct mutex cfg_values_lock;
 	struct completion comp_test_key_block;
 	struct completion comp_test_disconn_block;
 	struct completion comp_get_rssi;
 	struct completion comp_inactive_time;
 
 	struct timer_list scan_timer;
+	struct wilc_vif *scan_timer_vif;
+
 	struct timer_list connect_timer;
+	struct wilc_vif *connect_timer_vif;
+
 	struct timer_list remain_on_ch_timer;
+	struct wilc_vif *remain_on_ch_timer_vif;
 
-	bool IFC_UP;
+	bool ifc_up;
 	int driver_handler_id;
+	u8 assoc_resp[MAX_ASSOC_RESP_FRAME_SIZE];
 };
 
 struct add_sta_param {
@@ -299,18 +337,24 @@ struct add_sta_param {
 };
 
 struct wilc_vif;
-s32 wilc_remove_key(struct host_if_drv *hWFIDrv, const u8 *pu8StaAddress);
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  wilc_frmw_to_linux_t frmw_to_linux,
+				  free_eap_buf_param eap_buf_param,
+				  u8 *buff, unsigned int size,
+				  unsigned int pkt_offset,
+				  void *user_arg);
 int wilc_remove_wep_key(struct wilc_vif *vif, u8 index);
 int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index);
 int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
 			     u8 index);
 int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
-			    u8 index, u8 mode, enum AUTHTYPE auth_type);
+			    u8 index, u8 mode, enum authtype auth_type);
 int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index);
 s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
-			   u32 *pu32InactiveTime);
+			   u32 *out_val);
 int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    u8 index, u32 key_rsc_len, const u8 *key_rsc,
 		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
@@ -318,10 +362,11 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 int wilc_set_pmkid_info(struct wilc_vif *vif,
 			struct host_if_pmkid_attr *pmkid);
 int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr);
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr);
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ssid,
 		      size_t ssid_len, const u8 *ies, size_t ies_len,
 		      wilc_connect_result connect_result, void *user_arg,
-		      u8 security, enum AUTHTYPE auth_type,
+		      u8 security, enum authtype auth_type,
 		      u8 channel, void *join_params);
 int wilc_disconnect(struct wilc_vif *vif, u16 reason_code);
 int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel);
@@ -344,29 +389,33 @@ int wilc_edit_station(struct wilc_vif *vif,
 		      struct add_sta_param *sta_param);
 int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout);
 int wilc_setup_multicast_filter(struct wilc_vif *vif, bool enabled,
-				u32 count);
-int wilc_setup_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx);
+				u32 count, u8 *mc_list);
 int wilc_remain_on_channel(struct wilc_vif *vif, u32 session_id,
 			   u32 duration, u16 chan,
 			   wilc_remain_on_chan_expired expired,
 			   wilc_remain_on_chan_ready ready,
 			   void *user_arg);
 int wilc_listen_state_expired(struct wilc_vif *vif, u32 session_id);
-int wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg);
+void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg);
 int wilc_set_wfi_drv_handler(struct wilc_vif *vif, int index, u8 mode,
-			     u8 ifc_id);
+			     u8 ifc_id, bool is_sync);
 int wilc_set_operation_mode(struct wilc_vif *vif, u32 mode);
-int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats);
+int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats,
+			bool is_sync);
 void wilc_resolve_disconnect_aberration(struct wilc_vif *vif);
 int wilc_get_vif_idx(struct wilc_vif *vif);
 int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power);
 int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power);
-
-extern bool wilc_optaining_ip;
-extern u8 wilc_connected_ssid[6];
-extern u8 wilc_multicast_mac_addr_list[WILC_MULTICAST_TABLE_SIZE][ETH_ALEN];
-
-extern int wilc_connecting;
-extern struct timer_list wilc_during_ip_timer;
-
+/*0 select antenna 1 , 2 select antenna mode , 2 allow the firmware to choose
+ * the best antenna
+ */
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode);
+
+signed int host_int_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger);
+
+extern u8 wilc_initialized;
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt);
+void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length);
+void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length);
+void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 #endif
diff --git a/drivers/staging/wilc1000/linux_mon.c b/drivers/staging/wilc1000/linux_mon.c
index 91d49c4738dc..11f47d71ebda 100644
--- a/drivers/staging/wilc1000/linux_mon.c
+++ b/drivers/staging/wilc1000/linux_mon.c
@@ -1,65 +1,109 @@
 // SPDX-License-Identifier: GPL-2.0
-/*!
- *  @file	linux_mon.c
- *  @brief	File Operations OS wrapper functionality
- *  @author	mdaftedar
- *  @sa		wilc_wfi_netdevice.h
- *  @date	01 MAR 2012
- *  @version	1.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
+
+#include <linux/etherdevice.h>
+
 #include "wilc_wfi_cfgoperations.h"
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
 
-struct wilc_wfi_radiotap_hdr {
+struct wfi_rtap_hdr {
 	struct ieee80211_radiotap_header hdr;
 	u8 rate;
 } __packed;
 
-struct wilc_wfi_radiotap_cb_hdr {
+struct wfi_rtap_cb_hdr {
 	struct ieee80211_radiotap_header hdr;
 	u8 rate;
 	u8 dump;
 	u16 tx_flags;
 } __packed;
 
-static struct net_device *wilc_wfi_mon; /* global monitor netdev */
+struct net_device *wilc_wfi_mon;
 
 static u8 srcadd[6];
 static u8 bssid[6];
-static u8 broadcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-/**
- *  @brief      WILC_WFI_monitor_rx
- *  @details
- *  @param[in]
- *  @return     int : Return 0 on Success
- *  @author	mdaftedar
- *  @date	12 JUL 2012
- *  @version	1.0
- */
 
 #define IEEE80211_RADIOTAP_F_TX_RTS	0x0004  /* used rts/cts handshake */
 #define IEEE80211_RADIOTAP_F_TX_FAIL	0x0001  /* failed due to excessive*/
-#define IS_MANAGMEMENT				0x100
-#define IS_MANAGMEMENT_CALLBACK			0x080
-#define IS_MGMT_STATUS_SUCCES			0x040
-#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
 
-void WILC_WFI_monitor_rx(u8 *buff, u32 size)
+#define TX_RADIOTAP_PRESENT ((1 << IEEE80211_RADIOTAP_RATE) |	\
+			     (1 << IEEE80211_RADIOTAP_TX_FLAGS))
+
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size)
+{
+	struct wilc_vif *vif = 0;
+	struct sk_buff *skb = NULL;
+	struct wfi_rtap_hdr *hdr;
+	int i;
+
+	for (i = 0; i <= wilc->vif_num; i++) {
+		if (wilc->vif[i]->iftype == MONITOR_MODE) {
+			vif = wilc->vif[i];
+			break;
+		}
+	}
+
+	if (!vif) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG, "Monitor interface not up\n");
+		return;
+	}
+
+	skb = dev_alloc_skb(size + sizeof(*hdr));
+
+	if (!skb) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Monitor if : No memory to allocate skb");
+		return;
+	}
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff, size);
+	hdr = skb_push(skb, sizeof(*hdr));
+#else
+	memcpy(skb_put(skb, size), buff, size);
+	hdr = (struct wfi_rtap_hdr *)skb_push(skb, sizeof(*hdr));
+#endif
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
+	hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+	PRINT_D(vif->ndev, HOSTAPD_DBG,
+		"Radiotap len %d\n", hdr->hdr.it_len);
+	hdr->hdr.it_present = cpu_to_le32
+			(1 << IEEE80211_RADIOTAP_RATE); /* | */
+	PRINT_D(vif->ndev, HOSTAPD_DBG, "Presentflags %d\n",
+		hdr->hdr.it_present);
+	hdr->rate = 5; /* txrate->bitrate / 5; */
+	skb->dev = vif->ndev;
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx(skb);
+}
+
+void wilc_wfi_monitor_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 {
 	u32 header, pkt_offset;
 	struct sk_buff *skb = NULL;
-	struct wilc_wfi_radiotap_hdr *hdr;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
+	struct wfi_rtap_hdr *hdr;
+	struct wfi_rtap_cb_hdr *cb_hdr;
 
+	PRINT_D(vif->ndev, HOSTAPD_DBG,
+		"In monitor interface receive function\n");
 	if (!wilc_wfi_mon)
 		return;
 
-	if (!netif_running(wilc_wfi_mon))
+	if (!netif_running(wilc_wfi_mon)) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Monitor interface already RUNNING\n");
 		return;
+	}
 
 	/* Get WILC header */
 	memcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);
+	le32_to_cpus(&header);
 	/*
 	 * The packet offset field contain info about what type of management
 	 * the frame we are dealing with and ack status
@@ -69,24 +113,30 @@ void WILC_WFI_monitor_rx(u8 *buff, u32 size)
 	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
 		/* hostapd callback mgmt frame */
 
-		skb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_cb_hdr));
-		if (!skb)
+		skb = dev_alloc_skb(size + sizeof(*cb_hdr));
+		if (!skb) {
+			PRINT_D(vif->ndev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 
 		cb_hdr = skb_push(skb, sizeof(*cb_hdr));
-		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		cb_hdr = (struct wfi_rtap_cb_hdr *)skb_push(skb,
+							    sizeof(*cb_hdr));
+	#endif
+		memset(cb_hdr, 0, sizeof(*cb_hdr));
 
 		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
 
-		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_cb_hdr));
+		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(*cb_hdr));
 
-		cb_hdr->hdr.it_present = cpu_to_le32(
-				(1 << IEEE80211_RADIOTAP_RATE) |
-				(1 << IEEE80211_RADIOTAP_TX_FLAGS));
+		cb_hdr->hdr.it_present = cpu_to_le32(TX_RADIOTAP_PRESENT);
 
-		cb_hdr->rate = 5; /* txrate->bitrate / 5; */
+		cb_hdr->rate = 5;
 
 		if (pkt_offset & IS_MGMT_STATUS_SUCCES)	{
 			/* success */
@@ -96,19 +146,31 @@ void WILC_WFI_monitor_rx(u8 *buff, u32 size)
 		}
 
 	} else {
-		skb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_hdr));
+		skb = dev_alloc_skb(size + sizeof(*hdr));
 
-		if (!skb)
+		if (!skb) {
+			PRINT_D(vif->ndev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 		hdr = skb_push(skb, sizeof(*hdr));
-		memset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		hdr = (struct wfi_rtap_hdr *)skb_push(skb,
+							       sizeof(*hdr));
+	#endif
+		memset(hdr, 0, sizeof(*hdr));
 		hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
-		hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_hdr));
+		hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Radiotap len %d\n", hdr->hdr.it_len);
 		hdr->hdr.it_present = cpu_to_le32
 				(1 << IEEE80211_RADIOTAP_RATE); /* | */
-		hdr->rate = 5; /* txrate->bitrate / 5; */
+		PRINT_D(vif->ndev, HOSTAPD_DBG, "Presentflags %d\n",
+			hdr->hdr.it_present);
+		hdr->rate = 5;
 	}
 
 	skb->dev = wilc_wfi_mon;
@@ -129,6 +191,18 @@ struct tx_complete_mon_data {
 static void mgmt_tx_complete(void *priv, int status)
 {
 	struct tx_complete_mon_data *pv_data = priv;
+	u8 *buf =  pv_data->buff;
+
+	if (status == 1) {
+		if (buf[0] == 0x10 || buf[0] == 0xb0)
+			PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG,
+				   "Packet sent Size = %d Add = %p.\n",
+				   pv_data->size, pv_data->buff);
+	} else {
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG,
+			   "Couldn't send packet Size = %d Add = %p.\n",
+			   pv_data->size, pv_data->buff);
+	}
 	/*
 	 * in case of fully hosting mode, the freeing will be done
 	 * in response to the cfg packet
@@ -142,15 +216,20 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct tx_complete_mon_data *mgmt_tx = NULL;
 
-	if (!dev)
+	if (!dev) {
+		PRINT_ER(dev, "ERROR: dev == NULL\n");
 		return -EFAULT;
+	}
 
 	netif_stop_queue(dev);
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);
-	if (!mgmt_tx)
+	if (!mgmt_tx) {
+		PRINT_ER(dev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
 		return -ENOMEM;
+	}
 
-	mgmt_tx->buff = kmalloc(len, GFP_ATOMIC);
+	mgmt_tx->buff = kmemdup(buf, len, GFP_ATOMIC);
 	if (!mgmt_tx->buff) {
 		kfree(mgmt_tx);
 		return -ENOMEM;
@@ -158,87 +237,51 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 
 	mgmt_tx->size = len;
 
-	memcpy(mgmt_tx->buff, buf, len);
-	wilc_wlan_txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,
+	txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,
 				   mgmt_tx_complete);
 
 	netif_wake_queue(dev);
 	return 0;
 }
 
-/**
- *  @brief      WILC_WFI_mon_xmit
- *  @details
- *  @param[in]
- *  @return     int : Return 0 on Success
- *  @author	mdaftedar
- *  @date	12 JUL 2012
- *  @version	1.0
- */
-static netdev_tx_t WILC_WFI_mon_xmit(struct sk_buff *skb,
+static netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,
 				     struct net_device *dev)
 {
 	u32 rtap_len, ret = 0;
-	struct WILC_WFI_mon_priv  *mon_priv;
-
-	struct sk_buff *skb2;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
+	struct wilc_wfi_mon_priv  *mon_priv;
 
 	if (!wilc_wfi_mon)
 		return -EFAULT;
 
 	mon_priv = netdev_priv(wilc_wfi_mon);
-	if (!mon_priv)
+	if (!mon_priv) {
+		PRINT_ER(dev, "Monitor interface private structure is NULL\n");
 		return -EFAULT;
+	}
 	rtap_len = ieee80211_get_radiotap_len(skb->data);
-	if (skb->len < rtap_len)
+	if (skb->len < rtap_len) {
+		PRINT_ER(dev, "Error in radiotap header\n");
 		return -1;
+	}
 
 	skb_pull(skb, rtap_len);
 
-	if (skb->data[0] == 0xc0 && (!(memcmp(broadcast, &skb->data[4], 6)))) {
-		skb2 = dev_alloc_skb(skb->len + sizeof(struct wilc_wfi_radiotap_cb_hdr));
-		if (!skb2)
-			return -ENOMEM;
-
-		skb_put_data(skb2, skb->data, skb->len);
-
-		cb_hdr = skb_push(skb2, sizeof(*cb_hdr));
-		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
-
-		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_present = cpu_to_le32(
-				(1 << IEEE80211_RADIOTAP_RATE) |
-				(1 << IEEE80211_RADIOTAP_TX_FLAGS));
-
-		cb_hdr->rate = 5; /* txrate->bitrate / 5; */
-		cb_hdr->tx_flags = 0x0004;
-
-		skb2->dev = wilc_wfi_mon;
-		skb_reset_mac_header(skb2);
-		skb2->ip_summed = CHECKSUM_UNNECESSARY;
-		skb2->pkt_type = PACKET_OTHERHOST;
-		skb2->protocol = htons(ETH_P_802_2);
-		memset(skb2->cb, 0, sizeof(skb2->cb));
-
-		netif_rx(skb2);
-
-		return 0;
-	}
 	skb->dev = mon_priv->real_ndev;
 
-	/* Identify if Ethernet or MAC header (data or mgmt) */
+	PRINT_D(dev, HOSTAPD_DBG, "Skipping the radiotap header\n");
+	PRINT_D(dev, HOSTAPD_DBG, "SKB netdevice name = %s\n", skb->dev->name);
+	PRINT_D(dev, HOSTAPD_DBG, "MONITOR real dev name = %s\n",
+		mon_priv->real_ndev->name);
 	memcpy(srcadd, &skb->data[10], 6);
 	memcpy(bssid, &skb->data[16], 6);
-	/* if source address and bssid fields are equal>>Mac header */
-	/*send it to mgmt frames handler */
+	/*
+	 * Identify if data or mgmt packet, if source address and bssid
+	 * fields are equal send it to mgmt frames handler
+	 */
 	if (!(memcmp(srcadd, bssid, 6))) {
 		ret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);
 		if (ret)
-			netdev_err(dev, "fail to mgmt tx\n");
+			PRINT_ER(dev, "fail to mgmt tx\n");
 		dev_kfree_skb(skb);
 	} else {
 		ret = wilc_mac_xmit(skb, mon_priv->real_ndev);
@@ -248,69 +291,57 @@ static netdev_tx_t WILC_WFI_mon_xmit(struct sk_buff *skb,
 }
 
 static const struct net_device_ops wilc_wfi_netdev_ops = {
-	.ndo_start_xmit         = WILC_WFI_mon_xmit,
+	.ndo_start_xmit         = wilc_wfi_mon_xmit,
 
 };
 
-/**
- *  @brief      WILC_WFI_init_mon_interface
- *  @details
- *  @param[in]
- *  @return     int : Return 0 on Success
- *  @author	mdaftedar
- *  @date	12 JUL 2012
- *  @version	1.0
- */
-struct net_device *WILC_WFI_init_mon_interface(const char *name,
+struct net_device *wilc_wfi_init_mon_interface(const char *name,
 					       struct net_device *real_dev)
 {
-	u32 ret = 0;
-	struct WILC_WFI_mon_priv *priv;
+	struct wilc_wfi_mon_priv *priv;
 
 	/*If monitor interface is already initialized, return it*/
 	if (wilc_wfi_mon)
 		return wilc_wfi_mon;
 
-	wilc_wfi_mon = alloc_etherdev(sizeof(struct WILC_WFI_mon_priv));
-	if (!wilc_wfi_mon)
+	wilc_wfi_mon = alloc_etherdev(sizeof(struct wilc_wfi_mon_priv));
+	if (!wilc_wfi_mon) {
+		PRINT_ER(real_dev, "failed to allocate memory\n");
 		return NULL;
+	}
 	wilc_wfi_mon->type = ARPHRD_IEEE80211_RADIOTAP;
 	strncpy(wilc_wfi_mon->name, name, IFNAMSIZ);
 	wilc_wfi_mon->name[IFNAMSIZ - 1] = 0;
 	wilc_wfi_mon->netdev_ops = &wilc_wfi_netdev_ops;
 
-	ret = register_netdevice(wilc_wfi_mon);
-	if (ret) {
-		netdev_err(real_dev, "register_netdevice failed\n");
+	if (register_netdevice(wilc_wfi_mon)) {
+		PRINT_ER(real_dev, "register_netdevice failed\n");
 		return NULL;
 	}
 	priv = netdev_priv(wilc_wfi_mon);
-	if (!priv)
+	if (!priv) {
+		PRINT_ER(real_dev, "private structure is NULL\n");
 		return NULL;
+	}
 
 	priv->real_ndev = real_dev;
 
 	return wilc_wfi_mon;
 }
 
-/**
- *  @brief      WILC_WFI_deinit_mon_interface
- *  @details
- *  @param[in]
- *  @return     int : Return 0 on Success
- *  @author	mdaftedar
- *  @date	12 JUL 2012
- *  @version	1.0
- */
-int WILC_WFI_deinit_mon_interface(void)
+void wilc_wfi_deinit_mon_interface(void)
 {
 	bool rollback_lock = false;
 
 	if (wilc_wfi_mon) {
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG,
+			   "In Deinit monitor interface\n");
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG, "Locking RTNL\n");
 		if (rtnl_is_locked()) {
 			rtnl_unlock();
 			rollback_lock = true;
 		}
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG, "Unregister netdev\n");
 		unregister_netdev(wilc_wfi_mon);
 
 		if (rollback_lock) {
@@ -319,5 +350,4 @@ int WILC_WFI_deinit_mon_interface(void)
 		}
 		wilc_wfi_mon = NULL;
 	}
-	return 0;
 }
diff --git a/drivers/staging/wilc1000/linux_wlan.c b/drivers/staging/wilc1000/linux_wlan.c
index 119f3459b5bb..38ad88a9a1e5 100644
--- a/drivers/staging/wilc1000/linux_wlan.c
+++ b/drivers/staging/wilc1000/linux_wlan.c
@@ -1,59 +1,250 @@
-#include "wilc_wfi_cfgoperations.h"
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
 
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <linux/gpio.h>
-
 #include <linux/kthread.h>
 #include <linux/firmware.h>
-
 #include <linux/init.h>
 #include <linux/netdevice.h>
-#include <linux/inetdevice.h>
 #include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <net/ip.h>
 #include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/skbuff.h>
-#include <linux/mutex.h>
-#include <linux/completion.h>
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+#include <linux/inetdevice.h>
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
 
-static int dev_state_ev_handler(struct notifier_block *this,
-				unsigned long event, void *ptr);
+#include "linux_wlan.h"
+#include "wilc_wfi_cfgoperations.h"
 
-static struct notifier_block g_dev_notifier = {
-	.notifier_call = dev_state_ev_handler
-};
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+bool g_ignore_PS_state;
+#define DURING_IP_TIME_OUT		15000
+
+void handle_pwrsave_for_IP(struct wilc_vif *vif, uint8_t state)
+{
+	struct wilc_priv *priv;
+
+	priv = wdev_priv(vif->ndev->ieee80211_ptr);
+
+	switch (state) {
+	case IP_STATE_OBTAINING:
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Obtaining IP, Disable (Scan-Set PowerSave)\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Save the Current state of the PS = %d\n",
+			   vif->pwrsave_current_state);
+
+		vif->obtaining_ip = true;
+
+		/* Set this flag to avoid storing the disabled case of PS which
+		 * occurs duringIP
+		 */
+		g_ignore_PS_state = true;
+
+		wilc_set_power_mgmt(vif, 0, 0);
+
+		/* Start the DuringIPTimer */
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		vif->during_ip_timer.data = (uint32_t)vif;
+	#endif
+		mod_timer(&vif->during_ip_timer,
+			  (jiffies + msecs_to_jiffies(20000)));
+
+		break;
+
+	case IP_STATE_OBTAINED:
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "IP obtained , Enable (Scan-Set PowerSave)\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Recover the state of the PS = %d\n",
+			   vif->pwrsave_current_state);
+
+		vif->obtaining_ip = false;
+
+		wilc_set_power_mgmt(vif, vif->pwrsave_current_state, 0);
+
+		del_timer(&vif->during_ip_timer);
+
+		break;
 
-static int wlan_deinit_locks(struct net_device *dev);
-static void wlan_deinitialize_threads(struct net_device *dev);
+	case IP_STATE_GO_ASSIGNING:
 
-static void linux_wlan_tx_complete(void *priv, int status);
-static int  mac_init_fn(struct net_device *ndev);
-static struct net_device_stats *mac_stats(struct net_device *dev);
-static int  mac_ioctl(struct net_device *ndev, struct ifreq *req, int cmd);
+		vif->obtaining_ip = true;
+
+		/* Start the DuringIPTimer */
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		vif->during_ip_timer.data = (uint32_t)vif;
+	#endif
+		mod_timer(&vif->during_ip_timer,
+			  (jiffies + msecs_to_jiffies(DURING_IP_TIME_OUT)));
+
+		break;
+
+	default: //IP_STATE_DEFAULT
+
+		vif->obtaining_ip = false;
+
+		/* Stop the DuringIPTimer */
+		del_timer(&vif->during_ip_timer);
+
+		break;
+	}
+}
+
+void store_power_save_current_state(struct wilc_vif *vif, bool val)
+{
+	if (g_ignore_PS_state) {
+		g_ignore_PS_state = false;
+		return;
+	}
+	vif->pwrsave_current_state = val;
+}
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void clear_during_ip(struct timer_list *t)
+#else
+void clear_during_ip(unsigned long arg)
+#endif
+{
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_vif *vif = from_timer(vif, t, during_ip_timer);
+#else
+	struct wilc_vif *vif = (struct wilc_vif *)arg;
+#endif
+
+	PRINT_ER(vif->ndev, "Unable to Obtain IP\n");
+
+	vif->obtaining_ip = false;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Recover PS = %d\n",
+		   vif->pwrsave_current_state);
+
+	/* Recover PS previous state */
+	wilc_set_power_mgmt(vif, vif->pwrsave_current_state, 0);
+}
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
+
+void wilc_frmw_to_linux(struct wilc_vif *vif, u8 *buff, u32 size,
+			u32 pkt_offset, u8 status);
 static int wilc_mac_open(struct net_device *ndev);
 static int wilc_mac_close(struct net_device *ndev);
-static void wilc_set_multicast_list(struct net_device *dev);
 
-bool wilc_enable_ps = true;
+int debug_running;
+int recovery_on;
+int wait_for_recovery;
+static int debug_thread(void *arg)
+{
+	struct net_device *dev = arg;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl;
+	struct wilc_priv *priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
+	signed long timeout;
+	struct host_if_drv *hif_drv = (struct host_if_drv *)priv->hif_drv;
+	int i = 0;
 
-static const struct net_device_ops wilc_netdev_ops = {
-	.ndo_init = mac_init_fn,
-	.ndo_open = wilc_mac_open,
-	.ndo_stop = wilc_mac_close,
-	.ndo_start_xmit = wilc_mac_xmit,
-	.ndo_do_ioctl = mac_ioctl,
-	.ndo_get_stats = mac_stats,
-	.ndo_set_rx_mode  = wilc_set_multicast_list,
+	if (!vif)
+		return -1;
 
-};
+	wl = vif->wilc;
+	if (!wl)
+		return -1;
+
+	complete(&wl->debug_thread_started);
+
+	while (1) {
+		if (!wl->initialized && !kthread_should_stop()) {
+			msleep(1000);
+			continue;
+		} else if (!wl->initialized) {
+			break;
+		}
+
+		if (wait_for_completion_timeout(&wl->debug_thread_started,
+						msecs_to_jiffies(6000))) {
+			while (!kthread_should_stop())
+				schedule();
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Exit debug thread\n");
+			return 0;
+		}
 
+		if (!debug_running)
+			continue;
+		PRINT_INFO(dev, GENERIC_DBG,
+			   "*** Debug Thread Running ***\n");
+		if (cfg_packet_timeout < 5)
+			continue;
+
+		PRINT_INFO(dev, GENERIC_DBG,
+			   "<Recover>\n");
+		cfg_packet_timeout = 0;
+		timeout = 10;
+		recovery_on = 1;
+		wait_for_recovery = 1;
+		for (i = 0; i < NUM_CONCURRENT_IFC; i++)
+			wilc_mac_close(wl->vif[i]->ndev);
+		for (i = NUM_CONCURRENT_IFC; i > 0; i--) {
+			while (wilc_mac_open(wl->vif[i-1]->ndev) && --timeout)
+				msleep(100);
+
+			if (timeout == 0)
+				PRINT_WRN(vif->ndev, GENERIC_DBG,
+					  "Couldn't restart ifc %d\n", i);
+		}
+		if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			struct disconnect_info disconnect;
+			struct user_conn_req *con_req = &hif_drv->usr_conn_req;
+
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "notify the user with the Disconnection\n");
+			memset(&disconnect, 0, sizeof(struct disconnect_info));
+			if (hif_drv->usr_scan_req.scan_result) {
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "Abort the running OBSS Scan\n");
+				del_timer(&hif_drv->scan_timer);
+				handle_scan_done(vif, SCAN_EVENT_ABORTED);
+			}
+			disconnect.reason = 0;
+			disconnect.ie = NULL;
+			disconnect.ie_len = 0;
+
+			if (con_req->conn_result) {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+
+				handle_pwrsave_for_IP(vif, IP_STATE_DEFAULT);
+#endif
+
+				con_req->conn_result(EVENT_DISCONN_NOTIF, NULL,
+						     0, &disconnect,
+						     con_req->arg);
+			} else {
+				PRINT_ER(vif->ndev, "Connect result NULL\n");
+			}
+			eth_zero_addr(hif_drv->assoc_bssid);
+
+			con_req->ssid_len = 0;
+			kfree(con_req->ssid);
+			con_req->ssid = NULL;
+			kfree(con_req->bssid);
+			con_req->bssid = NULL;
+			con_req->ies_len = 0;
+			kfree(con_req->ies);
+			con_req->ies = NULL;
+
+			hif_drv->hif_state = HOST_IF_IDLE;
+		}
+		recovery_on = 0;
+	}
+	return 0;
+}
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
 static int dev_state_ev_handler(struct notifier_block *this,
 				unsigned long event, void *ptr)
 {
@@ -64,89 +255,116 @@ static int dev_state_ev_handler(struct notifier_block *this,
 	u8 *ip_addr_buf;
 	struct wilc_vif *vif;
 	u8 null_ip[4] = {0};
-	char wlan_dev_name[5] = "wlan0";
 
-	if (!dev_iface || !dev_iface->ifa_dev || !dev_iface->ifa_dev->dev)
+	if (!dev_iface || !dev_iface->ifa_dev || !dev_iface->ifa_dev->dev) {
+		pr_err("dev_iface = NULL\n");
 		return NOTIFY_DONE;
+	}
 
-	if (memcmp(dev_iface->ifa_label, "wlan0", 5) &&
-	    memcmp(dev_iface->ifa_label, "p2p0", 4))
+	dev  = (struct net_device *)dev_iface->ifa_dev->dev;
+	vif = netdev_priv(dev);
+	if (memcmp(dev_iface->ifa_label, IFC_0, 5) &&
+	    memcmp(dev_iface->ifa_label, IFC_1, 4)) {
+		pr_info("Interface is neither WLAN0 nor P2P0\n");
 		return NOTIFY_DONE;
+	}
 
-	dev  = (struct net_device *)dev_iface->ifa_dev->dev;
-	if (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)
+	if (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy) {
+		pr_err("No Wireless registerd\n");
 		return NOTIFY_DONE;
+	}
 
 	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
-	if (!priv)
+	if (!priv) {
+		pr_err("No Wireless Priv\n");
 		return NOTIFY_DONE;
-
+	}
 	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	vif = netdev_priv(dev);
-	if (!vif || !hif_drv)
+	if (!vif || !hif_drv) {
+		PRINT_WRN(vif->ndev, GENERIC_DBG, "No Wireless Priv\n");
 		return NOTIFY_DONE;
+	}
 
 	switch (event) {
 	case NETDEV_UP:
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "event NETDEV_UP%p\n", dev);
+		PRINT_D(vif->ndev, GENERIC_DBG,
+			"\n =========== IP Address Obtained ============\n\n");
 		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
-			hif_drv->IFC_UP = 1;
-			wilc_optaining_ip = false;
-			del_timer(&wilc_during_ip_timer);
-		}
-
-		if (wilc_enable_ps)
-			wilc_set_power_mgmt(vif, 1, 0);
+			hif_drv->ifc_up = 1;
 
-		netdev_dbg(dev, "[%s] Up IP\n", dev_iface->ifa_label);
+			handle_pwrsave_for_IP(vif,
+							  IP_STATE_OBTAINED);
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[%s] Up IP\n",
+			   dev_iface->ifa_label);
 
 		ip_addr_buf = (char *)&dev_iface->ifa_address;
-		netdev_dbg(dev, "IP add=%d:%d:%d:%d\n",
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "IP add=%d:%d:%d:%d\n",
 			   ip_addr_buf[0], ip_addr_buf[1],
 			   ip_addr_buf[2], ip_addr_buf[3]);
-		wilc_setup_ipaddress(vif, ip_addr_buf, vif->idx);
 
 		break;
 
 	case NETDEV_DOWN:
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "event=NETDEV_DOWN %p\n",
+			   dev);
+		PRINT_D(vif->ndev, GENERIC_DBG,
+			"\n =========== IP Address Released ============\n\n");
 		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
-			hif_drv->IFC_UP = 0;
-			wilc_optaining_ip = false;
+			hif_drv->ifc_up = 0;
+			handle_pwrsave_for_IP(vif, IP_STATE_DEFAULT);
 		}
 
-		if (memcmp(dev_iface->ifa_label, wlan_dev_name, 5) == 0)
-			wilc_set_power_mgmt(vif, 0, 0);
 
 		wilc_resolve_disconnect_aberration(vif);
 
-		netdev_dbg(dev, "[%s] Down IP\n", dev_iface->ifa_label);
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[%s] Down IP\n",
+			   dev_iface->ifa_label);
 
 		ip_addr_buf = null_ip;
-		netdev_dbg(dev, "IP add=%d:%d:%d:%d\n",
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "IP add=%d:%d:%d:%d\n",
 			   ip_addr_buf[0], ip_addr_buf[1],
 			   ip_addr_buf[2], ip_addr_buf[3]);
-
-		wilc_setup_ipaddress(vif, ip_addr_buf, vif->idx);
-
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "[%s] unknown dev event %lu\n",
+			   dev_iface->ifa_label, event);
 		break;
 	}
 
 	return NOTIFY_DONE;
 }
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
+
+void linux_wlan_disable_irq(struct wilc *wilc, int wait)
+{
+	if (wait) {
+		PRINT_INFO(wilc->vif[0]->ndev, INT_DBG, "Disabling IRQ ...\n");
+		disable_irq(wilc->dev_irq_num);
+	} else {
+		PRINT_INFO(wilc->vif[0]->ndev, INT_DBG, "Disabling IRQ ...\n");
+		disable_irq_nosync(wilc->dev_irq_num);
+	}
+}
+
+static irqreturn_t host_wakeup_isr(int irq, void *user_data)
+{
+	return IRQ_HANDLED;
+}
 
 static irqreturn_t isr_uh_routine(int irq, void *user_data)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	struct net_device *dev = user_data;
+	struct wilc *wilc = (struct wilc *)user_data;
+	struct net_device *dev = wilc->vif[0]->ndev;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+
+	PRINT_INFO(dev, INT_DBG, "Interrupt received UH\n");
 
 	if (wilc->close) {
-		netdev_err(dev, "Can't handle UH interrupt\n");
+		PRINT_ER(dev, "Can't handle UH interrupt\n");
 		return IRQ_HANDLED;
 	}
 	return IRQ_WAKE_THREAD;
@@ -154,18 +372,16 @@ static irqreturn_t isr_uh_routine(int irq, void *user_data)
 
 static irqreturn_t isr_bh_routine(int irq, void *userdata)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	struct net_device *dev = userdata;
+	struct wilc *wilc = (struct wilc *)userdata;
+	struct net_device *dev = wilc->vif[0]->ndev;
 
-	vif = netdev_priv(userdata);
-	wilc = vif->wilc;
 
 	if (wilc->close) {
-		netdev_err(dev, "Can't handle BH interrupt\n");
+		PRINT_ER(dev, "Can't handle BH interrupt\n");
 		return IRQ_HANDLED;
 	}
 
+	PRINT_INFO(dev, INT_DBG, "Interrupt received BH\n");
 	wilc_handle_isr(wilc);
 
 	return IRQ_HANDLED;
@@ -174,98 +390,196 @@ static irqreturn_t isr_bh_routine(int irq, void *userdata)
 static int init_irq(struct net_device *dev)
 {
 	int ret = 0;
-	struct wilc_vif *vif;
-	struct wilc *wl;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
 
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+
+	wl->gpio_irq = gpiod_get(wl->dt_dev, "irq", GPIOD_IN);
+	if (IS_ERR(wl->gpio_irq)) {
+		dev_warn(wl->dev, "failed to get IRQ GPIO, load default\r\n");
+		wl->gpio_irq = gpio_to_desc(GPIO_NUM);
+		if (!wl->gpio_irq) {
+			dev_warn(wl->dev, "failed to load default irq\r\n");
+			return -1;
+		}
+	} else {
+		dev_info(wl->dev, "got gpio_irq successfully\r\n");
+	}
+
+	ret = gpiod_direction_input(wl->gpio_irq);
+	if (ret) {
+		PRINT_ER(dev, "could not obtain gpio for WILC_INTR\n");
+		return ret;
+	}
+
+	wl->dev_irq_num = gpiod_to_irq(wl->gpio_irq);
+	if (wl->dev_irq_num < 0) {
+		PRINT_ER(dev, "could not the IRQ\n");
+		goto free_gpio;
+	}
+#else
+	wl->gpio_irq = of_get_named_gpio_flags(wl->dt_dev->of_node,
+					       "irq-gpios", 0, NULL);
+	if (wl->gpio_irq < 0) {
+		wl->gpio_irq = GPIO_NUM;
+		dev_warn(wl->dev, "failed to get IRQ GPIO, load default\r\n");
+	}
 
-	if ((gpio_request(wl->gpio, "WILC_INTR") == 0) &&
-	    (gpio_direction_input(wl->gpio) == 0)) {
-		wl->dev_irq_num = gpio_to_irq(wl->gpio);
+	if ((gpio_request(wl->gpio_irq, "WILC_INTR") == 0) &&
+	    (gpio_direction_input(wl->gpio_irq) == 0)) {
+		wl->dev_irq_num = gpio_to_irq(wl->gpio_irq);
 	} else {
-		ret = -1;
-		netdev_err(dev, "could not obtain gpio for WILC_INTR\n");
+		dev_err(wl->dev, "could not obtain gpio for WILC_INTR\n");
+		wl->gpio_irq = 0;
+		return -1;
 	}
 
-	if (ret != -1 && request_threaded_irq(wl->dev_irq_num,
-					      isr_uh_routine,
-					      isr_bh_routine,
-					      IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-					      "WILC_IRQ", dev) < 0) {
-		netdev_err(dev, "Failed to request IRQ GPIO: %d\n", wl->gpio);
-		gpio_free(wl->gpio);
-		ret = -1;
+#endif
+
+	if (wl->io_type == HIF_SPI ||
+		wl->io_type == HIF_SDIO_GPIO_IRQ) {
+		if (request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
+					 isr_bh_routine, IRQF_TRIGGER_LOW |
+							IRQF_ONESHOT |
+							IRQF_NO_SUSPEND,
+					 "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ\n");
+			goto free_gpio;
+		}
 	} else {
-		netdev_dbg(dev,
-			   "IRQ request succeeded IRQ-NUM= %d on GPIO: %d\n",
-			   wl->dev_irq_num, wl->gpio);
+		if (request_irq(wl->dev_irq_num, host_wakeup_isr,
+					     IRQF_TRIGGER_FALLING |
+					     IRQF_NO_SUSPEND,
+					     "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ\n");
+			goto free_gpio;
+		}
 	}
 
+	PRINT_INFO(dev, GENERIC_DBG, "IRQ request succeeded IRQ-NUM= %d\n",
+		   wl->dev_irq_num);
+	enable_irq_wake(wl->dev_irq_num);
 	return ret;
+
+free_gpio:
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+	gpiod_put(wl->gpio_irq);
+	wl->gpio_irq = NULL;
+#else
+	gpio_free(wl->gpio_irq);
+	wl->gpio_irq = 0;
+#endif
+	return -1;
 }
 
 static void deinit_irq(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
 	/* Deinitialize IRQ */
-	if (wilc->dev_irq_num) {
+	if (wilc->dev_irq_num > 0) {
 		free_irq(wilc->dev_irq_num, wilc);
-		gpio_free(wilc->gpio);
+		wilc->dev_irq_num = -1;
 	}
+
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+	if (wilc->gpio_irq) {
+		gpiod_put(wilc->gpio_irq);
+		wilc->gpio_irq = NULL;
+	}
+#else
+	if (wilc->gpio_irq > 0) {
+		gpio_free(wilc->gpio_irq);
+		wilc->gpio_irq = 0;
+	}
+
+#endif
+
 }
 
-void wilc_mac_indicate(struct wilc *wilc, int flag)
+void wilc_mac_indicate(struct wilc *wilc)
 {
-	int status;
-
-	if (flag == WILC_MAC_INDICATE_STATUS) {
-		wilc_wlan_cfg_get_val(WID_STATUS,
-				      (unsigned char *)&status, 4);
-		if (wilc->mac_status == WILC_MAC_STATUS_INIT) {
-			wilc->mac_status = status;
-			complete(&wilc->sync_event);
-		} else {
-			wilc->mac_status = status;
-		}
+	s8 status;
+
+	cfg_get_val(wilc, WID_STATUS, &status, 1);
+	if (wilc->mac_status == MAC_STATUS_INIT) {
+		wilc->mac_status = status;
+		complete(&wilc->sync_event);
+	} else {
+		wilc->mac_status = status;
 	}
 }
 
-static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+void free_eap_buff_params(void *vp)
 {
-	u8 *bssid, *bssid1;
-	int i = 0;
+	struct wilc_priv *priv;
 
-	bssid = mac_header + 10;
-	bssid1 = mac_header + 4;
+	priv = (struct wilc_priv *)vp;
 
-	for (i = 0; i < wilc->vif_num; i++) {
-		if (wilc->vif[i]->mode == STATION_MODE)
-			if (ether_addr_equal_unaligned(bssid,
-						       wilc->vif[i]->bssid))
-				return wilc->vif[i]->ndev;
-		if (wilc->vif[i]->mode == AP_MODE)
-			if (ether_addr_equal_unaligned(bssid1,
-						       wilc->vif[i]->bssid))
-				return wilc->vif[i]->ndev;
+	if (priv->buffered_eap) {
+		kfree(priv->buffered_eap->buff);
+		priv->buffered_eap->buff = NULL;
+
+		kfree(priv->buffered_eap);
+		priv->buffered_eap = NULL;
 	}
+}
 
-	return NULL;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t)
+#else
+void eap_buff_timeout(unsigned long user)
+#endif
+{
+	u8 null_bssid[ETH_ALEN] = {0};
+	u8 *assoc_bss;
+	static u8 timeout = 5;
+	int status = -1;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_priv *priv = from_timer(priv, t, eap_buff_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)user;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	assoc_bss = priv->associated_bss;
+	if (!(memcmp(assoc_bss, null_bssid, ETH_ALEN)) && (timeout-- > 0)) {
+		mod_timer(&priv->eap_buff_timer,
+			  (jiffies + msecs_to_jiffies(10)));
+		return;
+	}
+	del_timer(&priv->eap_buff_timer);
+	timeout = 5;
+
+	status = wilc_send_buffered_eap(vif, wilc_frmw_to_linux,
+					free_eap_buff_params,
+					priv->buffered_eap->buff,
+					priv->buffered_eap->size,
+					priv->buffered_eap->pkt_offset,
+					(void *)priv);
+	if (status)
+		PRINT_ER(vif->ndev, "Failed so send buffered eap\n");
 }
 
-int wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
+void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
 {
 	struct wilc_vif *vif = netdev_priv(wilc_netdev);
+	struct wilc *wilc = vif->wilc;
+	u8 i = 0;
 
-	memcpy(vif->bssid, bssid, 6);
-	vif->mode = mode;
 
-	return 0;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "set bssid on[%p]\n", wilc_netdev);
+	for (i = 0; i <= wilc->vif_num; i++) {
+		if (wilc_netdev == wilc->vif[i]->ndev) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "set bssid [%x][%x][%x]\n", bssid[0],
+				   bssid[1], bssid[2]);
+			ether_addr_copy(wilc->vif[i]->bssid, bssid);
+			wilc->vif[i]->iftype = mode;
+		}
+	}
 }
 
 int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
@@ -274,386 +588,477 @@ int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
 	u8 null_bssid[6] = {0};
 	u8 ret_val = 0;
 
-	for (i = 0; i < wilc->vif_num; i++)
+	for (i = 0; i <= wilc->vif_num; i++)
 		if (memcmp(wilc->vif[i]->bssid, null_bssid, 6))
 			ret_val++;
 
 	return ret_val;
 }
 
+struct net_device *wilc_get_if_netdev(struct wilc *wilc, uint8_t ifc)
+{
+	return wilc->vif[ifc]->ndev;
+}
+
+struct host_if_drv *get_drv_hndl_by_ifc(struct wilc *wilc, uint8_t ifc)
+{
+	return wilc->vif[ifc]->hif_drv;
+}
+
+#define TX_BACKOFF_WEIGHT_INCR_STEP (1)
+#define TX_BACKOFF_WEIGHT_DECR_STEP (1)
+#define TX_BACKOFF_WEIGHT_MAX (0)
+#define TX_BACKOFF_WEIGHT_MIN (0)
+#define TX_BCKOFF_WGHT_MS (1)
+
+
 static int linux_wlan_txq_task(void *vp)
 {
 	int ret;
 	u32 txq_count;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-	struct net_device *dev = vp;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
+	struct net_device *ndev = vp;
+	int backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+	signed long timeout;
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wl = vif->wilc;
 
 	complete(&wl->txq_thread_started);
 	while (1) {
+		PRINT_INFO(ndev, TX_DBG, "txq_task Taking a nap\n");
 		wait_for_completion(&wl->txq_event);
-
+		PRINT_INFO(ndev, TX_DBG, "txq_task Who waked me up\n");
 		if (wl->close) {
 			complete(&wl->txq_thread_started);
 
 			while (!kthread_should_stop())
 				schedule();
+			PRINT_INFO(ndev, TX_DBG, "TX thread stopped\n");
 			break;
 		}
+		PRINT_INFO(ndev, TX_DBG, "handle the tx packet\n");
 		do {
-			ret = wilc_wlan_handle_txq(dev, &txq_count);
-			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
+			ret = wilc_wlan_handle_txq(ndev, &txq_count);
+			if (txq_count < FLOW_CTRL_LOW_THRESHLD) {
+				PRINT_INFO(ndev, TX_DBG, "Waking up queue\n");
 				if (netif_queue_stopped(wl->vif[0]->ndev))
 					netif_wake_queue(wl->vif[0]->ndev);
 				if (netif_queue_stopped(wl->vif[1]->ndev))
 					netif_wake_queue(wl->vif[1]->ndev);
 			}
+
+			if (ret == WILC_TX_ERR_NO_BUF) {
+				timeout = msecs_to_jiffies(TX_BCKOFF_WGHT_MS <<
+							   backoff_weight);
+				do {
+			/* Back off from sending packets for some time.
+			 * schedule_timeout will allow RX task to run and free
+			 * buffers. Setting state to TASK_INTERRUPTIBLE will
+			 * put the thread back to CPU running queue when it's
+			 * signaled even if 'timeout' isn't elapsed. This gives
+			 * faster chance for reserved SK buffers to be freed
+			 */
+					set_current_state(TASK_INTERRUPTIBLE);
+					timeout = schedule_timeout(timeout);
+					} while (/*timeout*/0);
+				backoff_weight += TX_BACKOFF_WEIGHT_INCR_STEP;
+				if (backoff_weight > TX_BACKOFF_WEIGHT_MAX)
+					backoff_weight = TX_BACKOFF_WEIGHT_MAX;
+			} else if (backoff_weight > TX_BACKOFF_WEIGHT_MIN) {
+				backoff_weight -= TX_BACKOFF_WEIGHT_DECR_STEP;
+				if (backoff_weight < TX_BACKOFF_WEIGHT_MIN)
+					backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+			}
 		} while (ret == WILC_TX_ERR_NO_BUF && !wl->close);
 	}
 	return 0;
 }
 
-int wilc_wlan_get_firmware(struct net_device *dev)
+static int wilc_wlan_get_firmware(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	int chip_id, ret = 0;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	int ret = 0;
 	const struct firmware *wilc_firmware;
 	char *firmware;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	chip_id = wilc_get_chipid(wilc, false);
 
-	if (chip_id < 0x1003a0)
-		firmware = FIRMWARE_1002;
-	else
-		firmware = FIRMWARE_1003;
+	if (wilc->chip == WILC_3000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC3000\n");
+		firmware = FW_WILC3000_WIFI;
+	} else if (wilc->chip == WILC_1000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC1000\n");
+		firmware = FW_WILC1000_WIFi;
+	} else {
+		return -1;
+	}
 
-	netdev_info(dev, "loading firmware %s\n", firmware);
+	PRINT_INFO(dev, INIT_DBG, "loading firmware %s\n", firmware);
 
-	if (!(&vif->ndev->dev))
-		goto _fail_;
+	if (!(&vif->ndev->dev)) {
+		PRINT_ER(dev, "Dev  is NULL\n");
+		goto fail;
+	}
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "WLAN firmware: %s\n", firmware);
 	if (request_firmware(&wilc_firmware, firmware, wilc->dev) != 0) {
-		netdev_err(dev, "%s - firmware not available\n", firmware);
+		PRINT_ER(dev, "%s - firmware not available\n", firmware);
 		ret = -1;
-		goto _fail_;
+		goto fail;
 	}
 	wilc->firmware = wilc_firmware;
 
-_fail_:
+fail:
 
 	return ret;
 }
 
 static int linux_wlan_start_firmware(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 	int ret = 0;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Starting Firmware ...\n");
 
 	ret = wilc_wlan_start(wilc);
-	if (ret < 0)
+	if (ret < 0) {
+		PRINT_ER(dev, "Failed to start Firmware\n");
 		return ret;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Waiting for FW to get ready ...\n");
 
 	if (!wait_for_completion_timeout(&wilc->sync_event,
-					 msecs_to_jiffies(5000)))
+					 msecs_to_jiffies(500))) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Firmware start timed out\n");
 		return -ETIME;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Firmware successfully started\n");
 
 	return 0;
 }
 
-static int wilc1000_firmware_download(struct net_device *dev)
+static int wilc_firmware_download(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 	int ret = 0;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
 	if (!wilc->firmware) {
-		netdev_err(dev, "Firmware buffer is NULL\n");
-		return -ENOBUFS;
+		PRINT_ER(dev, "Firmware buffer is NULL\n");
+		ret = -ENOBUFS;
 	}
-
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading Firmware ...\n");
 	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
 					  wilc->firmware->size);
 	if (ret < 0)
-		return ret;
+		goto fail;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Download Succeeded\n");
 
+fail:
 	release_firmware(wilc->firmware);
 	wilc->firmware = NULL;
 
-	netdev_dbg(dev, "Download Succeeded\n");
-
-	return 0;
+	return ret;
 }
 
 static int linux_wlan_init_test_config(struct net_device *dev,
 				       struct wilc_vif *vif)
 {
 	unsigned char c_val[64];
-	struct wilc *wilc = vif->wilc;
 	struct wilc_priv *priv;
 	struct host_if_drv *hif_drv;
 
-	netdev_dbg(dev, "Start configuring Firmware\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Start configuring Firmware\n");
 	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
 	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	netdev_dbg(dev, "Host = %p\n", hif_drv);
-	wilc_get_chipid(wilc, false);
+	PRINT_D(vif->ndev, INIT_DBG, "Host = %p\n", hif_drv);
 
-	*(int *)c_val = 1;
+	*(int *)c_val = (unsigned int)vif->iftype;
 
-	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_DRV_HANDLER, c_val, 4, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 1, WID_SET_OPERATION_MODE, c_val, 4, 0, 0))
+		goto fail;
 
 	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_PC_TEST_MODE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_PC_TEST_MODE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = INFRASTRUCTURE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BSS_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_BSS_TYPE, c_val, 1, 0, 0))
+		goto fail;
 
-	c_val[0] = RATE_AUTO;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_TX_RATE, c_val, 1, 0, 0))
-		goto _fail_;
+	c_val[0] = AUTORATE;
+	if (!cfg_set(vif, 0, WID_CURRENT_TX_RATE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = G_MIXED_11B_2_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_11G_OPERATING_MODE, c_val, 1, 0,
 			       0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_CHANNEL, c_val, 1, 0, 0))
-		goto _fail_;
+		goto fail;
 
-	c_val[0] = G_SHORT_PREAMBLE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, c_val, 1, 0, 0))
-		goto _fail_;
+	c_val[0] = G_AUTO_PREAMBLE;
+	if (!cfg_set(vif, 0, WID_PREAMBLE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = AUTO_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_PROT_MECH, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_11N_PROT_MECH, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = ACTIVE_SCAN;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SCAN_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_SCAN_TYPE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = SITE_SURVEY_OFF;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SITE_SURVEY, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_SITE_SURVEY, c_val, 1, 0, 0))
+		goto fail;
 
 	*((int *)c_val) = 0xffff;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_RTS_THRESHOLD, c_val, 2, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_RTS_THRESHOLD, c_val, 2, 0, 0))
+		goto fail;
 
 	*((int *)c_val) = 2346;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_FRAG_THRESHOLD, c_val, 2, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_FRAG_THRESHOLD, c_val, 2, 0, 0))
+		goto fail;
 
 	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BCAST_SSID, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_BCAST_SSID, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_QOS_ENABLE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_QOS_ENABLE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = NO_POWERSAVE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_POWER_MANAGEMENT, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_POWER_MANAGEMENT, c_val, 1, 0, 0))
+		goto fail;
 
-	c_val[0] = NO_SECURITY; /* NO_ENCRYPT, 0x79 */
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_MODE, c_val, 1, 0, 0))
-		goto _fail_;
+	c_val[0] = NO_ENCRYPT;
+	if (!cfg_set(vif, 0, WID_11I_MODE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = OPEN_SYSTEM;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_AUTH_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_AUTH_TYPE, c_val, 1, 0, 0))
+		goto fail;
 
 	strcpy(c_val, "123456790abcdef1234567890");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_WEP_KEY_VALUE, c_val,
+	if (!cfg_set(vif, 0, WID_WEP_KEY_VALUE, c_val,
 			       (strlen(c_val) + 1), 0, 0))
-		goto _fail_;
+		goto fail;
 
 	strcpy(c_val, "12345678");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_PSK, c_val, (strlen(c_val)), 0,
+	if (!cfg_set(vif, 0, WID_11I_PSK, c_val, (strlen(c_val)), 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	strcpy(c_val, "password");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_KEY, c_val, (strlen(c_val) + 1),
+	if (!cfg_set(vif, 0, WID_1X_KEY, c_val, (strlen(c_val) + 1),
 			       0, 0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 192;
 	c_val[1] = 168;
 	c_val[2] = 1;
 	c_val[3] = 112;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_SERV_ADDR, c_val, 4, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_1X_SERV_ADDR, c_val, 4, 0, 0))
+		goto fail;
 
 	c_val[0] = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_LISTEN_INTERVAL, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_LISTEN_INTERVAL, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_DTIM_PERIOD, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_DTIM_PERIOD, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = NORMAL_ACK;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_ACK_POLICY, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_ACK_POLICY, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, c_val, 1,
+	if (!cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, c_val, 1,
 			       0, 0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 48;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 28;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	*((int *)c_val) = 100;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BEACON_INTERVAL, c_val, 2, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_BEACON_INTERVAL, c_val, 2, 0, 0))
+		goto fail;
 
 	c_val[0] = REKEY_DISABLE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_POLICY, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_REKEY_POLICY, c_val, 1, 0, 0))
+		goto fail;
 
 	*((int *)c_val) = 84600;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PERIOD, c_val, 4, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_REKEY_PERIOD, c_val, 4, 0, 0))
+		goto fail;
 
 	*((int *)c_val) = 500;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, c_val, 4, 0,
+	if (!cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, c_val, 4, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = G_SELF_CTS_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ENABLE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_11N_ENABLE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = HT_MIXED_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OPERATING_MODE, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_11N_OPERATING_MODE, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = DETECT_PROTECT_REPORT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, c_val, 1,
+	if (!cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, c_val, 1,
 			       0, 0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = RTS_CTS_NONHT_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, c_val, 1, 0, 0))
+		goto fail;
 
 	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, c_val, 1, 0,
 			       0))
-		goto _fail_;
-
-	c_val[0] = MIMO_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_SMPS_MODE, c_val, 1, 0, 0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 7;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, c_val, 1, 0,
+	if (!cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, c_val, 1, 0,
 			       0))
-		goto _fail_;
+		goto fail;
 
 	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, c_val, 1,
-			       1, 1))
-		goto _fail_;
+	if (!cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, c_val, 1,
+			       1, 0))
+		goto fail;
 
 	return 0;
 
-_fail_:
+fail:
 	return -1;
 }
 
-void wilc1000_wlan_deinit(struct net_device *dev)
+static void wlan_deinit_locks(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wl;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
+	PRINT_INFO(vif->ndev, INIT_DBG, "De-Initializing Locks\n");
 
-	if (!wl) {
-		netdev_err(dev, "wl is NULL\n");
-		return;
+	mutex_destroy(&wilc->hif_cs);
+	mutex_destroy(&wilc->rxq_cs);
+	mutex_destroy(&wilc->txq_add_to_head_cs);
+	mutex_destroy(&wilc->cs);
+}
+
+static void wlan_deinitialize_threads(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+	if (!recovery_on) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
+		debug_running = false;
+		if (&wl->debug_thread_started)
+			complete(&wl->debug_thread_started);
+		if (wl->debug_thread) {
+			kthread_stop(wl->debug_thread);
+			wl->debug_thread = NULL;
+		}
 	}
 
-	if (wl->initialized)	{
-		netdev_info(dev, "Deinitializing wilc1000...\n");
+	wl->close = 1;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt) {
-			mutex_lock(&wl->hif_cs);
-			wl->hif_func->disable_interrupt(wl);
-			mutex_unlock(&wl->hif_cs);
+	complete(&wl->txq_event);
+
+	if (wl->txq_thread) {
+		kthread_stop(wl->txq_thread);
+		wl->txq_thread = NULL;
+	}
+}
+
+static void wilc_wlan_deinitialize(struct net_device *dev)
+{
+	int ret;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+
+	if (wl->initialized) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing wilc  ...\n");
+
+		if (!wl) {
+			PRINT_ER(dev, "wl is NULL\n");
+			return;
 		}
-		if (&wl->txq_event)
-			complete(&wl->txq_event);
 
+		PRINT_D(vif->ndev, INIT_DBG, "destroy aging timer\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Disabling IRQ\n");
+		if (wl->io_type == HIF_SPI ||
+			wl->io_type == HIF_SDIO_GPIO_IRQ) {
+			linux_wlan_disable_irq(wl, 1);
+		} else {
+			if (wl->hif_func->disable_interrupt) {
+				mutex_lock(&wl->hif_cs);
+				wl->hif_func->disable_interrupt(wl);
+				mutex_unlock(&wl->hif_cs);
+			}
+		}
+		complete(&wl->txq_event);
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 		wlan_deinitialize_threads(dev);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing IRQ\n");
 		deinit_irq(dev);
 
-		wilc_wlan_stop(wl);
+		ret = wilc_wlan_stop(wl);
+		if (ret == 0)
+			PRINT_ER(dev, "failed in wlan_stop\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing WILC Wlan\n");
 		wilc_wlan_cleanup(dev);
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Locks\n");
 		wlan_deinit_locks(dev);
 
 		wl->initialized = false;
 
-		netdev_dbg(dev, "wilc1000 deinitialization Done\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc deinitialization Done\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 is not initialized\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc is not initialized\n");
 	}
 }
 
-static int wlan_init_locks(struct net_device *dev)
+static void wlan_init_locks(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wl;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
 
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Locks ...\n");
 
-	mutex_init(&wl->hif_cs);
 	mutex_init(&wl->rxq_cs);
 
 	spin_lock_init(&wl->txq_spinlock);
@@ -664,158 +1069,141 @@ static int wlan_init_locks(struct net_device *dev)
 	init_completion(&wl->cfg_event);
 	init_completion(&wl->sync_event);
 	init_completion(&wl->txq_thread_started);
-
-	return 0;
-}
-
-static int wlan_deinit_locks(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	if (&wilc->hif_cs)
-		mutex_destroy(&wilc->hif_cs);
-
-	if (&wilc->rxq_cs)
-		mutex_destroy(&wilc->rxq_cs);
-
-	return 0;
+	init_completion(&wl->debug_thread_started);
 }
 
 static int wlan_initialize_threads(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Threads ...\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Creating kthread for transmission\n");
 	wilc->txq_thread = kthread_run(linux_wlan_txq_task, (void *)dev,
-				     "K_TXQ_TASK");
+				       "K_TXQ_TASK");
 	if (IS_ERR(wilc->txq_thread)) {
-		netdev_err(dev, "couldn't create TXQ thread\n");
-		wilc->close = 0;
+		PRINT_ER(dev, "couldn't create TXQ thread\n");
+		wilc->close = 1;
 		return PTR_ERR(wilc->txq_thread);
 	}
 	wait_for_completion(&wilc->txq_thread_started);
 
-	return 0;
-}
-
-static void wlan_deinitialize_threads(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	wl->close = 1;
-
-	if (&wl->txq_event)
-		complete(&wl->txq_event);
-
-	if (wl->txq_thread) {
-		kthread_stop(wl->txq_thread);
-		wl->txq_thread = NULL;
+	if (!debug_running) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Creating kthread for Debugging\n");
+		wilc->debug_thread = kthread_run(debug_thread, (void *)dev,
+						 "WILC_DEBUG");
+		if (IS_ERR(wilc->debug_thread)) {
+			PRINT_ER(dev, "couldn't create debug thread\n");
+			wilc->close = 1;
+			kthread_stop(wilc->txq_thread);
+			return PTR_ERR(wilc->debug_thread);
+		}
+		debug_running = true;
+		wait_for_completion(&wilc->debug_thread_started);
 	}
+
+	return 0;
 }
 
-int wilc1000_wlan_init(struct net_device *dev, struct wilc_vif *vif)
+static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
 {
 	int ret = 0;
 	struct wilc *wl = vif->wilc;
 
 	if (!wl->initialized) {
-		wl->mac_status = WILC_MAC_STATUS_INIT;
+		wl->mac_status = MAC_STATUS_INIT;
 		wl->close = 0;
+		wl->initialized = 0;
 
 		wlan_init_locks(dev);
 
 		ret = wilc_wlan_init(dev);
 		if (ret < 0) {
+			PRINT_ER(dev, "Initializing WILC_Wlan FAILED\n");
 			ret = -EIO;
-			goto _fail_locks_;
+			goto fail_locks;
 		}
-
-		if (wl->gpio >= 0 && init_irq(dev)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "WILC Initialization done\n");
+		if (init_irq(dev)) {
 			ret = -EIO;
-			goto _fail_locks_;
+			goto fail_locks;
 		}
 
 		ret = wlan_initialize_threads(dev);
 		if (ret < 0) {
+			PRINT_ER(dev, "Initializing Threads FAILED\n");
 			ret = -EIO;
-			goto _fail_wilc_wlan_;
+			goto fail_wilc_wlan;
 		}
 
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->enable_interrupt &&
+		if (wl->io_type == HIF_SDIO &&
 		    wl->hif_func->enable_interrupt(wl)) {
+			PRINT_ER(dev, "couldn't initialize IRQ\n");
 			ret = -EIO;
-			goto _fail_irq_init_;
+			goto fail_irq_init;
 		}
 
 		if (wilc_wlan_get_firmware(dev)) {
+			PRINT_ER(dev, "Can't get firmware\n");
 			ret = -EIO;
-			goto _fail_irq_enable_;
+			goto fail_irq_enable;
 		}
 
-		ret = wilc1000_firmware_download(dev);
+		ret = wilc_firmware_download(dev);
 		if (ret < 0) {
+			PRINT_ER(dev, "Failed to download firmware\n");
 			ret = -EIO;
-			goto _fail_irq_enable_;
+			goto fail_irq_enable;
 		}
 
 		ret = linux_wlan_start_firmware(dev);
 		if (ret < 0) {
+			PRINT_ER(dev, "Failed to start firmware\n");
 			ret = -EIO;
-			goto _fail_irq_enable_;
+			goto fail_irq_enable;
 		}
 
-		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
+		if (cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
 			int size;
-			char firmware_ver[20];
+			char firmware_ver[50];
 
-			size = wilc_wlan_cfg_get_val(WID_FIRMWARE_VERSION,
+			size = cfg_get_val(wl, WID_FIRMWARE_VERSION,
 						     firmware_ver,
 						     sizeof(firmware_ver));
 			firmware_ver[size] = '\0';
-			netdev_dbg(dev, "Firmware Ver = %s\n", firmware_ver);
+			PRINT_INFO(dev, INIT_DBG, "WILC Firmware Ver = %s\n",
+				   firmware_ver);
 		}
 		ret = linux_wlan_init_test_config(dev, vif);
 
 		if (ret < 0) {
-			netdev_err(dev, "Failed to configure firmware\n");
+			PRINT_ER(dev, "Failed to configure firmware\n");
 			ret = -EIO;
-			goto _fail_fw_start_;
+			goto fail_fw_start;
 		}
 
 		wl->initialized = true;
 		return 0;
 
-_fail_fw_start_:
+fail_fw_start:
 		wilc_wlan_stop(wl);
 
-_fail_irq_enable_:
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt)
+fail_irq_enable:
+		if (wl->io_type == HIF_SDIO)
 			wl->hif_func->disable_interrupt(wl);
-_fail_irq_init_:
-		if (wl->dev_irq_num)
-			deinit_irq(dev);
+fail_irq_init:
+		deinit_irq(dev);
 
 		wlan_deinitialize_threads(dev);
-_fail_wilc_wlan_:
+fail_wilc_wlan:
 		wilc_wlan_cleanup(dev);
-_fail_locks_:
+fail_locks:
 		wlan_deinit_locks(dev);
-		netdev_err(dev, "WLAN initialization FAILED\n");
+		PRINT_ER(dev, "WLAN initialization FAILED\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 already initialized\n");
+		PRINT_WRN(vif->ndev, INIT_DBG, "wilc already initialized\n");
 	}
 	return ret;
 }
@@ -830,53 +1218,63 @@ static int mac_init_fn(struct net_device *ndev)
 
 static int wilc_mac_open(struct net_device *ndev)
 {
-	struct wilc_vif *vif;
-
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wl = vif->wilc;
+	struct wilc_priv *priv = wdev_priv(vif->ndev->ieee80211_ptr);
 	unsigned char mac_add[ETH_ALEN] = {0};
 	int ret = 0;
-	int i = 0;
-	struct wilc *wl;
-
-	vif = netdev_priv(ndev);
-	wl = vif->wilc;
 
 	if (!wl || !wl->dev) {
-		netdev_err(ndev, "device not ready\n");
+		PRINT_ER(ndev, "device not ready\n");
 		return -ENODEV;
 	}
 
-	netdev_dbg(ndev, "MAC OPEN[%p]\n", ndev);
+	PRINT_INFO(ndev, INIT_DBG, "MAC OPEN[%p] %s\n", ndev, ndev->name);
 
-	ret = wilc_init_host_int(ndev);
-	if (ret < 0)
-		return ret;
+	if (wl->open_ifcs == 0)
+		wilc_bt_power_up(wl, DEV_WIFI);
+
+	if (!recovery_on) {
+		ret = wilc_init_host_int(ndev);
+		if (ret < 0) {
+			PRINT_ER(ndev, "Failed to initialize host interface\n");
+			return ret;
+		}
+	}
 
-	ret = wilc1000_wlan_init(ndev, vif);
+	PRINT_INFO(vif->ndev, INIT_DBG, "*** re-init ***\n");
+	ret = wilc_wlan_initialize(ndev, vif);
 	if (ret < 0) {
-		wilc_deinit_host_int(ndev);
+		PRINT_ER(ndev, "Failed to initialize wilc\n");
+		if (!recovery_on)
+			wilc_deinit_host_int(ndev);
 		return ret;
 	}
 
-	for (i = 0; i < wl->vif_num; i++) {
-		if (ndev == wl->vif[i]->ndev) {
-			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
-						 vif->iftype, vif->ifc_id);
-			wilc_set_operation_mode(vif, vif->iftype);
-			break;
-		}
+	wait_for_recovery = 0;
+	if (!(memcmp(ndev->name, IFC_0, 5))) {
+		vif->ifc_id = WLAN_IFC;
+	} else if (!(memcmp(ndev->name, IFC_1, 4))) {
+		vif->ifc_id = P2P_IFC;
+	} else {
+		PRINT_ER(vif->ndev, "Unknown interface name\n");
+		wilc_deinit_host_int(ndev);
+		wilc_wlan_deinitialize(ndev);
+		return -ENODEV;
 	}
-			wilc_get_mac_address(vif, mac_add);
-			netdev_dbg(ndev, "Mac address: %pM\n", mac_add);
-			memcpy(wl->vif[i]->src_addr, mac_add, ETH_ALEN);
-
-	memcpy(ndev->dev_addr, wl->vif[i]->src_addr, ETH_ALEN);
-
-	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		netdev_err(ndev, "Wrong MAC address\n");
+	wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+				 vif->iftype, vif->ifc_id, false);
+	wilc_set_operation_mode(vif, vif->iftype);
+	wilc_get_mac_address(vif, mac_add);
+	PRINT_INFO(vif->ndev, INIT_DBG, "Mac address: %pM\n", mac_add);
+
+	if (!is_valid_ether_addr(mac_add)) {
+		PRINT_ER(ndev, "Wrong MAC address\n");
 		wilc_deinit_host_int(ndev);
-		wilc1000_wlan_deinit(ndev);
+		wilc_wlan_deinitialize(ndev);
 		return -EINVAL;
 	}
+	ether_addr_copy(ndev->dev_addr, mac_add);
 
 	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
 				 vif->ndev->ieee80211_ptr,
@@ -888,6 +1286,7 @@ static int wilc_mac_open(struct net_device *ndev)
 				 vif->frame_reg[1].reg);
 	netif_wake_queue(ndev);
 	wl->open_ifcs++;
+	priv->p2p.local_random = 0x01;
 	vif->mac_opened = 1;
 	return 0;
 }
@@ -899,74 +1298,130 @@ static struct net_device_stats *mac_stats(struct net_device *dev)
 	return &vif->netstats;
 }
 
+static int wilc_set_mac_addr(struct net_device *dev, void *p)
+{
+	int result;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)p;
+	struct wilc *wilc = vif->wilc;
+	unsigned char mac_addr[6] = {0};
+	int i;
+
+	if (!is_valid_ether_addr(addr->sa_data)) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Invalid MAC address\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i <= wilc->vif_num; i++) {
+		wilc_get_mac_address(wilc->vif[i], mac_addr);
+		if (ether_addr_equal(addr->sa_data, mac_addr)) {
+			if (vif != wilc->vif[i]) {
+				PRINT_INFO(vif->ndev, INIT_DBG,
+					   "MAC address is alredy in use\n");
+				return -EINVAL;
+			} else {
+				return 0;
+			}
+		}
+	}
+
+	/* configure new MAC address */
+	result = wilc_set_mac_address(vif, (u8 *)addr->sa_data);
+	ether_addr_copy(vif->bssid, addr->sa_data);
+	ether_addr_copy(vif->ndev->dev_addr, vif->bssid);
+
+	return result;
+}
+
 static void wilc_set_multicast_list(struct net_device *dev)
 {
 	struct netdev_hw_addr *ha;
-	struct wilc_vif *vif;
+	struct wilc_vif *vif = netdev_priv(dev);
 	int i = 0;
-
-	vif = netdev_priv(dev);
-
-	if (dev->flags & IFF_PROMISC)
+	u8 *mc_list;
+	int res;
+
+	PRINT_INFO(vif->ndev, INIT_DBG,
+		   "Setting mcast List with count = %d.\n", dev->mc.count);
+	if (dev->flags & IFF_PROMISC) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Set promiscuous mode ON retrive all pkts\n");
 		return;
+	}
 
-	if ((dev->flags & IFF_ALLMULTI) ||
-	    (dev->mc.count) > WILC_MULTICAST_TABLE_SIZE) {
-		wilc_setup_multicast_filter(vif, false, 0);
+	if (dev->flags & IFF_ALLMULTI ||
+	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Disable mcast filter retrive multicast pkts\n");
+		wilc_setup_multicast_filter(vif, false, 0, NULL);
 		return;
 	}
 
-	if ((dev->mc.count) == 0) {
-		wilc_setup_multicast_filter(vif, true, 0);
+	if (dev->mc.count == 0) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Enable mcast filter retrive directed pkts only\n");
+		wilc_setup_multicast_filter(vif, true, 0, NULL);
 		return;
 	}
 
+	mc_list = kmalloc(dev->mc.count * ETH_ALEN, GFP_KERNEL);
+	if (!mc_list)
+		return;
+
 	netdev_for_each_mc_addr(ha, dev) {
-		memcpy(wilc_multicast_mac_addr_list[i], ha->addr, ETH_ALEN);
-		netdev_dbg(dev, "Entry[%d]: %x:%x:%x:%x:%x:%x\n", i,
-			   wilc_multicast_mac_addr_list[i][0],
-			   wilc_multicast_mac_addr_list[i][1],
-			   wilc_multicast_mac_addr_list[i][2],
-			   wilc_multicast_mac_addr_list[i][3],
-			   wilc_multicast_mac_addr_list[i][4],
-			   wilc_multicast_mac_addr_list[i][5]);
-		i++;
-	}
-
-	wilc_setup_multicast_filter(vif, true, (dev->mc.count));
+		memcpy(mc_list + i, ha->addr, ETH_ALEN);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Entry%d: %x:%x:%x:%x:%x:%x\n",
+			   i/ETH_ALEN,
+			   mc_list[i], mc_list[i + 1], mc_list[i + 2],
+			   mc_list[i + 3], mc_list[i + 4], mc_list[i + 5]);
+		i += ETH_ALEN;
+	}
+
+	res = wilc_setup_multicast_filter(vif, true, dev->mc.count, mc_list);
+	if (res)
+		kfree(mc_list);
+
 }
 
 static void linux_wlan_tx_complete(void *priv, int status)
 {
 	struct tx_complete_data *pv_data = priv;
 
+	if (status == 1)
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			  "Packet sentSize= %d Add= %p SKB= %p\n",
+			  pv_data->size, pv_data->buff, pv_data->skb);
+	else
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			   "Couldn't send pkt Size= %d Add= %p SKB= %p\n",
+			   pv_data->size, pv_data->buff, pv_data->skb);
 	dev_kfree_skb(pv_data->skb);
 	kfree(pv_data);
 }
 
-int wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
+netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
-	struct wilc_vif *vif;
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wilc = vif->wilc;
 	struct tx_complete_data *tx_data = NULL;
 	int queue_count;
 	char *udp_buf;
 	struct iphdr *ih;
 	struct ethhdr *eth_h;
-	struct wilc *wilc;
-
-	vif = netdev_priv(ndev);
-	wilc = vif->wilc;
 
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Sending packet just received from TCP/IP\n");
 	if (skb->dev != ndev) {
-		netdev_err(ndev, "Packet not destined to this device\n");
-		return 0;
+		PRINT_ER(ndev, "Packet not destined to this device\n");
+		return NETDEV_TX_OK;
 	}
 
 	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
 	if (!tx_data) {
+		PRINT_ER(ndev, "Failed to alloc memory for tx_data struct\n");
 		dev_kfree_skb(skb);
 		netif_wake_queue(ndev);
-		return 0;
+		return NETDEV_TX_OK;
 	}
 
 	tx_data->buff = skb->data;
@@ -974,77 +1429,91 @@ int wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
 	tx_data->skb  = skb;
 
 	eth_h = (struct ethhdr *)(skb->data);
-	if (eth_h->h_proto == cpu_to_be16(0x8e88))
-		netdev_dbg(ndev, "EAPOL transmitted\n");
+	if (eth_h->h_proto == (0x8e88))
+		PRINT_INFO(ndev, TX_DBG, " EAPOL transmitted\n");
 
 	ih = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
 
 	udp_buf = (char *)ih + sizeof(struct iphdr);
 	if ((udp_buf[1] == 68 && udp_buf[3] == 67) ||
 	    (udp_buf[1] == 67 && udp_buf[3] == 68))
-		netdev_dbg(ndev, "DHCP Message transmitted, type:%x %x %x\n",
+		PRINT_INFO(ndev, GENERIC_DBG,
+			   "DHCP Message transmitted, type:%x %x %x\n",
 			   udp_buf[248], udp_buf[249], udp_buf[250]);
 
+	PRINT_D(vif->ndev, TX_DBG, "Sending pkt Size= %d Add= %p SKB= %p\n",
+		tx_data->size, tx_data->buff, tx_data->skb);
+	PRINT_D(vif->ndev, TX_DBG, "Adding tx pkt to TX Queue\n");
 	vif->netstats.tx_packets++;
 	vif->netstats.tx_bytes += tx_data->size;
 	tx_data->bssid = wilc->vif[vif->idx]->bssid;
-	queue_count = wilc_wlan_txq_add_net_pkt(ndev, (void *)tx_data,
+	tx_data->vif = vif;
+	queue_count = txq_add_net_pkt(ndev, (void *)tx_data,
 						tx_data->buff, tx_data->size,
 						linux_wlan_tx_complete);
 
-	if (queue_count > FLOW_CONTROL_UPPER_THRESHOLD) {
+	if (queue_count > FLOW_CTRL_UP_THRESHLD) {
 		netif_stop_queue(wilc->vif[0]->ndev);
 		netif_stop_queue(wilc->vif[1]->ndev);
 	}
 
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 static int wilc_mac_close(struct net_device *ndev)
 {
 	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	struct wilc_vif *vif = netdev_priv(ndev);
 	struct host_if_drv *hif_drv;
 	struct wilc *wl;
 
-	vif = netdev_priv(ndev);
-
 	if (!vif || !vif->ndev || !vif->ndev->ieee80211_ptr ||
-	    !vif->ndev->ieee80211_ptr->wiphy)
+	    !vif->ndev->ieee80211_ptr->wiphy) {
+		PRINT_ER(ndev, "vif = NULL\n");
 		return 0;
+	}
 
 	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
 	wl = vif->wilc;
 
-	if (!priv)
+	if (!priv) {
+		PRINT_ER(ndev, "priv = NULL\n");
 		return 0;
+	}
 
 	hif_drv = (struct host_if_drv *)priv->hif_drv;
 
-	netdev_dbg(ndev, "Mac close\n");
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Mac close\n");
 
-	if (!wl)
+	if (!wl) {
+		PRINT_ER(ndev, "wilc = NULL\n");
 		return 0;
+	}
 
-	if (!hif_drv)
+	if (!hif_drv) {
+		PRINT_ER(ndev, "hif driver is NULL\n");
 		return 0;
+	}
 
-	if ((wl->open_ifcs) > 0)
+	if (wl->open_ifcs > 0) {
 		wl->open_ifcs--;
-	else
+	} else {
+		PRINT_ER(ndev, "MAC close called with no opened interfaces\n");
 		return 0;
+	}
 
 	if (vif->ndev) {
 		netif_stop_queue(vif->ndev);
 
+	if (!recovery_on)
 		wilc_deinit_host_int(vif->ndev);
 	}
 
 	if (wl->open_ifcs == 0) {
-		netdev_dbg(ndev, "Deinitializing wilc1000\n");
+		PRINT_INFO(ndev, GENERIC_DBG, "Deinitializing wilc\n");
 		wl->close = 1;
-		wilc1000_wlan_deinit(ndev);
-		WILC_WFI_deinit_mon_interface();
+		wilc_wlan_deinitialize(ndev);
+		wilc_wfi_deinit_mon_interface();
 	}
 
 	vif->mac_opened = 0;
@@ -1052,116 +1521,93 @@ static int wilc_mac_close(struct net_device *ndev)
 	return 0;
 }
 
-static int mac_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
-{
-	u8 *buff = NULL;
-	s8 rssi;
-	u32 size = 0;
-	struct wilc_vif *vif;
-	s32 ret = 0;
-	struct wilc *wilc;
-
-	vif = netdev_priv(ndev);
-	wilc = vif->wilc;
-
-	if (!wilc->initialized)
-		return 0;
-
-	switch (cmd) {
-	case SIOCSIWPRIV:
-	{
-		struct iwreq *wrq = (struct iwreq *)req;
-
-		size = wrq->u.data.length;
-
-		if (size && wrq->u.data.pointer) {
-			buff = memdup_user(wrq->u.data.pointer,
-					   wrq->u.data.length);
-			if (IS_ERR(buff))
-				return PTR_ERR(buff);
-
-			if (strncasecmp(buff, "RSSI", size) == 0) {
-				ret = wilc_get_rssi(vif, &rssi);
-				netdev_info(ndev, "RSSI :%d\n", rssi);
-
-				rssi += 5;
-
-				snprintf(buff, size, "rssi %d", rssi);
-
-				if (copy_to_user(wrq->u.data.pointer, buff, size)) {
-					netdev_err(ndev, "failed to copy\n");
-					ret = -EFAULT;
-					goto done;
-				}
-			}
-		}
-	}
-	break;
-
-	default:
-	{
-		netdev_info(ndev, "Command - %d - has been received\n", cmd);
-		ret = -EOPNOTSUPP;
-		goto done;
-	}
-	}
-
-done:
-
-	kfree(buff);
-
-	return ret;
-}
-
-void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset)
+void wilc_frmw_to_linux(struct wilc_vif *vif, u8 *buff, u32 size,
+			u32 pkt_offset, u8 status)
 {
 	unsigned int frame_len = 0;
 	int stats;
 	unsigned char *buff_to_send = NULL;
 	struct sk_buff *skb;
-	struct net_device *wilc_netdev;
-	struct wilc_vif *vif;
-
-	if (!wilc)
-		return;
-
-	wilc_netdev = get_if_handler(wilc, buff);
-	if (!wilc_netdev)
-		return;
+	struct wilc_priv *priv;
+	u8 null_bssid[ETH_ALEN] = {0};
 
 	buff += pkt_offset;
-	vif = netdev_priv(wilc_netdev);
-
-	if (size > 0) {
-		frame_len = size;
-		buff_to_send = buff;
-
-		skb = dev_alloc_skb(frame_len);
-		if (!skb)
-			return;
-
-		skb->dev = wilc_netdev;
+	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
 
-		skb_put_data(skb, buff_to_send, frame_len);
+	if (size == 0) {
+		PRINT_ER(vif->ndev,
+			 "Discard sending packet with len = %d\n", size);
+		return;
+	}
 
-		skb->protocol = eth_type_trans(skb, wilc_netdev);
-		vif->netstats.rx_packets++;
-		vif->netstats.rx_bytes += frame_len;
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		stats = netif_rx(skb);
-		netdev_dbg(wilc_netdev, "netif_rx ret value is: %d\n", stats);
+	frame_len = size;
+	buff_to_send = buff;
+
+	if (status == PKT_STATUS_NEW && buff_to_send[12] == 0x88 &&
+	   buff_to_send[13] == 0x8e &&
+	   (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) &&
+	   !memcmp(priv->associated_bss, null_bssid, ETH_ALEN)) {
+		if (!priv->buffered_eap) {
+			priv->buffered_eap = kmalloc(sizeof(struct
+							    wilc_buffered_eap),
+						     GFP_ATOMIC);
+			if (priv->buffered_eap) {
+				priv->buffered_eap->buff = NULL;
+				priv->buffered_eap->size = 0;
+				priv->buffered_eap->pkt_offset = 0;
+			} else {
+				PRINT_ER(vif->ndev,
+					 "failed to alloc buffered_eap\n");
+				return;
+			}
+		} else {
+			kfree(priv->buffered_eap->buff);
+		}
+		priv->buffered_eap->buff = kmalloc(size + pkt_offset,
+						   GFP_ATOMIC);
+		priv->buffered_eap->size = size;
+		priv->buffered_eap->pkt_offset = pkt_offset;
+		memcpy(priv->buffered_eap->buff, buff -
+		       pkt_offset, size + pkt_offset);
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		priv->eap_buff_timer.data = (unsigned long) priv;
+	#endif
+		mod_timer(&priv->eap_buff_timer, (jiffies +
+			  msecs_to_jiffies(10)));
+		return;
 	}
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		PRINT_ER(vif->ndev, "Low memory - packet droped\n");
+		return;
+	}
+
+	skb->dev = vif->ndev;
+	if (skb->dev == NULL)
+		PRINT_ER(vif->ndev, "skb->dev is NULL\n");
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff_to_send, frame_len);
+#else
+	memcpy(skb_put(skb, frame_len), buff_to_send, frame_len);
+#endif
+
+	skb->protocol = eth_type_trans(skb, vif->ndev);
+	vif->netstats.rx_packets++;
+	vif->netstats.rx_bytes += frame_len;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	stats = netif_rx(skb);
+	PRINT_D(vif->ndev, RX_DBG, "netif_rx ret value: %d\n", stats);
 }
 
-void WILC_WFI_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
 {
 	int i = 0;
 	struct wilc_vif *vif;
 
-	for (i = 0; i < wilc->vif_num; i++) {
+	for (i = 0; i <= wilc->vif_num; i++) {
 		vif = netdev_priv(wilc->vif[i]->ndev);
 		if (vif->monitor_flag) {
-			WILC_WFI_monitor_rx(buff, size);
+			wilc_wfi_monitor_rx(vif, buff, size);
 			return;
 		}
 	}
@@ -1169,112 +1615,278 @@ void WILC_WFI_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
 	vif = netdev_priv(wilc->vif[1]->ndev);
 	if ((buff[0] == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
 	    (buff[0] == vif->frame_reg[1].type && vif->frame_reg[1].reg))
-		WILC_WFI_p2p_rx(wilc->vif[1]->ndev, buff, size);
+		wilc_wfi_p2p_rx(wilc->vif[1]->ndev, buff, size);
 }
 
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+static struct notifier_block g_dev_notifier = {
+	.notifier_call = dev_state_ev_handler
+};
+#endif
+
 void wilc_netdev_cleanup(struct wilc *wilc)
 {
 	int i;
 
-	if (wilc && (wilc->vif[0]->ndev || wilc->vif[1]->ndev))
-		unregister_inetaddr_notifier(&g_dev_notifier);
+	if (!wilc)
+		return;
 
-	if (wilc && wilc->firmware) {
+	if (wilc->firmware) {
 		release_firmware(wilc->firmware);
 		wilc->firmware = NULL;
 	}
 
-	if (wilc && (wilc->vif[0]->ndev || wilc->vif[1]->ndev)) {
-		for (i = 0; i < NUM_CONCURRENT_IFC; i++)
-			if (wilc->vif[i]->ndev)
-				if (wilc->vif[i]->mac_opened)
-					wilc_mac_close(wilc->vif[i]->ndev);
-
-		for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
+	for (i = 0; i < NUM_CONCURRENT_IFC; i++)
+		if (wilc->vif[i] && wilc->vif[i]->ndev) {
+			PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+				   "Unregistering netdev %p\n",
+				   wilc->vif[i]->ndev);
 			unregister_netdev(wilc->vif[i]->ndev);
+			PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+				   "Freeing Wiphy...\n");
 			wilc_free_wiphy(wilc->vif[i]->ndev);
+			PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+				   "Freeing netdev...\n");
 			free_netdev(wilc->vif[i]->ndev);
 		}
-	}
 
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		unregister_inetaddr_notifier(&g_dev_notifier);
+	#endif
+
+	flush_workqueue(wilc->hif_workqueue);
+	destroy_workqueue(wilc->hif_workqueue);
+	wilc->hif_workqueue = NULL;
+	cfg_deinit(wilc);
+	kfree(wilc->bus_data);
 	kfree(wilc);
+	wilc_debugfs_remove();
+	wilc_sysfs_exit();
+	pr_info("Module_exit Done.\n");
 }
-EXPORT_SYMBOL_GPL(wilc_netdev_cleanup);
+
+static const struct net_device_ops wilc_netdev_ops = {
+	.ndo_init = mac_init_fn,
+	.ndo_open = wilc_mac_open,
+	.ndo_stop = wilc_mac_close,
+	.ndo_set_mac_address = wilc_set_mac_addr,
+	.ndo_start_xmit = wilc_mac_xmit,
+	.ndo_get_stats = mac_stats,
+	.ndo_set_rx_mode  = wilc_set_multicast_list,
+};
 
 int wilc_netdev_init(struct wilc **wilc, struct device *dev, int io_type,
-		     int gpio, const struct wilc_hif_func *ops)
+		     const struct wilc_hif_func *ops)
 {
 	int i, ret;
 	struct wilc_vif *vif;
 	struct net_device *ndev;
 	struct wilc *wl;
+	struct wireless_dev *wdev;
 
 	wl = kzalloc(sizeof(*wl), GFP_KERNEL);
 	if (!wl)
 		return -ENOMEM;
 
+	ret = cfg_init(wl);
+	if (ret)
+		goto free_wl;
+
+	wilc_debugfs_init();
 	*wilc = wl;
 	wl->io_type = io_type;
-	wl->gpio = gpio;
 	wl->hif_func = ops;
+	for (i = 0; i < NQUEUES; i++)
+		INIT_LIST_HEAD(&wl->txq[i].txq_head.list);
+
+	INIT_LIST_HEAD(&wl->rxq_head.list);
+
+	wl->hif_workqueue = create_singlethread_workqueue("WILC_wq");
+	if (!wl->hif_workqueue) {
+		ret = -ENOMEM;
+		goto free_cfg;
+	}
 
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
 	register_inetaddr_notifier(&g_dev_notifier);
+#endif
 
 	for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
 		ndev = alloc_etherdev(sizeof(struct wilc_vif));
-		if (!ndev)
-			return -ENOMEM;
+		if (!ndev) {
+			ret = -ENOMEM;
+			goto free_ndev;
+		}
 
 		vif = netdev_priv(ndev);
 		memset(vif, 0, sizeof(struct wilc_vif));
 
-		if (i == 0) {
+		if (i == 0)
 			strcpy(ndev->name, "wlan%d");
-			vif->ifc_id = 1;
-		} else {
+		else
 			strcpy(ndev->name, "p2p%d");
-			vif->ifc_id = 0;
-		}
+
+		wl->vif_num = i;
+		vif->idx = wl->vif_num;
 		vif->wilc = *wilc;
 		vif->ndev = ndev;
 		wl->vif[i] = vif;
-		wl->vif_num = i;
-		vif->idx = wl->vif_num;
-
-		ndev->netdev_ops = &wilc_netdev_ops;
 
-		{
-			struct wireless_dev *wdev;
 
-			wdev = wilc_create_wiphy(ndev, dev);
+		ndev->netdev_ops = &wilc_netdev_ops;
 
-			if (dev)
-				SET_NETDEV_DEV(ndev, dev);
+		wdev = wilc_create_wiphy(ndev, dev);
+		if (!wdev) {
+			PRINT_ER(ndev, "Can't register WILC Wiphy\n");
+			ret = -ENOMEM;
+			goto free_ndev;
+		}
 
-			if (!wdev) {
-				netdev_err(ndev, "Can't register WILC Wiphy\n");
-				return -1;
-			}
+		SET_NETDEV_DEV(ndev, dev);
 
-			vif->ndev->ieee80211_ptr = wdev;
-			vif->ndev->ml_priv = vif;
-			wdev->netdev = vif->ndev;
-			vif->netstats.rx_packets = 0;
-			vif->netstats.tx_packets = 0;
-			vif->netstats.rx_bytes = 0;
-			vif->netstats.tx_bytes = 0;
-		}
+		vif->ndev->ieee80211_ptr = wdev;
+		vif->ndev->ml_priv = vif;
+		wdev->netdev = vif->ndev;
+		vif->netstats.rx_packets = 0;
+		vif->netstats.tx_packets = 0;
+		vif->netstats.rx_bytes = 0;
+		vif->netstats.tx_bytes = 0;
 
 		ret = register_netdev(ndev);
-		if (ret)
-			return ret;
+		if (ret) {
+			PRINT_ER(ndev, "Device couldn't be registered - %s\n",
+			       ndev->name);
+			goto free_ndev;
+		}
 
 		vif->iftype = STATION_MODE;
 		vif->mac_opened = 0;
 	}
+	wilc_sysfs_init(wl->vif[0], wl->vif[1]);
 
 	return 0;
+free_ndev:
+	for (; i >= 0; i--) {
+		if (wl->vif[i]) {
+			if (wl->vif[i]->iftype == STATION_MODE)
+				unregister_netdev(wl->vif[i]->ndev);
+
+			if (wl->vif[i]->ndev) {
+				wilc_free_wiphy(wl->vif[i]->ndev);
+				free_netdev(wl->vif[i]->ndev);
+			}
+		}
+	}
+	unregister_inetaddr_notifier(&g_dev_notifier);
+	destroy_workqueue(wl->hif_workqueue);
+free_cfg:
+	cfg_deinit(wl);
+free_wl:
+	kfree(wl);
+	return ret;
+}
+
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+static void wilc_wlan_power(struct wilc *wilc, int power)
+{
+	struct gpio_desc *gpio_reset;
+	struct gpio_desc *gpio_chip_en;
+
+	pr_info("wifi_pm : %d\n", power);
+
+	gpio_reset = gpiod_get(wilc->dt_dev, "reset", GPIOD_ASIS);
+	if (IS_ERR(gpio_reset)) {
+		dev_warn(wilc->dev, "failed to get Reset GPIO, try default\r\n");
+		gpio_reset = gpio_to_desc(GPIO_NUM_RESET);
+		if (!gpio_reset) {
+			dev_warn(wilc->dev,
+				 "failed to get default Reset GPIO\r\n");
+			return;
+		}
+	} else {
+		dev_info(wilc->dev, "succesfully got gpio_reset\r\n");
+	}
+
+	gpio_chip_en = gpiod_get(wilc->dt_dev, "chip_en", GPIOD_ASIS);
+	if (IS_ERR(gpio_chip_en)) {
+		gpio_chip_en = gpio_to_desc(GPIO_NUM_CHIP_EN);
+		if (!gpio_chip_en) {
+			dev_warn(wilc->dev,
+				 "failed to get default chip_en GPIO\r\n");
+			gpiod_put(gpio_reset);
+			return;
+		}
+	} else {
+		dev_info(wilc->dev, "succesfully got gpio_chip_en\r\n");
+	}
+
+	if (power) {
+		gpiod_direction_output(gpio_chip_en, 1);
+		mdelay(5);
+		gpiod_direction_output(gpio_reset, 1);
+	} else {
+		gpiod_direction_output(gpio_reset, 0);
+		gpiod_direction_output(gpio_chip_en, 0);
+	}
+	gpiod_put(gpio_chip_en);
+	gpiod_put(gpio_reset);
+}
+#else
+static void wilc_wlan_power(struct wilc *wilc, int power)
+{
+	int gpio_reset;
+	int gpio_chip_en;
+	struct device_node *of_node = wilc->dt_dev->of_node;
+
+	pr_info("wifi_pm : %d\n", power);
+
+	gpio_reset = of_get_named_gpio_flags(of_node, "reset-gpios", 0, NULL);
+
+	if (gpio_reset < 0) {
+		gpio_reset = GPIO_NUM_RESET;
+		pr_info("wifi_pm : load default reset GPIO %d\n", gpio_reset);
+	}
+
+	gpio_chip_en = of_get_named_gpio_flags(of_node, "chip_en-gpios", 0,
+					       NULL);
+
+	if (gpio_chip_en < 0) {
+		gpio_chip_en = GPIO_NUM_CHIP_EN;
+		pr_info("wifi_pm : load default chip_en GPIO %d\n",
+			gpio_chip_en);
+	}
+
+	if (gpio_request(gpio_chip_en, "CHIP_EN") == 0 &&
+	    gpio_request(gpio_reset, "RESET") == 0) {
+		gpio_direction_output(gpio_chip_en, 0);
+		gpio_direction_output(gpio_reset, 0);
+		if (power) {
+			gpio_set_value(gpio_chip_en, 1);
+			mdelay(5);
+			gpio_set_value(gpio_reset, 1);
+		} else {
+			gpio_set_value(gpio_reset, 0);
+			gpio_set_value(gpio_chip_en, 0);
+		}
+		gpio_free(gpio_chip_en);
+		gpio_free(gpio_reset);
+	} else {
+		dev_err(wilc->dev,
+			"Error requesting GPIOs for CHIP_EN and RESET");
+	}
+
+}
+#endif
+
+void wilc_wlan_power_on_sequence(struct wilc *wilc)
+{
+	wilc_wlan_power(wilc, 0);
+	wilc_wlan_power(wilc, 1);
+}
+
+void wilc_wlan_power_off_sequence(struct wilc *wilc)
+{
+	wilc_wlan_power(wilc, 0);
 }
-EXPORT_SYMBOL_GPL(wilc_netdev_init);
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/staging/wilc1000/linux_wlan.h b/drivers/staging/wilc1000/linux_wlan.h
new file mode 100644
index 000000000000..58fe6c2ad5d2
--- /dev/null
+++ b/drivers/staging/wilc1000/linux_wlan.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_LINUX_WLAN_H
+#define WILC_LINUX_WLAN_H
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#include "wilc_wfi_netdevice.h"
+#include "wilc_wlan_if.h"
+
+#define IP_STATE_OBTAINING		1
+#define IP_STATE_OBTAINED		2
+#define IP_STATE_GO_ASSIGNING		3
+#define IP_STATE_DEFAULT		4
+
+extern int wait_for_recovery;
+
+void handle_pwrsave_for_IP(struct wilc_vif *vif, uint8_t state);
+void store_power_save_current_state(struct wilc_vif *vif, bool val);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void clear_during_ip(struct timer_list *t);
+#else
+void clear_during_ip(unsigned long arg);
+#endif
+
+struct net_device *wilc_get_if_netdev(struct wilc *wilc, uint8_t ifc);
+struct host_if_drv *get_drv_hndl_by_ifc(struct wilc *wilc, uint8_t ifc);
+
+#if KERNEL_VERSION(3, 14, 0) > LINUX_VERSION_CODE
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+static inline bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	return ether_addr_equal(addr1, addr2);
+#else
+	return memcmp(addr1, addr2, ETH_ALEN) == 0;
+#endif
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0) */
+
+int wilc_bt_power_up(struct wilc *wilc, int source);
+int wilc_bt_power_down(struct wilc *wilc, int source);
+void wilc_wfi_monitor_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+
+#endif /* WILC_LINUX_WLAN_H */
diff --git a/drivers/staging/wilc1000/microchip,wilc,sdio.txt b/drivers/staging/wilc1000/microchip,wilc,sdio.txt
new file mode 100644
index 000000000000..028c64017c9b
--- /dev/null
+++ b/drivers/staging/wilc1000/microchip,wilc,sdio.txt
@@ -0,0 +1,36 @@
+* Microchip WILC wireless SDIO device
+
+The wilc1000 chips can be connected via SDIO. The node is used to specifiy
+child node to the SDIO controller that connects the device to the system.
+
+Required properties:
+- compatible	:	Should be "microchip,wilc1000-sdio"
+- irq-gpios	:	Connect to a host IRQ
+- reset-gpios	:	Reset module GPIO
+- chip_en-gpios	:	Chip enable GPIO
+- reg		:	Slot ID used in the controller
+
+Optional:
+- bus-width	:	Number of data lines wired up the slot. Default 1 bit.
+
+
+Examples:
+mmc1: mmc@fc000000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mmc1_clk_cmd_dat0 &pinctrl_mmc1_dat1_3>;
+		non-removable;
+		vmmc-supply = <&vcc_mmc1_reg>;
+		vqmmc-supply = <&vcc_3v3_reg>;
+		status = "okay";
+
+		wilc_sdio@0 {
+			compatible = "microchip,wilc1000", "microchip,wilc3000";
+			irq-gpios = <&pioC 27 0>;
+			reset-gpios = <&pioB 28 0>;
+			chip_en-gpios = <&pioC 30 0>;
+			status = "okay";
+			reg = <0>;
+			bus-width = <4>;
+		}
+	};
+}
diff --git a/drivers/staging/wilc1000/microchip,wilc,spi.txt b/drivers/staging/wilc1000/microchip,wilc,spi.txt
new file mode 100644
index 000000000000..2e2a9306c1e8
--- /dev/null
+++ b/drivers/staging/wilc1000/microchip,wilc,spi.txt
@@ -0,0 +1,30 @@
+* Microchip WILC wireless SPI device
+
+The wilc1000 chips can be connected via SPI. This document describes
+the binding for the SPI connected module.
+
+Required properties:
+- compatible		: Should be "microchip,wilc1000-spi"
+- spi-max-frequency	: Maximum SPI clocking speed of device in Hz
+- reg			: Chip select address of device
+- irq-gpios		: Connect to a host IRQ
+- reset-gpios		: Reset module GPIO
+- chip_en-gpios:    	: Chip enable GPIO
+
+
+Examples:
+
+spi1: spi@fc018000 {
+		cs-gpios = <&pioB 21 0>;
+		status = "okay";
+
+		wilc_spi@0 {
+			compatible = "microchip,wilc1000", "microchip,wilc3000";
+			spi-max-frequency = <48000000>;
+			reg = <0>;
+			irq-gpios = <&pioC 27 0>;
+			reset-gpios = <&pioB 28 0>;
+			chip_en-gpios = <&pioC 30 0>;
+			status = "okay";
+		};
+};
diff --git a/drivers/staging/wilc1000/sysfs.c b/drivers/staging/wilc1000/sysfs.c
new file mode 100644
index 000000000000..771e5727d8b5
--- /dev/null
+++ b/drivers/staging/wilc1000/sysfs.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/kobject.h>
+#include "wilc_wfi_cfgoperations.h"
+
+static struct kobject *wilc_kobj;
+static int device_created;
+static struct wilc_vif *vif[NUM_CONCURRENT_IFC];
+
+static ssize_t wilc_sysfs_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	int attr_val = -1;
+
+	if (strcmp(attr->attr.name, "p2p_mode") == 0)
+		attr_val = vif[0]->attr_sysfs.p2p_mode;
+	if (strcmp(attr->attr.name, "ant_swtch_mode") == 0)
+		attr_val = vif[0]->attr_sysfs.ant_swtch_mode;
+	else if (strcmp(attr->attr.name, "antenna1") == 0)
+		attr_val = vif[0]->attr_sysfs.antenna1;
+	else if (strcmp(attr->attr.name, "antenna2") == 0)
+		attr_val = vif[0]->attr_sysfs.antenna2;
+
+	return sprintf(buf, "%d\n", attr_val);
+}
+
+static ssize_t wilc_sysfs_store(struct kobject *kobj,
+				struct kobj_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_val;
+	int i;
+
+	for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
+		if (kstrtoint(buf, 10, &attr_val))
+			PRINT_ER(vif[i]->ndev,
+				 "Failed to convert p2p_mode string");
+		if (strcmp(attr->attr.name, "p2p_mode") == 0) {
+			vif[i]->attr_sysfs.p2p_mode = (attr_val?1:0);
+		} else if (strcmp(attr->attr.name, "ant_swtch_mode") == 0) {
+			if (attr_val > ANT_SWTCH_DUAL_GPIO_CTRL)
+				PRINT_ER(vif[i]->ndev,
+					 "Valid antenna switch modes:\n1-Single Antenna, 2-Dual Antenna\n");
+			else
+				vif[i]->attr_sysfs.ant_swtch_mode = attr_val;
+		} else if (strcmp(attr->attr.name, "antenna1") == 0) {
+			vif[i]->attr_sysfs.antenna1 = attr_val;
+		} else if (strcmp(attr->attr.name, "antenna2") == 0) {
+			vif[i]->attr_sysfs.antenna2 = attr_val;
+		}
+	}
+
+	return count;
+}
+
+static struct kobj_attribute p2p_mode_attr =
+	__ATTR(p2p_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_mode_attr =
+	__ATTR(ant_swtch_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna1_attr =
+	__ATTR(antenna1, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna2_attr =
+	__ATTR(antenna2, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+
+static struct attribute *wilc_attrs[] = {
+	&p2p_mode_attr.attr,
+	&ant_swtch_mode_attr.attr,
+	&ant_swtch_antenna1_attr.attr,
+	&ant_swtch_antenna2_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+	.attrs = wilc_attrs,
+};
+
+void wilc_sysfs_init(struct wilc_vif *vif1, struct wilc_vif *vif2)
+{
+	int retval;
+	int i;
+
+	vif[0] = vif1;
+	vif[1] = vif2;
+
+	if (device_created)
+		return;
+
+	wilc_kobj = kobject_create_and_add("wilc", NULL);
+	if (!wilc_kobj) {
+		retval = -ENOMEM;
+		return;
+	}
+
+	for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
+		/* By default p2p mode is Group Owner */
+		vif[i]->attr_sysfs.p2p_mode = 1;
+		vif[i]->attr_sysfs.ant_swtch_mode = ANT_SWTCH_INVALID_GPIO_CTRL;
+		vif[i]->attr_sysfs.antenna1 = 0xFF;
+		vif[i]->attr_sysfs.antenna2 = 0xFF;
+	}
+	retval = sysfs_create_group(wilc_kobj, &attr_group);
+	device_created = 1;
+}
+
+void wilc_sysfs_exit(void)
+{
+	device_created = 0;
+	sysfs_remove_group(wilc_kobj, &attr_group);
+	kobject_put(wilc_kobj);
+}
+
diff --git a/drivers/staging/wilc1000/wilc_bt.c b/drivers/staging/wilc1000/wilc_bt.c
new file mode 100644
index 000000000000..bf3957ee0dc8
--- /dev/null
+++ b/drivers/staging/wilc1000/wilc_bt.c
@@ -0,0 +1,691 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/firmware.h>
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#include "wilc_wfi_netdevice.h"
+
+static struct wilc *wilc_bt;
+static dev_t chc_dev_no; /* Global variable for the first device number */
+static struct cdev str_chc_dev; /* Global variable for the character */
+struct device *dev;
+static struct class *chc_dev_class; /* Global variable for the device class */
+static bool device_created;
+int bt_init_done;
+
+typedef void (wilc_cmd_handler)(char *);
+
+static void handle_cmd_bt_enable(char *param);
+static void handle_cmd_pwr_up(char *param);
+static void handle_cmd_pwr_down(char *param);
+static void handle_cmd_chip_wake_up(char *param);
+static void handle_cmd_chip_allow_sleep(char *param);
+static void handle_cmd_download_fw(char *param);
+static void handle_cmd_cca_thrshld(char *param);
+
+static void wilc_bt_firmware_download(struct wilc *);
+static void wilc_bt_start(struct wilc *);
+static int wilc_bt_dev_open(struct inode *i, struct file *f);
+static int wilc_bt_dev_close(struct inode *i, struct file *f);
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off);
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off);
+
+static const struct file_operations pugs_fops = {
+	.owner = THIS_MODULE,
+	.open = wilc_bt_dev_open,
+	.release = wilc_bt_dev_close,
+	.read = wilc_bt_dev_read,
+	.write = wilc_bt_dev_write
+};
+
+struct cmd_entry {
+	const char *str;
+	wilc_cmd_handler *wilc_handle_cmd;
+};
+
+static const struct cmd_entry cmd_table[] = {
+	{"BT_DOWNLOAD_FW", handle_cmd_download_fw},
+	{"BT_POWER_UP", handle_cmd_pwr_up},
+	{"BT_POWER_DOWN", handle_cmd_pwr_down},
+	{"BT_FW_CHIP_WAKEUP", handle_cmd_chip_wake_up},
+	{"BT_FW_CHIP_ALLOW_SLEEP", handle_cmd_chip_allow_sleep},
+	{"BT_ENABLE", handle_cmd_bt_enable},
+	{"CCA_THRESHOLD", handle_cmd_cca_thrshld},
+	/* Keep the NULL handler at the end of the table */
+	{(const char *)NULL, NULL},
+};
+
+static int wilc_bt_dev_open(struct inode *i, struct file *f)
+{
+	pr_err("at_pwr_dev: open()\n");
+	return 0;
+}
+
+static int wilc_bt_dev_close(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: close()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off)
+{
+	pr_debug("at_pwr_dev: read()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off)
+{
+	struct cmd_entry *cmd;
+	char *usr_str;
+
+
+	if (len == 0) {
+		pr_debug("received invalid size <=0: %d\n", len);
+		return len;
+	}
+
+	usr_str = kmalloc(len, GFP_KERNEL);
+
+	if (copy_from_user(usr_str, buff, len))
+		return -EIO;
+
+	pr_debug("received %s, len %d\n", usr_str, len);
+	// call the appropriate command handler
+	cmd = (struct cmd_entry *)cmd_table;
+	while (cmd->wilc_handle_cmd != NULL) {
+		if (strncmp(cmd->str, usr_str, strlen(cmd->str)) == 0) {
+			pr_debug("param len: %d, string: %s\n",
+				 len - strlen(cmd->str), usr_str);
+			cmd->wilc_handle_cmd(usr_str + strlen(cmd->str));
+			break;
+		}
+		cmd++;
+	}
+
+	kfree(usr_str);
+	return len;
+}
+
+static void wilc_bt_create_device(void)
+{
+	int ret = 0;
+
+	if (device_created)
+		return;
+
+	ret = alloc_chrdev_region(&chc_dev_no, 0, 1, "atmel");
+	if (ret < 0)
+		return;
+	chc_dev_class = class_create(THIS_MODULE, "atmel");
+	if (IS_ERR(chc_dev_class)) {
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	dev = device_create(chc_dev_class, NULL, chc_dev_no, NULL,
+			    "wilc_bt");
+	if (IS_ERR(dev)) {
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+
+	cdev_init(&str_chc_dev, &pugs_fops);
+	ret = cdev_add(&str_chc_dev, chc_dev_no, 1);
+	if (ret < 0) {
+		device_destroy(chc_dev_class, chc_dev_no);
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	mutex_init(&wilc_bt->cs);
+	device_created = 1;
+}
+
+static void handle_cmd_cca_thrshld(char *param)
+{
+	int carrier_thrshld, noise_thrshld;
+	unsigned int carr_thrshld_frac, noise_thrshld_frac, carr_thrshld_int,
+		noise_thrshld_int, reg;
+
+	if (param == NULL) {
+		pr_err("Invalid parameter\n");
+		return;
+	}
+
+	if (sscanf(param, " %d %d", &noise_thrshld, &carrier_thrshld) != 2) {
+		pr_err("Failed to parse input parameters. Usage:\n");
+		pr_err("echo CCA_THRESHOLD NOISE_THRESHOLD CARRIER_THRESHOLD > /dev/at_pwr_dev\n");
+		pr_err("where threshold values are in dB * 10\n");
+		pr_err("e.g. echo CCA_THRESHOLD -625 -826 > /dev/at_pwr_dev to set thresholds to -62.5 and -82.6\n\n");
+		return;
+	}
+
+	pr_info("Changing CCA noise threshold to %d and carrier thresholds to %d\n",
+		noise_thrshld, carrier_thrshld);
+
+	carr_thrshld_int = carrier_thrshld/10;
+	if (carrier_thrshld < 0)
+		carr_thrshld_frac = (carr_thrshld_int * 10) - carrier_thrshld;
+	else
+		carr_thrshld_frac = carrier_thrshld - (carr_thrshld_int * 10);
+
+	noise_thrshld_int = noise_thrshld/10;
+	if (noise_thrshld < 0)
+		noise_thrshld_frac = (noise_thrshld_int * 10) - noise_thrshld;
+	else
+		noise_thrshld_frac = noise_thrshld - (noise_thrshld_int * 10);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_2, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((noise_thrshld_frac & 0x7) | ((noise_thrshld_int & 0x1FF)
+					      << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_2, reg);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_7, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((carr_thrshld_frac & 0x7) | ((carr_thrshld_int & 0x1FF) << 3))
+		<< 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_7, reg);
+}
+
+int wilc_bt_power_down(struct wilc *wilc, int source)
+{
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (source == DEV_BT) {
+		int ret;
+		u32 reg;
+
+		pr_info("AT PWR: bt_power_down\n");
+
+		/* Adjust coexistence module. This should be done from the FW
+		 * in the future
+		 */
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL,
+					     &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Clear BT mode*/
+		reg &= ~BIT(1);
+		ret = hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL,
+					      reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+
+		/*TicketId1115*/
+		/*Disable awake coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					     &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					      reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		/*TicketId1115*/
+		/*Disable doze coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					     &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					      reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		// Disable BT wakeup
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		bt_init_done = 0;
+	}
+
+	mutex_lock(&wilc->cs);
+
+	pr_info("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power_status[DEV_WIFI],
+		 wilc->power_status[DEV_BT]);
+
+	if (wilc->power_status[source] == false) {
+		pr_err("power down request for already powered down source %s\n",
+		       (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else if (((source == DEV_WIFI) &&
+		  (wilc->power_status[DEV_BT] == true)) ||
+		  ((source == DEV_BT) &&
+		  (wilc->power_status[DEV_WIFI] == true))) {
+		pr_warn("Another device is preventing power down. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		wilc_wlan_power_off_sequence(wilc);
+	}
+	wilc->power_status[source] = false;
+
+	mutex_unlock(&wilc->cs);
+
+	return 0;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source)
+{
+	int count = 0;
+	int ret;
+	int reg;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	mutex_lock(&wilc->cs);
+
+	pr_debug("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power_status[DEV_WIFI],
+		 wilc->power_status[DEV_BT]);
+
+	if (wilc->power_status[source] == true) {
+		pr_err("power up request for already powered up source %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		/*Bug 215*/
+		/*Avoid overlapping between BT and Wifi intialization*/
+		if (wilc->power_status[DEV_WIFI] == true) {
+			while (!wilc->initialized) {
+				msleep(100);
+				if (++count > 20) {
+					pr_warn("Wifi initialize timeout\n");
+					break;
+				}
+			}
+		} else if (wilc->power_status[DEV_BT] == true) {
+			while (!bt_init_done) {
+				msleep(200);
+				if (++count > 30) {
+					pr_warn("BT initialize timeout\n");
+					break;
+				}
+			}
+			/* An additional wait to give BT firmware time to do
+			 * CPLL update as the time measured since the start of
+			 * BT Fw till the end of function "rf_nmi_init_tuner"
+			 * was 71.2 ms
+			 */
+			msleep(100);
+		}
+	}
+
+	if ((wilc->power_status[DEV_WIFI] == true) ||
+		   (wilc->power_status[DEV_BT] == true)) {
+		pr_info("Device already up. request source is %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		pr_info("WILC POWER UP\n");
+	}
+	wilc->power_status[source] = true;
+	mutex_unlock(&wilc->cs);
+
+	if (source == DEV_BT) {
+		/*TicketId1092*/
+		/*If WiFi is off, force BT*/
+		if (wilc->power_status[DEV_WIFI] == false) {
+			acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+			/*TicketId1115*/
+			/*Disable awake coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_ON_NULL_PKT,
+						     &reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_ON_NULL_PKT,
+						      reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+
+			/*TicketId1115*/
+			/*Disable doze coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_OFF_NULL_PKT,
+						     &reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_OFF_NULL_PKT,
+						      reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+		}
+
+		// Enable BT wakeup
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+		reg |= BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+	}
+
+	return 0;
+
+fail:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+	wilc_bt_power_down(wilc, DEV_BT);
+	return ret;
+}
+
+static void wilc_bt_firmware_download(struct wilc *wilc)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	const struct firmware *wilc_bt_firmware;
+	const u8 *buffer;
+	size_t buffer_size;
+	int ret = 0;
+	u32 reg;
+	const struct wilc_hif_func *hif_func;
+
+	hif_func = wilc->hif_func;
+
+	pr_info("Bluetooth firmware: %s\n", FW_WILC3000_BLE);
+	if (request_firmware(&wilc_bt_firmware, FW_WILC3000_BLE, dev) != 0) {
+		pr_err("%s - firmare not available. Skip!\n", FW_WILC3000_BLE);
+		ret = -1;
+		goto fail_1;
+	}
+
+	buffer = wilc_bt_firmware->data;
+	buffer_size = (size_t)wilc_bt_firmware->size;
+	if (buffer_size <= 0) {
+		pr_err("Firmware size = 0!\n");
+		ret = -1;
+		goto fail_1;
+	}
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	ret = hif_func->hif_write_reg(wilc, 0x4f0000, 0x71);
+	if (!ret) {
+		pr_err("[wilc start]: fail write reg 0x4f0000 ...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	/*
+	 * Avoid booting from BT boot ROM. Make sure that Drive IRQN
+	 * [SDIO platform] or SD_DAT3 [SPI platform] to ?1?
+	 */
+	/* Set cortus reset register to register control. */
+	ret = hif_func->hif_read_reg(wilc, 0x3b0090, &reg);
+	if (!ret) {
+		pr_err("[wilc start]: fail read reg 0x3b0090 ...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	reg |= (1 << 0);
+	ret = hif_func->hif_write_reg(wilc, 0x3b0090, reg);
+	if (!ret) {
+		pr_err("[wilc start]: fail write reg 0x3b0090 ...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	hif_func->hif_read_reg(wilc, 0x3B0400, &reg);
+
+	if (reg & (1ul << 2)) {
+		reg &= ~(1ul << 2);
+	} else {
+		reg |= (1ul << 2);
+		hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+		reg &= ~(1ul << 2);
+	}
+	hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+
+	/* blocks of sizes > 512 causes the wifi to hang! */
+	blksz = (1ul << 9);
+	/* Allocate a DMA coherent  buffer. */
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (dma_buffer == NULL) {
+		ret = -5;
+		pr_err("Can't allocate buffer for BT firmware download IO error\n");
+		goto fail_1;
+	}
+	pr_info("Downloading BT firmware size = %d ...\n", buffer_size);
+
+	offset = 0;
+	addr = 0x400000;
+	size = buffer_size;
+	addr = cpu_to_le32(addr);
+	size = cpu_to_le32(size);
+	offset = 0;
+
+	while (((int)size) && (offset < buffer_size)) {
+		if (size <= blksz)
+			size2 = size;
+		else
+			size2 = blksz;
+
+		/* Copy firmware into a DMA coherent buffer */
+		memcpy(dma_buffer, &buffer[offset], size2);
+
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_block_tx(wilc, addr, dma_buffer, size2);
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		if (!ret)
+			break;
+
+		addr += size2;
+		offset += size2;
+		size -= size2;
+	}
+
+	if (!ret) {
+		ret = -5;
+		pr_err("Can't download BT firmware IO error\n");
+		goto fail;
+	}
+
+fail:
+	kfree(dma_buffer);
+fail_1:
+	pr_debug("Freeing BT FW buffer ...\n");
+	pr_debug("Releasing BT firmware\n");
+	release_firmware(wilc_bt_firmware);
+}
+
+static void wilc_bt_start(struct wilc *wilc)
+{
+	u32 val32 = 0;
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	pr_info("Starting BT firmware\n");
+	/*
+	 * Write the firmware download complete magic value 0x10ADD09E at
+	 * location 0xFFFF000C (Cortus map) or C000C (AHB map).
+	 * This will let the boot-rom code execute from RAM.
+	 */
+	wilc->hif_func->hif_write_reg(wilc, 0x4F000c, 0x10add09e);
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &val32);
+	val32 &= ~((1ul << 2) | (1ul << 3));
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	msleep(100);
+
+	val32 |= ((1ul << 2) | (1ul << 3));
+
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	pr_info("BT Start Succeeded\n");
+
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_BT);
+}
+
+static void handle_cmd_pwr_up(char *param)
+{
+	pr_info("AT PWR: bt_power_up\n");
+	bt_init_done = 0;
+
+	if (!wilc_bt->initialized && !wilc_bt->hif_func->hif_is_init(wilc_bt)) {
+		acquire_bus(wilc_bt, ACQUIRE_ONLY, DEV_BT);
+		if (!wilc_bt->hif_func->hif_init(wilc_bt, false)) {
+			release_bus(wilc_bt, RELEASE_ONLY, DEV_BT);
+			return;
+		}
+		release_bus(wilc_bt, RELEASE_ONLY, DEV_BT);
+	}
+
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_pwr_down(char *param)
+{
+	wilc_bt_power_down(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_wake_up(char *param)
+{
+	chip_wakeup(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_allow_sleep(char *param)
+{
+	bt_init_done = 1;
+	chip_allow_sleep(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_download_fw(char *param)
+{
+	pr_info("AT PWR: bt_download_fw\n");
+
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+static void handle_cmd_bt_enable(char *param)
+{
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+void wilc_bt_init(struct wilc *wilc)
+{
+	wilc_bt = wilc;
+	pr_debug("at_pwr_dev: init\n");
+	wilc_bt_create_device();
+}
+
+void wilc_bt_deinit(void)
+{
+	pr_info("at_pwr_dev: deinit\n");
+
+	if (&wilc_bt->cs != NULL)
+		mutex_destroy(&wilc_bt->cs);
+
+	cdev_del(&str_chc_dev);
+	device_created = 0;
+	device_destroy(chc_dev_class, chc_dev_no);
+	class_destroy(chc_dev_class);
+	unregister_chrdev_region(chc_dev_no, 1);
+	pr_info("at_pwr_dev: unregistered\n");
+}
diff --git a/drivers/staging/wilc1000/wilc_debugfs.c b/drivers/staging/wilc1000/wilc_debugfs.c
index ce54864569c7..2c0460cfb7c6 100644
--- a/drivers/staging/wilc1000/wilc_debugfs.c
+++ b/drivers/staging/wilc1000/wilc_debugfs.c
@@ -1,41 +1,22 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * NewportMedia WiFi chipset driver test tools - wilc-debug
- * Copyright (c) 2012 NewportMedia Inc.
- * Author: SSW <sswd@wilcsemic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
 
 #if defined(WILC_DEBUGFS)
 #include <linux/module.h>
 #include <linux/debugfs.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
 
-#include "wilc_wlan_if.h"
+#include "wilc_debugfs.h"
 
 static struct dentry *wilc_dir;
 
-/*
- * ----------------------------------------------------------------------------
- */
-#define DEBUG           BIT(0)
-#define INFO            BIT(1)
-#define WRN             BIT(2)
-#define ERR             BIT(3)
-
-#define DBG_LEVEL_ALL	(DEBUG | INFO | WRN | ERR)
-static atomic_t WILC_DEBUG_LEVEL = ATOMIC_INIT(ERR);
-EXPORT_SYMBOL_GPL(WILC_DEBUG_LEVEL);
-
-/*
- * ----------------------------------------------------------------------------
- */
+atomic_t WILC_DEBUG_REGION = ATOMIC_INIT(INIT_DBG | GENERIC_DBG |
+					 CFG80211_DBG | HOSTAPD_DBG |
+					 PWRDEV_DBG);
 
-static ssize_t wilc_debug_level_read(struct file *file, char __user *userbuf,
+static ssize_t wilc_debug_region_read(struct file *file, char __user *userbuf,
 				     size_t count, loff_t *ppos)
 {
 	char buf[128];
@@ -45,13 +26,13 @@ static ssize_t wilc_debug_level_read(struct file *file, char __user *userbuf,
 	if (*ppos > 0)
 		return 0;
 
-	res = scnprintf(buf, sizeof(buf), "Debug Level: %x\n",
-			atomic_read(&WILC_DEBUG_LEVEL));
+	res = scnprintf(buf, sizeof(buf), "Debug Region: (0x%08x)\n",
+				    atomic_read(&WILC_DEBUG_REGION));
 
 	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
 }
 
-static ssize_t wilc_debug_level_write(struct file *filp,
+static ssize_t wilc_debug_region_write(struct file *filp,
 				      const char __user *buf, size_t count,
 				      loff_t *ppos)
 {
@@ -62,26 +43,20 @@ static ssize_t wilc_debug_level_write(struct file *filp,
 	if (ret)
 		return ret;
 
-	if (flag > DBG_LEVEL_ALL) {
-		pr_info("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
-			__func__, flag, atomic_read(&WILC_DEBUG_LEVEL));
+	if (flag > DBG_REGION_ALL) {
+		pr_err("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
+			   __func__, flag, atomic_read(&WILC_DEBUG_REGION));
+		pr_err("allowed bits are 0 to 15\n");
 		return -EINVAL;
 	}
 
-	atomic_set(&WILC_DEBUG_LEVEL, (int)flag);
+	atomic_set(&WILC_DEBUG_REGION, (int)flag);
 
-	if (flag == 0)
-		pr_info("Debug-level disabled\n");
-	else
-		pr_info("Debug-level enabled\n");
+	pr_info("Debug region set to %x\n", atomic_read(&WILC_DEBUG_REGION));
 
 	return count;
 }
 
-/*
- * ----------------------------------------------------------------------------
- */
-
 #define FOPS(_open, _read, _write, _poll) { \
 		.owner	= THIS_MODULE, \
 		.open	= (_open), \
@@ -99,19 +74,24 @@ struct wilc_debugfs_info_t {
 
 static struct wilc_debugfs_info_t debugfs_info[] = {
 	{
-		"wilc_debug_level",
+		"wilc_debug_region",
 		0666,
-		(DEBUG | ERR),
-		FOPS(NULL, wilc_debug_level_read, wilc_debug_level_write, NULL),
+		0,
+		FOPS(NULL, wilc_debug_region_read, wilc_debug_region_write,
+		     NULL),
 	},
 };
 
-static int __init wilc_debugfs_init(void)
+int wilc_debugfs_init(void)
 {
 	int i;
 	struct wilc_debugfs_info_t *info;
 
-	wilc_dir = debugfs_create_dir("wilc_wifi", NULL);
+	wilc_dir = debugfs_create_dir("wilc", NULL);
+	if (wilc_dir == NULL) {
+		pr_err("Error creating debugfs\n");
+		return -EFAULT;
+	}
 	for (i = 0; i < ARRAY_SIZE(debugfs_info); i++) {
 		info = &debugfs_info[i];
 		debugfs_create_file(info->name,
@@ -122,12 +102,10 @@ static int __init wilc_debugfs_init(void)
 	}
 	return 0;
 }
-module_init(wilc_debugfs_init);
 
-static void __exit wilc_debugfs_remove(void)
+void wilc_debugfs_remove(void)
 {
 	debugfs_remove_recursive(wilc_dir);
 }
-module_exit(wilc_debugfs_remove);
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_debugfs.h b/drivers/staging/wilc1000/wilc_debugfs.h
new file mode 100644
index 000000000000..cf6efd94bcde
--- /dev/null
+++ b/drivers/staging/wilc1000/wilc_debugfs.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_DEBUGFS_H
+#define WILC_DEBUGFS_H
+
+#include <linux/kern_levels.h>
+
+#define GENERIC_DBG		BIT(0)
+#define HOSTAPD_DBG		BIT(1)
+#define HOSTINF_DBG		BIT(2)
+#define CORECONFIG_DBG		BIT(3)
+#define CFG80211_DBG		BIT(4)
+#define INT_DBG			BIT(5)
+#define TX_DBG			BIT(6)
+#define RX_DBG			BIT(7)
+#define TCP_ENH			BIT(8)
+#define INIT_DBG		BIT(9)
+#define PWRDEV_DBG		BIT(10)
+#define DBG_REGION_ALL		(BIT(11)-1)
+
+extern atomic_t WILC_DEBUG_REGION;
+
+#define PRINT_D(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_dbg(netdev, "DBG [%s: %d] "format, __func__, __LINE__,\
+		   ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_INFO(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_info(netdev, "INFO [%s]"format, __func__, \
+		##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_WRN(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_warn(netdev, "WRN [%s: %d]"format, __func__, __LINE__,\
+		    ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_ER(netdev, format, ...) netdev_err(netdev, "ERR [%s:%d] "format,\
+	__func__, __LINE__, ##__VA_ARGS__)
+
+int wilc_debugfs_init(void);
+void wilc_debugfs_remove(void);
+#endif /* WILC_DEBUGFS_H */
diff --git a/drivers/staging/wilc1000/wilc_sdio.c b/drivers/staging/wilc1000/wilc_sdio.c
index 0189e3edbbbe..739a70499ff1 100644
--- a/drivers/staging/wilc1000/wilc_sdio.c
+++ b/drivers/staging/wilc1000/wilc_sdio.c
@@ -1,21 +1,28 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) Atmel Corporation.  All rights reserved.
- *
- * Module Name:  wilc_sdio.c
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
 
-#include <linux/string.h>
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-#include "wilc_wfi_netdevice.h"
 #include <linux/mmc/sdio_func.h>
-#include <linux/mmc/card.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/mmc/sdio.h>
 #include <linux/mmc/host.h>
-#include <linux/of_gpio.h>
+#include <linux/mmc/card.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
 
-#define SDIO_MODALIAS "wilc1000_sdio"
+#include "wilc_wfi_netdevice.h"
+#include "wilc_wlan.h"
+
+enum sdio_host_lock {
+	WILC_SDIO_HOST_NO_TAKEN = 0,
+	WILC_SDIO_HOST_IRQ_TAKEN = 1,
+	WILC_SDIO_HOST_DIS_TAKEN = 2,
+};
+
+static enum sdio_host_lock	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+static wait_queue_head_t sdio_intr_waitqueue;
+
+#define SDIO_MODALIAS "wilc_sdio"
 
 #define SDIO_VENDOR_ID_WILC 0x0296
 #define SDIO_DEVICE_ID_WILC 0x5347
@@ -31,11 +38,9 @@ struct wilc_sdio {
 	bool irq_gpio;
 	u32 block_size;
 	int nint;
-#define MAX_NUN_INT_THRPT_ENH2 (5) /* Max num interrupts allowed in registers 0xf7, 0xf8 */
-	int has_thrpt_enh3;
+	bool is_init;
 };
 
-static struct wilc_sdio g_sdio;
 static const struct wilc_hif_func wilc_hif_sdio;
 
 static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data);
@@ -44,9 +49,14 @@ static int sdio_init(struct wilc *wilc, bool resume);
 
 static void wilc_sdio_interrupt(struct sdio_func *func)
 {
+	if (sdio_intr_lock == WILC_SDIO_HOST_DIS_TAKEN)
+		return;
+	sdio_intr_lock = WILC_SDIO_HOST_IRQ_TAKEN;
 	sdio_release_host(func);
 	wilc_handle_isr(sdio_get_drvdata(func));
 	sdio_claim_host(func);
+	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+	wake_up_interruptible(&sdio_intr_waitqueue);
 }
 
 static int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)
@@ -112,24 +122,39 @@ static int linux_sdio_probe(struct sdio_func *func,
 			    const struct sdio_device_id *id)
 {
 	struct wilc *wilc;
-	int gpio, ret;
+	int ret, io_type;
+	static bool init_power;
+	struct wilc_sdio *sdio_priv;
 
-	gpio = -1;
-	if (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {
-		gpio = of_get_gpio(func->dev.of_node, 0);
-		if (gpio < 0)
-			gpio = GPIO_NUM;
-	}
+	sdio_priv = kzalloc(sizeof(*sdio_priv), GFP_KERNEL);
+	if (!sdio_priv)
+		return -ENOMEM;
 
+	if (IS_ENABLED(CONFIG_WILC_HW_OOB_INTR))
+		io_type = HIF_SDIO_GPIO_IRQ;
+	else
+		io_type = HIF_SDIO;
 	dev_dbg(&func->dev, "Initializing netdev\n");
-	ret = wilc_netdev_init(&wilc, &func->dev, HIF_SDIO, gpio,
-			       &wilc_hif_sdio);
+	ret = wilc_netdev_init(&wilc, &func->dev, io_type, &wilc_hif_sdio);
 	if (ret) {
 		dev_err(&func->dev, "Couldn't initialize netdev\n");
+		kfree(sdio_priv);
 		return ret;
 	}
 	sdio_set_drvdata(func, wilc);
+	wilc->bus_data = sdio_priv;
 	wilc->dev = &func->dev;
+	wilc->dt_dev = &func->card->dev;
+
+	if (!init_power) {
+		wilc_wlan_power_on_sequence(wilc);
+		init_power = 1;
+	}
+
+	mutex_init(&wilc->hif_cs);
+	mutex_init(&wilc->cs);
+
+	wilc_bt_init(wilc);
 
 	dev_info(&func->dev, "Driver Initializing success\n");
 	return 0;
@@ -137,26 +162,36 @@ static int linux_sdio_probe(struct sdio_func *func,
 
 static void linux_sdio_remove(struct sdio_func *func)
 {
-	wilc_netdev_cleanup(sdio_get_drvdata(func));
+	struct wilc *wilc = sdio_get_drvdata(func);
+
+	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
 }
 
-static int sdio_reset(struct wilc *wilc)
+static int wilc_sdio_reset(struct wilc *wilc)
 {
 	struct sdio_cmd52 cmd;
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 
+	dev_info(&func->dev, "De Init SDIO\n");
+
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
 	cmd.address = 0x6;
 	cmd.data = 0x8;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
-	if (ret) {
-		dev_err(&func->dev, "Fail cmd 52, reset cmd ...\n");
-		return ret;
-	}
-	return 0;
+	if (ret)
+		dev_err(&func->dev, "Fail cmd 52, reset cmd\n");
+	return ret;
+}
+
+static bool sdio_is_init(struct wilc *wilc)
+{
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	return sdio_priv->is_init;
 }
 
 static int wilc_sdio_suspend(struct device *dev)
@@ -165,22 +200,20 @@ static int wilc_sdio_suspend(struct device *dev)
 	struct wilc *wilc = sdio_get_drvdata(func);
 	int ret;
 
-	dev_info(dev, "sdio suspend\n");
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio suspend\n");
+	mutex_lock(&wilc->hif_cs);
 
-	if (!wilc->suspend_event) {
-		wilc_chip_sleep_manually(wilc);
-	} else {
-		host_sleep_notify(wilc);
-		chip_allow_sleep(wilc);
-	}
+	chip_wakeup(wilc, 0);
 
-	ret = sdio_reset(wilc);
-	if (ret) {
-		dev_err(&func->dev, "Fail reset sdio\n");
-		return ret;
-	}
-	sdio_claim_host(func);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
+
+	ret = wilc_sdio_reset(wilc);
 
 	return 0;
 }
@@ -190,34 +223,48 @@ static int wilc_sdio_resume(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	dev_info(dev, "sdio resume\n");
-	sdio_release_host(func);
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio resume\n");
+	chip_wakeup(wilc, 0);
 	sdio_init(wilc, true);
 
-	if (wilc->suspend_event)
-		host_wakeup_notify(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
 
-	chip_allow_sleep(wilc);
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
 
 	return 0;
 }
 
+static const struct of_device_id wilc_of_match[] = {
+	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, wilc_of_match);
+
 static const struct dev_pm_ops wilc_sdio_pm_ops = {
 	.suspend = wilc_sdio_suspend,
 	.resume = wilc_sdio_resume,
 };
 
-static struct sdio_driver wilc1000_sdio_driver = {
+static struct sdio_driver wilc_sdio_driver = {
 	.name		= SDIO_MODALIAS,
 	.id_table	= wilc_sdio_ids,
 	.probe		= linux_sdio_probe,
 	.remove		= linux_sdio_remove,
 	.drv = {
 		.pm = &wilc_sdio_pm_ops,
+		.of_match_table = wilc_of_match,
 	}
 };
-module_driver(wilc1000_sdio_driver,
+module_driver(wilc_sdio_driver,
 	      sdio_register_driver,
 	      sdio_unregister_driver);
 MODULE_LICENSE("GPL");
@@ -227,6 +274,8 @@ static int wilc_sdio_enable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret = 0;
 
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_claim_irq(func, wilc_sdio_interrupt);
 	sdio_release_host(func);
@@ -243,11 +292,19 @@ static void wilc_sdio_disable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret;
 
+	dev_info(&func->dev, "%s\n", __func__);
+
+	if (sdio_intr_lock  == WILC_SDIO_HOST_IRQ_TAKEN)
+		wait_event_interruptible(sdio_intr_waitqueue,
+				   sdio_intr_lock == WILC_SDIO_HOST_NO_TAKEN);
+	sdio_intr_lock  = WILC_SDIO_HOST_DIS_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_release_irq(func);
 	if (ret < 0)
 		dev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);
 	sdio_release_host(func);
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 }
 
 /********************************************
@@ -273,7 +330,7 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10c data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x10d;
@@ -281,7 +338,7 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10d data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x10e;
@@ -289,11 +346,11 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10e data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -311,7 +368,7 @@ static int sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x11;
@@ -319,11 +376,11 @@ static int sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x11 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -347,18 +404,18 @@ static int sdio_set_func1_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x110 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 	cmd.address = 0x111;
 	cmd.data = (u8)(block_size >> 8);
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x111 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -370,11 +427,12 @@ static int sdio_set_func1_block_size(struct wilc *wilc, u32 block_size)
 static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
 
-	data = cpu_to_le32(data);
+	cpu_to_le32s(&data);
 
-	if ((addr >= 0xf0) && (addr <= 0xff)) {
+	if (addr >= 0xf0 && addr <= 0xff) {
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 1;
@@ -385,8 +443,8 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
-				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto _fail_;
+				"Failed cmd 52, write reg %08x ...\n", addr);
+			goto fail;
 		}
 	} else {
 		struct sdio_cmd53 cmd;
@@ -395,7 +453,7 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		 *      set the AHB address
 		 **/
 		if (!sdio_set_func0_csa_address(wilc, addr))
-			goto _fail_;
+			goto fail;
 
 		cmd.read_write = 1;
 		cmd.function = 0;
@@ -404,18 +462,18 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		cmd.increment = 1;
 		cmd.count = 4;
 		cmd.buffer = (u8 *)&data;
-		cmd.block_size = g_sdio.block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = sdio_priv->block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, write reg (%08x)...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -423,7 +481,8 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
-	u32 block_size = g_sdio.block_size;
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+	u32 block_size = sdio_priv->block_size;
 	struct sdio_cmd53 cmd;
 	int nblk, nleft, ret;
 
@@ -469,13 +528,13 @@ static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block send...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -488,23 +547,23 @@ static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
-		cmd.block_size = block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = block_size;
 
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes send...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -512,9 +571,10 @@ static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
 
-	if ((addr >= 0xf0) && (addr <= 0xff)) {
+	if (addr >= 0xf0 && addr <= 0xff) {
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 0;
@@ -525,14 +585,14 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		*data = cmd.data;
 	} else {
 		struct sdio_cmd53 cmd;
 
 		if (!sdio_set_func0_csa_address(wilc, addr))
-			goto _fail_;
+			goto fail;
 
 		cmd.read_write = 0;
 		cmd.function = 0;
@@ -542,20 +602,20 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		cmd.count = 4;
 		cmd.buffer = (u8 *)data;
 
-		cmd.block_size = g_sdio.block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = sdio_priv->block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, read reg (%08x)...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
-	*data = cpu_to_le32(*data);
+	le32_to_cpus(data);
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -563,7 +623,8 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
-	u32 block_size = g_sdio.block_size;
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+	u32 block_size = sdio_priv->block_size;
 	struct sdio_cmd53 cmd;
 	int nblk, nleft, ret;
 
@@ -609,13 +670,13 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block read...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -628,23 +689,23 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
-		cmd.block_size = block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = block_size;
 
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes read...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -657,20 +718,29 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 static int sdio_deinit(struct wilc *wilc)
 {
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	sdio_priv->is_init = false;
+
 	return 1;
 }
 
 static int sdio_init(struct wilc *wilc, bool resume)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	struct sdio_cmd52 cmd;
 	int loop, ret;
 	u32 chipid;
 
-	if (!resume) {
-		memset(&g_sdio, 0, sizeof(struct wilc_sdio));
-		g_sdio.irq_gpio = wilc->dev_irq_num;
-	}
+	dev_info(&func->dev, "SDIO speed: %d\n",
+		func->card->host->ios.clock);
+
+	/* Patch for sdio interrupt latency issue */
+	pm_runtime_get_sync(mmc_dev(func->card->host));
+
+	init_waitqueue_head(&sdio_intr_waitqueue);
+	sdio_priv->irq_gpio = (wilc->io_type == HIF_SDIO_GPIO_IRQ);
 
 	/**
 	 *      function 0 csa enable
@@ -683,7 +753,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, enable csa...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -691,9 +761,9 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	 **/
 	if (!sdio_set_func0_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
 		dev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");
-		goto _fail_;
+		goto fail;
 	}
-	g_sdio.block_size = WILC_SDIO_BLOCK_SIZE;
+	sdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;
 
 	/**
 	 *      enable func1 IO
@@ -707,7 +777,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	if (ret) {
 		dev_err(&func->dev,
 			"Fail cmd 52, set IOE register...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -724,7 +794,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 		if (ret) {
 			dev_err(&func->dev,
 				"Fail cmd 52, get IOR register...\n");
-			goto _fail_;
+			goto fail;
 		}
 		if (cmd.data == 0x2)
 			break;
@@ -732,7 +802,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 
 	if (loop <= 0) {
 		dev_err(&func->dev, "Fail func 1 is not ready...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -740,7 +810,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	 **/
 	if (!sdio_set_func1_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
 		dev_err(&func->dev, "Fail set func 1 block size...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -754,29 +824,30 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set IEN register...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
 	 *      make sure can read back chip id correctly
 	 **/
 	if (!resume) {
-		if (!sdio_read_reg(wilc, 0x1000, &chipid)) {
-			dev_err(&func->dev, "Fail cmd read chip id...\n");
-			goto _fail_;
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&func->dev, "Unsupported chipid: %x\n", chipid);
+			goto fail;
 		}
-		dev_err(&func->dev, "chipid (%08x)\n", chipid);
-		if ((chipid & 0xfff) > 0x2a0)
-			g_sdio.has_thrpt_enh3 = 1;
-		else
-			g_sdio.has_thrpt_enh3 = 0;
-		dev_info(&func->dev, "has_thrpt_enh3 = %d...\n",
-			 g_sdio.has_thrpt_enh3);
+		dev_info(&func->dev, "chipid %08x\n", chipid);
 	}
 
+	sdio_priv->is_init = true;
+
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -797,9 +868,6 @@ static int sdio_read_size(struct wilc *wilc, u32 *size)
 	wilc_sdio_cmd52(wilc, &cmd);
 	tmp = cmd.data;
 
-	/* cmd.read_write = 0; */
-	/* cmd.function = 0; */
-	/* cmd.raw = 0; */
 	cmd.address = 0xf3;
 	cmd.data = 0;
 	wilc_sdio_cmd52(wilc, &cmd);
@@ -812,17 +880,34 @@ static int sdio_read_size(struct wilc *wilc, u32 *size)
 static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 tmp;
 	struct sdio_cmd52 cmd;
+	u32 irq_flags;
+	int i;
 
-	sdio_read_size(wilc, &tmp);
+	if (sdio_priv->irq_gpio) {
+		sdio_read_size(wilc, &tmp);
 
-	/**
-	 *      Read IRQ flags
-	 **/
-	if (!g_sdio.irq_gpio) {
-		int i;
+		cmd.read_write = 0;
+		cmd.function = 1;
+		cmd.raw = 0;
+		cmd.data = 0;
+		if (wilc->chip == WILC_1000) {
+			cmd.address = 0xf7;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x1f;
+		} else {
+			cmd.address = 0xfe;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x0f;
+		}
+		tmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);
 
+		*int_status = tmp;
+	} else {
+		sdio_read_size(wilc, &tmp);
+		cmd.read_write = 0;
 		cmd.function = 1;
 		cmd.address = 0x04;
 		cmd.data = 0;
@@ -838,9 +923,8 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 			tmp |= INT_3;
 		if (cmd.data & BIT(5))
 			tmp |= INT_4;
-		if (cmd.data & BIT(6))
-			tmp |= INT_5;
-		for (i = g_sdio.nint; i < MAX_NUM_INT; i++) {
+
+		for (i = sdio_priv->nint; i < MAX_NUM_INT; i++) {
 			if ((tmp >> (IRG_FLAGS_OFFSET + i)) & 0x1) {
 				dev_err(&func->dev,
 					"Unexpected interrupt (1) : tmp=%x, data=%x\n",
@@ -848,20 +932,10 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 				break;
 			}
 		}
-	} else {
-		u32 irq_flags;
 
-		cmd.read_write = 0;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = 0xf7;
-		cmd.data = 0;
-		wilc_sdio_cmd52(wilc, &cmd);
-		irq_flags = cmd.data & 0x1f;
-		tmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);
-	}
+		*int_status = tmp;
 
-	*int_status = tmp;
+	}
 
 	return 1;
 }
@@ -869,27 +943,22 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 static int sdio_clear_int_ext(struct wilc *wilc, u32 val)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
+	u32 reg = 0;
 
-	if (g_sdio.has_thrpt_enh3) {
-		u32 reg;
+	if (wilc->chip == WILC_1000) {
+		if (sdio_priv->irq_gpio)
+			reg = val & (BIT(MAX_NUM_INT) - 1);
 
-		if (g_sdio.irq_gpio) {
-			u32 flags;
-
-			flags = val & (BIT(MAX_NUN_INT_THRPT_ENH2) - 1);
-			reg = flags;
-		} else {
-			reg = 0;
-		}
 		/* select VMM table 0 */
-		if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
+		if (val & SEL_VMM_TBL0)
 			reg |= BIT(5);
 		/* select VMM table 1 */
-		if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
+		if (val & SEL_VMM_TBL1)
 			reg |= BIT(6);
 		/* enable VMM */
-		if ((val & EN_VMM) == EN_VMM)
+		if (val & EN_VMM)
 			reg |= BIT(7);
 		if (reg) {
 			struct sdio_cmd52 cmd;
@@ -905,127 +974,97 @@ static int sdio_clear_int_ext(struct wilc *wilc, u32 val)
 				dev_err(&func->dev,
 					"Failed cmd52, set 0xf8 data (%d) ...\n",
 					__LINE__);
-				goto _fail_;
+				goto fail;
 			}
 		}
 	} else {
-		if (g_sdio.irq_gpio) {
-			/* see below. has_thrpt_enh2 uses register 0xf8 to clear interrupts. */
-			/* Cannot clear multiple interrupts. Must clear each interrupt individually */
-			u32 flags;
-
-			flags = val & (BIT(MAX_NUM_INT) - 1);
-			if (flags) {
-				int i;
-
-				ret = 1;
-				for (i = 0; i < g_sdio.nint; i++) {
-					if (flags & 1) {
-						struct sdio_cmd52 cmd;
-
-						cmd.read_write = 1;
-						cmd.function = 0;
-						cmd.raw = 0;
-						cmd.address = 0xf8;
-						cmd.data = BIT(i);
-
-						ret = wilc_sdio_cmd52(wilc, &cmd);
-						if (ret) {
-							dev_err(&func->dev,
-								"Failed cmd52, set 0xf8 data (%d) ...\n",
-								__LINE__);
-							goto _fail_;
-						}
-					}
-					if (!ret)
-						break;
-					flags >>= 1;
-				}
-				if (!ret)
-					goto _fail_;
-				for (i = g_sdio.nint; i < MAX_NUM_INT; i++) {
-					if (flags & 1)
-						dev_err(&func->dev,
-							"Unexpected interrupt cleared %d...\n",
-							i);
-					flags >>= 1;
-				}
-			}
-		}
-
-		{
-			u32 vmm_ctl;
-
-			vmm_ctl = 0;
-			/* select VMM table 0 */
-			if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				vmm_ctl |= BIT(0);
-			/* select VMM table 1 */
-			if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				vmm_ctl |= BIT(1);
-			/* enable VMM */
-			if ((val & EN_VMM) == EN_VMM)
-				vmm_ctl |= BIT(2);
-
-			if (vmm_ctl) {
+		if (sdio_priv->irq_gpio) {
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+			if (reg) {
 				struct sdio_cmd52 cmd;
 
 				cmd.read_write = 1;
 				cmd.function = 0;
 				cmd.raw = 0;
-				cmd.address = 0xf6;
-				cmd.data = vmm_ctl;
+				cmd.address = 0xfe;
+				cmd.data = reg;
+
 				ret = wilc_sdio_cmd52(wilc, &cmd);
 				if (ret) {
 					dev_err(&func->dev,
-						"Failed cmd52, set 0xf6 data (%d) ...\n",
+						"Failed cmd52, set 0xf8 data (%d) ...\n",
 						__LINE__);
-					goto _fail_;
+					goto fail;
 				}
 			}
 		}
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(0);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(1);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(2);
+
+		if (reg) {
+			struct sdio_cmd52 cmd;
+
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = 0xf1;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd52, set 0xf6 data (%d) ...\n",
+					__LINE__);
+				goto fail;
+			}
+		}
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
 static int sdio_sync_ext(struct wilc *wilc, int nint)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 reg;
+	int ret, i;
 
 	if (nint > MAX_NUM_INT) {
-		dev_err(&func->dev, "Too many interrupts (%d)...\n", nint);
-		return 0;
-	}
-	if (nint > MAX_NUN_INT_THRPT_ENH2) {
-		dev_err(&func->dev,
-			"Cannot support more than 5 interrupts when has_thrpt_enh2=1.\n");
+		dev_err(&func->dev, "Too many interrupts %d\n", nint);
 		return 0;
 	}
 
-	g_sdio.nint = nint;
-
-	/**
-	 *      Disable power sequencer
-	 **/
-	if (!sdio_read_reg(wilc, WILC_MISC, &reg)) {
-		dev_err(&func->dev, "Failed read misc reg...\n");
-		return 0;
-	}
+	sdio_priv->nint = nint;
 
-	reg &= ~BIT(8);
-	if (!sdio_write_reg(wilc, WILC_MISC, reg)) {
-		dev_err(&func->dev, "Failed write misc reg...\n");
-		return 0;
+/* WILC3000 only. Was removed in WILC1000 on revision 6200.
+ * Might be related to suspend/resume
+ */
+	if (wilc->chip == WILC_3000) {
+		/**
+		 *      Disable power sequencer
+		 **/
+		if (!sdio_read_reg(wilc, WILC_MISC, &reg)) {
+			dev_err(&func->dev, "Failed read misc reg\n");
+			return 0;
+		}
+		reg &= ~BIT(8);
+		if (!sdio_write_reg(wilc, WILC_MISC, reg)) {
+			dev_err(&func->dev, "Failed write misc reg\n");
+			return 0;
+		}
 	}
 
-	if (g_sdio.irq_gpio) {
-		u32 reg;
-		int ret, i;
-
+	if (sdio_priv->irq_gpio) {
 		/**
 		 *      interrupt pin mux select
 		 **/
@@ -1073,7 +1112,7 @@ static int sdio_sync_ext(struct wilc *wilc, int nint)
 			for (i = 0; (i < 3) && (nint > 0); i++, nint--)
 				reg |= BIT(i);
 
-			ret = sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
+			ret = sdio_write_reg(wilc, WILC_INTR2_ENABLE, reg);
 			if (!ret) {
 				dev_err(&func->dev,
 					"Failed write reg (%08x)...\n",
@@ -1085,12 +1124,7 @@ static int sdio_sync_ext(struct wilc *wilc, int nint)
 	return 1;
 }
 
-/********************************************
- *
- *      Global sdio HIF function table
- *
- ********************************************/
-
+/* Global sdio HIF function table */
 static const struct wilc_hif_func wilc_hif_sdio = {
 	.hif_init = sdio_init,
 	.hif_deinit = sdio_deinit,
@@ -1106,5 +1140,7 @@ static const struct wilc_hif_func wilc_hif_sdio = {
 	.hif_sync_ext = sdio_sync_ext,
 	.enable_interrupt = wilc_sdio_enable_interrupt,
 	.disable_interrupt = wilc_sdio_disable_interrupt,
+	.hif_reset = wilc_sdio_reset,
+	.hif_is_init = sdio_is_init,
 };
 
diff --git a/drivers/staging/wilc1000/wilc_spi.c b/drivers/staging/wilc1000/wilc_spi.c
index 5ef84410e0f2..5781f2630185 100644
--- a/drivers/staging/wilc1000/wilc_spi.c
+++ b/drivers/staging/wilc1000/wilc_spi.c
@@ -1,37 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) Atmel Corporation.  All rights reserved.
- *
- * Module Name:  wilc_spi.c
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/device.h>
 #include <linux/spi/spi.h>
-#include <linux/of_gpio.h>
+#include <linux/module.h>
 
-#include <linux/string.h>
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
 #include "wilc_wfi_netdevice.h"
 
 struct wilc_spi {
 	int crc_off;
 	int nint;
-	int has_thrpt_enh;
+	bool is_init;
 };
 
-static struct wilc_spi g_spi;
 static const struct wilc_hif_func wilc_hif_spi;
 
-static int wilc_spi_read(struct wilc *wilc, u32, u8 *, u32);
-static int wilc_spi_write(struct wilc *wilc, u32, u8 *, u32);
+static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen);
+static int wilc_spi_reset(struct wilc *wilc);
 
 /********************************************
  *
@@ -94,72 +81,180 @@ static u8 crc7(u8 crc, const u8 *buffer, u32 len)
 
 #define CMD_DMA_WRITE				0xc1
 #define CMD_DMA_READ				0xc2
-#define CMD_INTERNAL_WRITE		0xc3
-#define CMD_INTERNAL_READ		0xc4
+#define CMD_INTERNAL_WRITE			0xc3
+#define CMD_INTERNAL_READ			0xc4
 #define CMD_TERMINATE				0xc5
-#define CMD_REPEAT					0xc6
-#define CMD_DMA_EXT_WRITE		0xc7
-#define CMD_DMA_EXT_READ		0xc8
+#define CMD_REPEAT				0xc6
+#define CMD_DMA_EXT_WRITE			0xc7
+#define CMD_DMA_EXT_READ			0xc8
 #define CMD_SINGLE_WRITE			0xc9
-#define CMD_SINGLE_READ			0xca
-#define CMD_RESET						0xcf
+#define CMD_SINGLE_READ				0xca
+#define CMD_RESET				0xcf
 
-#define N_OK								1
-#define N_FAIL								0
-#define N_RESET							-1
-#define N_RETRY							-2
+#define N_OK					1
+#define N_FAIL					0
+#define N_RESET					-1
+#define N_RETRY					-2
 
+#define SPI_RESP_RETRY_COUNT			(10)
+#define SPI_RETRY_COUNT				(10)
 #define DATA_PKT_SZ_256				256
-#define DATA_PKT_SZ_512			512
+#define DATA_PKT_SZ_512				512
 #define DATA_PKT_SZ_1K				1024
+#define DATA_PKT_SZ_2K				(2 * 1024)
 #define DATA_PKT_SZ_4K				(4 * 1024)
 #define DATA_PKT_SZ_8K				(8 * 1024)
-#define DATA_PKT_SZ					DATA_PKT_SZ_8K
+#define DATA_PKT_SZ				DATA_PKT_SZ_8K
 
-#define USE_SPI_DMA     0
+#define USE_SPI_DMA				0
 
 static int wilc_bus_probe(struct spi_device *spi)
 {
-	int ret, gpio;
+	int ret;
+	static bool init_power;
 	struct wilc *wilc;
+	struct device *dev = &spi->dev;
+	struct wilc_spi *spi_priv;
 
-	gpio = of_get_gpio(spi->dev.of_node, 0);
-	if (gpio < 0)
-		gpio = GPIO_NUM;
+	dev_info(&spi->dev, "spiModalias: %s, spiMax-Speed: %d\n",
+			spi->modalias, spi->max_speed_hz);
 
-	ret = wilc_netdev_init(&wilc, NULL, HIF_SPI, GPIO_NUM, &wilc_hif_spi);
-	if (ret)
+	spi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);
+	if (!spi_priv)
+		return -ENOMEM;
+
+	ret = wilc_netdev_init(&wilc, dev, HIF_SPI, &wilc_hif_spi);
+	if (ret) {
+		kfree(spi_priv);
 		return ret;
+	}
 
 	spi_set_drvdata(spi, wilc);
 	wilc->dev = &spi->dev;
+	wilc->bus_data = spi_priv;
+	wilc->dt_dev = &spi->dev;
+
 
+	if (!init_power) {
+		wilc_wlan_power_on_sequence(wilc);
+		init_power = 1;
+	}
+
+	mutex_init(&wilc->hif_cs);
+	mutex_init(&wilc->cs);
+	wilc_bt_init(wilc);
+
+	dev_info(dev, "WILC SPI probe success\n");
 	return 0;
 }
 
 static int wilc_bus_remove(struct spi_device *spi)
 {
-	wilc_netdev_cleanup(spi_get_drvdata(spi));
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
+	return 0;
+}
+
+static int wilc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n << SUSPEND >>\n\n");
+	mutex_lock(&wilc->hif_cs);
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	/*notify the chip that host will sleep*/
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+	mutex_lock(&wilc->hif_cs);
+
+	return 0;
+}
+
+static int wilc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n  <<RESUME>>\n\n");
+
+	/*wake the chip to compelete the re-intialization*/
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
 	return 0;
 }
 
-static const struct of_device_id wilc1000_of_match[] = {
-	{ .compatible = "atmel,wilc_spi", },
-	{}
+static const struct of_device_id wilc_of_match[] = {
+	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, wilc_of_match);
+static const struct dev_pm_ops wilc_spi_pm_ops = {
+	.suspend = wilc_spi_suspend,
+	.resume = wilc_spi_resume,
 };
-MODULE_DEVICE_TABLE(of, wilc1000_of_match);
 
-static struct spi_driver wilc1000_spi_driver = {
+static struct spi_driver wilc_spi_driver = {
 	.driver = {
 		.name = MODALIAS,
-		.of_match_table = wilc1000_of_match,
+		.of_match_table = wilc_of_match,
+		.pm = &wilc_spi_pm_ops,
 	},
 	.probe =  wilc_bus_probe,
 	.remove = wilc_bus_remove,
 };
-module_spi_driver(wilc1000_spi_driver);
+module_spi_driver(wilc_spi_driver);
 MODULE_LICENSE("GPL");
 
+static int spi_data_rsp(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 len;
+	u8 rsp[3];
+	int result = N_OK;
+
+	if (!spi_priv->crc_off)
+		len = 2;
+	else
+		len = 3;
+
+	if (wilc_spi_rx(wilc, &rsp[0], len)) {
+		dev_err(&spi->dev, "Failed bus error...\n");
+		result = N_FAIL;
+		goto fail;
+	}
+
+	if ((rsp[len-1] != 0) || (rsp[len-2] != 0xC3)) {
+		dev_err(&spi->dev, "Failed data response read, %x %x %x\n",
+			rsp[0], rsp[1], rsp[2]);
+		result = N_FAIL;
+		goto fail;
+	}
+
+fail:
+	return result;
+}
+
 static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
@@ -280,23 +375,26 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 			    u8 clockless)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
 	u8 wb[32], rb[32];
 	u8 wix, rix;
 	u32 len2;
 	u8 rsp;
 	int len = 0;
 	int result = N_OK;
+	int retry;
+	u8 crc[2];
 
 	wb[0] = cmd;
 	switch (cmd) {
-	case CMD_SINGLE_READ:                           /* single word (4 bytes) read */
+	case CMD_SINGLE_READ: /* single word (4 bytes) read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
 		len = 5;
 		break;
 
-	case CMD_INTERNAL_READ:                 /* internal register read */
+	case CMD_INTERNAL_READ: /* internal register read */
 		wb[1] = (u8)(adr >> 8);
 		if (clockless == 1)
 			wb[1] |= BIT(7);
@@ -305,29 +403,29 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 5;
 		break;
 
-	case CMD_TERMINATE:                                     /* termination */
+	case CMD_TERMINATE:
 		wb[1] = 0x00;
 		wb[2] = 0x00;
 		wb[3] = 0x00;
 		len = 5;
 		break;
 
-	case CMD_REPEAT:                                                /* repeat */
+	case CMD_REPEAT:
 		wb[1] = 0x00;
 		wb[2] = 0x00;
 		wb[3] = 0x00;
 		len = 5;
 		break;
 
-	case CMD_RESET:                                                 /* reset */
+	case CMD_RESET:
 		wb[1] = 0xff;
 		wb[2] = 0xff;
 		wb[3] = 0xff;
 		len = 5;
 		break;
 
-	case CMD_DMA_WRITE:                                     /* dma write */
-	case CMD_DMA_READ:                                      /* dma read */
+	case CMD_DMA_WRITE: /* dma write */
+	case CMD_DMA_READ:  /* dma read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
@@ -336,8 +434,8 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 7;
 		break;
 
-	case CMD_DMA_EXT_WRITE:         /* dma extended write */
-	case CMD_DMA_EXT_READ:                  /* dma extended read */
+	case CMD_DMA_EXT_WRITE: /* dma extended write */
+	case CMD_DMA_EXT_READ:  /* dma extended read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
@@ -347,7 +445,7 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 8;
 		break;
 
-	case CMD_INTERNAL_WRITE:                /* internal register write */
+	case CMD_INTERNAL_WRITE: /* internal register write */
 		wb[1] = (u8)(adr >> 8);
 		if (clockless == 1)
 			wb[1] |= BIT(7);
@@ -359,7 +457,7 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 8;
 		break;
 
-	case CMD_SINGLE_WRITE:                  /* single word write */
+	case CMD_SINGLE_WRITE: /* single word write */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)(adr);
@@ -378,7 +476,7 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 	if (result != N_OK)
 		return result;
 
-	if (!g_spi.crc_off)
+	if (!spi_priv->crc_off)
 		wb[len - 1] = (crc7(0x7f, (const u8 *)&wb[0], len - 1)) << 1;
 	else
 		len -= 1;
@@ -389,18 +487,17 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 #define NUM_DATA_BYTES (4)
 #define NUM_CRC_BYTES (2)
 #define NUM_DUMMY_BYTES (3)
-	if ((cmd == CMD_RESET) ||
-	    (cmd == CMD_TERMINATE) ||
-	    (cmd == CMD_REPEAT)) {
+	if (cmd == CMD_RESET ||
+	    cmd == CMD_TERMINATE ||
+	    cmd == CMD_REPEAT) {
 		len2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);
-	} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
-		if (!g_spi.crc_off) {
-			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
-				      + NUM_CRC_BYTES + NUM_DUMMY_BYTES);
-		} else {
-			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
-				      + NUM_DUMMY_BYTES);
-		}
+	} else if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
+		int tmp = NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
+			+ NUM_DUMMY_BYTES;
+		if (!spi_priv->crc_off)
+			len2 = len + tmp + NUM_CRC_BYTES;
+		else
+			len2 = len + tmp;
 	} else {
 		len2 = len + (NUM_RSP_BYTES + NUM_DUMMY_BYTES);
 	}
@@ -421,19 +518,13 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	/**
+	/*
 	 * Command/Control response
-	 **/
-	if ((cmd == CMD_RESET) ||
-	    (cmd == CMD_TERMINATE) ||
-	    (cmd == CMD_REPEAT)) {
-		rix++;         /* skip 1 byte */
-	}
+	 */
+	if (cmd == CMD_RESET || cmd == CMD_TERMINATE || cmd == CMD_REPEAT)
+		rix++; /* skip 1 byte */
 
-	/* do { */
 	rsp = rb[rix++];
-	/*	if(rsp == cmd) break; */
-	/* } while(&rptr[1] <= &rb[len2]); */
 
 	if (rsp != cmd) {
 		dev_err(&spi->dev,
@@ -442,9 +533,9 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	/**
+	/*
 	 * State response
-	 **/
+	 */
 	rsp = rb[rix++];
 	if (rsp != 0x00) {
 		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
@@ -452,17 +543,17 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ) ||
-	    (cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
-		int retry;
-		/* u16 crc1, crc2; */
-		u8 crc[2];
-		/**
+	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ ||
+	    cmd == CMD_DMA_READ || cmd == CMD_DMA_EXT_READ) {
+		/*
 		 * Data Respnose header
-		 **/
-		retry = 100;
+		 */
+		retry = SPI_RESP_RETRY_COUNT;
 		do {
-			/* ensure there is room in buffer later to read data and crc */
+			/*
+			 * ensure there is room in buffer later
+			 * to read data and crc
+			 */
 			if (rix < len2) {
 				rsp = rb[rix++];
 			} else {
@@ -478,170 +569,167 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 				"Error, data read response (%02x)\n", rsp);
 			return N_RESET;
 		}
+	}
 
-		if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
-			/**
-			 * Read bytes
-			 **/
-			if ((rix + 3) < len2) {
-				b[0] = rb[rix++];
-				b[1] = rb[rix++];
-				b[2] = rb[rix++];
-				b[3] = rb[rix++];
+	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
+		/*
+		 * Read bytes
+		 */
+		if ((rix + 3) < len2) {
+			b[0] = rb[rix++];
+			b[1] = rb[rix++];
+			b[2] = rb[rix++];
+			b[3] = rb[rix++];
+		} else {
+			dev_err(&spi->dev,
+				"buffer overrun when reading data.\n");
+			return N_FAIL;
+		}
+
+		if (!spi_priv->crc_off) {
+			/*
+			 * Read Crc
+			 */
+			if ((rix + 1) < len2) {
+				crc[0] = rb[rix++];
+				crc[1] = rb[rix++];
 			} else {
 				dev_err(&spi->dev,
-					"buffer overrun when reading data.\n");
+					"buffer overrun when reading crc.\n");
 				return N_FAIL;
 			}
+		}
+	} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
+		int ix;
 
-			if (!g_spi.crc_off) {
-				/**
-				 * Read Crc
-				 **/
-				if ((rix + 1) < len2) {
-					crc[0] = rb[rix++];
-					crc[1] = rb[rix++];
-				} else {
-					dev_err(&spi->dev, "buffer overrun when reading crc.\n");
-					return N_FAIL;
-				}
-			}
-		} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
-			int ix;
-
-			/* some data may be read in response to dummy bytes. */
-			for (ix = 0; (rix < len2) && (ix < sz); )
-				b[ix++] = rb[rix++];
-
-			sz -= ix;
+		/* some data may be read in response to dummy bytes. */
+		for (ix = 0; (rix < len2) && (ix < sz); )
+			b[ix++] = rb[rix++];
 
-			if (sz > 0) {
-				int nbytes;
+		sz -= ix;
 
-				if (sz <= (DATA_PKT_SZ - ix))
-					nbytes = sz;
-				else
-					nbytes = DATA_PKT_SZ - ix;
+		if (sz > 0) {
+			int nbytes;
 
-				/**
-				 * Read bytes
-				 **/
-				if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-					dev_err(&spi->dev, "Failed data block read, bus error...\n");
-					result = N_FAIL;
-					goto _error_;
-				}
+			if (sz <= (DATA_PKT_SZ - ix))
+				nbytes = sz;
+			else
+				nbytes = DATA_PKT_SZ - ix;
 
-				/**
-				 * Read Crc
-				 **/
-				if (!g_spi.crc_off) {
-					if (wilc_spi_rx(wilc, crc, 2)) {
-						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
-						result = N_FAIL;
-						goto _error_;
-					}
-				}
+			/*
+			 * Read bytes
+			 */
+			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
+				dev_err(&spi->dev,
+					"Failed block read, bus err\n");
+				return N_FAIL;
+			}
 
-				ix += nbytes;
-				sz -= nbytes;
+			/*
+			 * Read Crc
+			 */
+			if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
+				dev_err(&spi->dev,
+					"Failed block crc read, bus err\n");
+				return N_FAIL;
 			}
 
-			/*  if any data in left unread, then read the rest using normal DMA code.*/
-			while (sz > 0) {
-				int nbytes;
-
-				if (sz <= DATA_PKT_SZ)
-					nbytes = sz;
-				else
-					nbytes = DATA_PKT_SZ;
-
-				/**
-				 * read data response only on the next DMA cycles not
-				 * the first DMA since data response header is already
-				 * handled above for the first DMA.
-				 **/
-				/**
-				 * Data Respnose header
-				 **/
-				retry = 10;
-				do {
-					if (wilc_spi_rx(wilc, &rsp, 1)) {
-						dev_err(&spi->dev, "Failed data response read, bus error...\n");
-						result = N_FAIL;
-						break;
-					}
-					if (((rsp >> 4) & 0xf) == 0xf)
-						break;
-				} while (retry--);
-
-				if (result == N_FAIL)
-					break;
+			ix += nbytes;
+			sz -= nbytes;
+		}
+
+		/*
+		 * if any data in left unread,
+		 * then read the rest using normal DMA code.
+		 */
+		while (sz > 0) {
+			int nbytes;
 
-				/**
-				 * Read bytes
-				 **/
-				if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-					dev_err(&spi->dev, "Failed data block read, bus error...\n");
+			if (sz <= DATA_PKT_SZ)
+				nbytes = sz;
+			else
+				nbytes = DATA_PKT_SZ;
+
+			/*
+			 * read data response only on the next DMA cycles not
+			 * the first DMA since data response header is already
+			 * handled above for the first DMA.
+			 */
+			/*
+			 * Data Respnose header
+			 */
+			retry = SPI_RESP_RETRY_COUNT;
+			do {
+				if (wilc_spi_rx(wilc, &rsp, 1)) {
+					dev_err(&spi->dev,
+						"Failed resp read, bus err\n");
 					result = N_FAIL;
 					break;
 				}
+				if (((rsp >> 4) & 0xf) == 0xf)
+					break;
+			} while (retry--);
 
-				/**
-				 * Read Crc
-				 **/
-				if (!g_spi.crc_off) {
-					if (wilc_spi_rx(wilc, crc, 2)) {
-						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
-						result = N_FAIL;
-						break;
-					}
-				}
+			if (result == N_FAIL)
+				break;
 
-				ix += nbytes;
-				sz -= nbytes;
+			/*
+			 * Read bytes
+			 */
+			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
+				dev_err(&spi->dev,
+					"Failed block read, bus err\n");
+				result = N_FAIL;
+				break;
+			}
+
+			/*
+			 * Read Crc
+			 */
+			if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
+				dev_err(&spi->dev,
+					"Failed block crc read, bus err\n");
+				result = N_FAIL;
+				break;
 			}
+
+			ix += nbytes;
+			sz -= nbytes;
 		}
 	}
-_error_:
 	return result;
 }
 
 static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
 	int ix, nbytes;
 	int result = 1;
 	u8 cmd, order, crc[2] = {0};
-	/* u8 rsp; */
 
-	/**
-	 *      Data
-	 **/
+	/*
+	 * Data
+	 */
 	ix = 0;
 	do {
-		if (sz <= DATA_PKT_SZ)
+		if (sz <= DATA_PKT_SZ) {
 			nbytes = sz;
-		else
+			order = 0x3;
+		} else {
 			nbytes = DATA_PKT_SZ;
-
-		/**
-		 *      Write command
-		 **/
-		cmd = 0xf0;
-		if (ix == 0) {
-			if (sz <= DATA_PKT_SZ)
-
-				order = 0x3;
-			else
+			if (ix == 0)
 				order = 0x1;
-		} else {
-			if (sz <= DATA_PKT_SZ)
-				order = 0x3;
 			else
-				order = 0x2;
+				order = 0x02;
 		}
+
+		/*
+		 * Write command
+		 */
+		cmd = 0xf0;
 		cmd |= order;
+
 		if (wilc_spi_tx(wilc, &cmd, 1)) {
 			dev_err(&spi->dev,
 				"Failed data block cmd write, bus error...\n");
@@ -649,9 +737,9 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			break;
 		}
 
-		/**
-		 *      Write data
-		 **/
+		/*
+		 * Write data
+		 */
 		if (wilc_spi_tx(wilc, &b[ix], nbytes)) {
 			dev_err(&spi->dev,
 				"Failed data block write, bus error...\n");
@@ -659,10 +747,10 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			break;
 		}
 
-		/**
-		 *      Write Crc
-		 **/
-		if (!g_spi.crc_off) {
+		/*
+		 * Write Crc
+		 */
+		if (!spi_priv->crc_off) {
 			if (wilc_spi_tx(wilc, crc, 2)) {
 				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
 				result = N_FAIL;
@@ -670,9 +758,9 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			}
 		}
 
-		/**
-		 *      No need to wait for response
-		 **/
+		/*
+		 * No need to wait for response
+		 */
 		ix += nbytes;
 		sz -= nbytes;
 	} while (sz);
@@ -690,31 +778,57 @@ static int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
-	dat = cpu_to_le32(dat);
+retry:
+	cpu_to_le32s(&dat);
 	result = spi_cmd_complete(wilc, CMD_INTERNAL_WRITE, adr, (u8 *)&dat, 4,
 				  0);
-	if (result != N_OK)
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed internal write cmd...\n");
+		goto fail;
+	}
 
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
 	return result;
 }
 
 static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
+	int result = N_OK;
+	u8 retry = SPI_RETRY_COUNT;
 
+retry:
 	result = spi_cmd_complete(wilc, CMD_INTERNAL_READ, adr, (u8 *)data, 4,
 				  0);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed internal read cmd...\n");
-		return 0;
+		goto fail;
 	}
 
-	*data = cpu_to_le32(*data);
+	le32_to_cpus(data);
 
-	return 1;
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -726,21 +840,39 @@ static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 static int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result = N_OK;
 	u8 cmd = CMD_SINGLE_WRITE;
 	u8 clockless = 0;
 
-	data = cpu_to_le32(data);
-	if (addr < 0x30) {
-		/* Clockless register*/
+	cpu_to_le32s(&data);
+_RETRY_:
+	if (addr <= 0x30) {
+		/* Clockless register */
 		cmd = CMD_INTERNAL_WRITE;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_WRITE;
+		clockless = 0;
 	}
 
 	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)&data, 4, clockless);
-	if (result != N_OK)
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
+		goto fail;
+	}
 
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, data);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto _RETRY_;
+	}
 	return result;
 }
 
@@ -748,72 +880,120 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
-	u8 cmd = CMD_DMA_EXT_WRITE;
+	u8 retry = SPI_RETRY_COUNT;
 
-	/**
-	 *      has to be greated than 4
-	 **/
+	/*
+	 * has to be greated than 4
+	 */
 	if (size <= 4)
 		return 0;
 
-	result = spi_cmd_complete(wilc, cmd, addr, NULL, size, 0);
+retry:
+	result = spi_cmd_complete(wilc, CMD_DMA_EXT_WRITE, addr, NULL, size, 0);
 	if (result != N_OK) {
 		dev_err(&spi->dev,
 			"Failed cmd, write block (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
-	/**
-	 *      Data
-	 **/
+	/*
+	 * Data
+	 */
 	result = spi_data_write(wilc, buf, size);
-	if (result != N_OK)
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
+	/*
+	 * Data RESP
+	 */
+	result = spi_data_rsp(wilc, CMD_DMA_EXT_WRITE);
+	if (result != N_OK) {
+		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
 
-	return 1;
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result = N_OK;
 	u8 cmd = CMD_SINGLE_READ;
 	u8 clockless = 0;
 
-	if (addr < 0x30) {
-		/* dev_err(&spi->dev, "***** read addr %d\n\n", addr); */
-		/* Clockless register*/
+retry:
+	if (addr <= 0x30) {
+		/* Clockless register */
 		cmd = CMD_INTERNAL_READ;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_READ;
+		clockless = 0;
 	}
 
 	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)data, 4, clockless);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
-	*data = cpu_to_le32(*data);
+	le32_to_cpus(data);
 
-	return 1;
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x\n", retry, addr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
-	u8 cmd = CMD_DMA_EXT_READ;
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
 	if (size <= 4)
 		return 0;
 
-	result = spi_cmd_complete(wilc, cmd, addr, buf, size, 0);
+retry:
+	result = spi_cmd_complete(wilc, CMD_DMA_EXT_READ, addr, buf, size, 0);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
-	return 1;
+fail:
+	if (result != N_OK) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x %d\n", retry, addr,
+			 size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -822,23 +1002,47 @@ static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
  *
  ********************************************/
 
+int wilc_spi_reset(struct wilc *wilc)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result = N_OK;
+
+	result = spi_cmd_complete(wilc, CMD_RESET, 0, 0, 0, 0);
+	if (result != N_OK) {
+		dev_err(&spi->dev, "Failed cmd reset\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static bool wilc_spi_is_init(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	return spi_priv->is_init;
+}
+
 static int _wilc_spi_deinit(struct wilc *wilc)
 {
-	/**
-	 *      TODO:
-	 **/
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	/*
+	 * TODO:
+	 */
+	spi_priv->is_init = false;
+
 	return 1;
 }
 
 static int wilc_spi_init(struct wilc *wilc, bool resume)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
 	u32 reg;
 	u32 chipid;
 
-	static int isinit;
-
-	if (isinit) {
+	if (spi_priv->is_init) {
 		if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
 			dev_err(&spi->dev, "Fail cmd read chip id...\n");
 			return 0;
@@ -846,214 +1050,109 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 		return 1;
 	}
 
-	memset(&g_spi, 0, sizeof(struct wilc_spi));
-
-	/**
-	 *      configure protocol
-	 **/
-	g_spi.crc_off = 0;
+	/*
+	 * configure protocol
+	 */
 
-	/* TODO: We can remove the CRC trials if there is a definite way to reset */
+	/*
+	 * TODO: We can remove the CRC trials if there is a definite
+	 * way to reset
+	 */
 	/* the SPI to it's initial value. */
 	if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-		/* Read failed. Try with CRC off. This might happen when module
+		/*
+		 * Read failed. Try with CRC off. This might happen when module
 		 * is removed but chip isn't reset
 		 */
-		g_spi.crc_off = 1;
-		dev_err(&spi->dev, "Failed internal read protocol with CRC on, retrying with CRC off...\n");
+		spi_priv->crc_off = 1;
+		dev_err(&spi->dev,
+			"Failed read with CRC on, retrying with CRC off\n");
 		if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-			/* Reaad failed with both CRC on and off, something went bad */
-			dev_err(&spi->dev,
-				"Failed internal read protocol...\n");
+			/*
+			 * Read failed with both CRC on and off,
+			 * something went bad
+			 */
+			dev_err(&spi->dev, "Failed internal read protocol...\n");
 			return 0;
 		}
 	}
-	if (g_spi.crc_off == 0)	{
-		reg &= ~0xc;    /* disable crc checking */
+	if (spi_priv->crc_off == 0) {
+		reg &= ~0xc; /* disable crc checking */
 		reg &= ~0x70;
 		reg |= (0x5 << 4);
 		if (!spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg)) {
-			dev_err(&spi->dev, "[wilc spi %d]: Failed internal write protocol reg...\n", __LINE__);
+			dev_err(&spi->dev,
+				"[wilc spi %d]: Failed internal write reg\n",
+				__LINE__);
 			return 0;
 		}
-		g_spi.crc_off = 1;
+		spi_priv->crc_off = 1;
 	}
 
-	/**
-	 *      make sure can read back chip id correctly
-	 **/
+	/*
+	 * make sure can read back chip id correctly
+	 */
 	if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
 		dev_err(&spi->dev, "Fail cmd read chip id...\n");
 		return 0;
 	}
-	/* dev_err(&spi->dev, "chipid (%08x)\n", chipid); */
 
-	g_spi.has_thrpt_enh = 1;
-
-	isinit = 1;
+	if (!resume) {
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+			goto pass;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+			goto pass;
+		} else {
+			dev_err(&spi->dev, "Unsupported chipid: %x\n", chipid);
+			goto fail;
+		}
+		dev_dbg(&spi->dev, "chipid %08x\n", chipid);
+	}
 
+pass:
+	spi_priv->is_init = true;
 	return 1;
+
+fail:
+	return 0;
 }
 
 static int wilc_spi_read_size(struct wilc *wilc, u32 *size)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
 
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					size);
-		*size = *size  & IRQ_DMA_WD_CNT_MASK;
-	} else {
-		u32 tmp;
-		u32 byte_cnt;
+	ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
+				size);
+	*size = *size  & IRQ_DMA_WD_CNT_MASK;
 
-		ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,
-					&byte_cnt);
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-			goto _fail_;
-		}
-		tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
-		*size = tmp;
-	}
-
-_fail_:
 	return ret;
 }
 
 static int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
-	u32 tmp;
-	u32 byte_cnt;
-	int happened, j;
-	u32 unknown_mask;
-	u32 irq_flags;
-
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					int_status);
-	} else {
-		ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,
-					&byte_cnt);
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-			goto _fail_;
-		}
-		tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
 
-		j = 0;
-		do {
-			happened = 0;
-
-			wilc_spi_read_reg(wilc, 0x1a90, &irq_flags);
-			tmp |= ((irq_flags >> 27) << IRG_FLAGS_OFFSET);
+	ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
+				int_status);
 
-			if (g_spi.nint > 5) {
-				wilc_spi_read_reg(wilc, 0x1a94,
-						  &irq_flags);
-				tmp |= (((irq_flags >> 0) & 0x7) << (IRG_FLAGS_OFFSET + 5));
-			}
-
-			unknown_mask = ~((1ul << g_spi.nint) - 1);
-
-			if ((tmp >> IRG_FLAGS_OFFSET) & unknown_mask) {
-				dev_err(&spi->dev, "Unexpected interrupt (2): j=%d, tmp=%x, mask=%x\n", j, tmp, unknown_mask);
-					happened = 1;
-			}
-
-			j++;
-		} while (happened);
-
-		*int_status = tmp;
-	}
-
-_fail_:
 	return ret;
 }
 
 static int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
 
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE,
-					 val);
-	} else {
-		u32 flags;
-
-		flags = val & (BIT(MAX_NUM_INT) - 1);
-		if (flags) {
-			int i;
-
-			ret = 1;
-			for (i = 0; i < g_spi.nint; i++) {
-				/* No matter what you write 1 or 0, it will clear interrupt. */
-				if (flags & 1)
-					ret = wilc_spi_write_reg(wilc, 0x10c8 + i * 4, 1);
-				if (!ret)
-					break;
-				flags >>= 1;
-			}
-			if (!ret) {
-				dev_err(&spi->dev,
-					"Failed wilc_spi_write_reg, set reg %x ...\n",
-					0x10c8 + i * 4);
-				goto _fail_;
-			}
-			for (i = g_spi.nint; i < MAX_NUM_INT; i++) {
-				if (flags & 1)
-					dev_err(&spi->dev,
-						"Unexpected interrupt cleared %d...\n",
-						i);
-				flags >>= 1;
-			}
-		}
-
-		{
-			u32 tbl_ctl;
-
-			tbl_ctl = 0;
-			/* select VMM table 0 */
-			if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				tbl_ctl |= BIT(0);
-			/* select VMM table 1 */
-			if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				tbl_ctl |= BIT(1);
-
-			ret = wilc_spi_write_reg(wilc, WILC_VMM_TBL_CTL,
-						 tbl_ctl);
-			if (!ret) {
-				dev_err(&spi->dev,
-					"fail write reg vmm_tbl_ctl...\n");
-				goto _fail_;
-			}
-
-			if ((val & EN_VMM) == EN_VMM) {
-				/**
-				 *      enable vmm transfer.
-				 **/
-				ret = wilc_spi_write_reg(wilc,
-							 WILC_VMM_CORE_CTL, 1);
-				if (!ret) {
-					dev_err(&spi->dev, "fail write reg vmm_core_ctl...\n");
-					goto _fail_;
-				}
-			}
-		}
-	}
-_fail_:
+	ret = spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE, val);
 	return ret;
 }
 
 static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
 	u32 reg;
 	int ret, i;
 
@@ -1062,11 +1161,11 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 		return 0;
 	}
 
-	g_spi.nint = nint;
+	spi_priv->nint = nint;
 
-	/**
-	 *      interrupt pin mux select
-	 **/
+	/*
+	 * interrupt pin mux select
+	 */
 	ret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);
 	if (!ret) {
 		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
@@ -1081,9 +1180,9 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 		return 0;
 	}
 
-	/**
-	 *      interrupt enable
-	 **/
+	/*
+	 * interrupt enable
+	 */
 	ret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);
 	if (!ret) {
 		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
@@ -1111,7 +1210,7 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 		for (i = 0; (i < 3) && (nint > 0); i++, nint--)
 			reg |= BIT(i);
 
-		ret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
+		ret = wilc_spi_write_reg(wilc, WILC_INTR2_ENABLE, reg);
 		if (!ret) {
 			dev_err(&spi->dev, "Failed write reg (%08x)...\n",
 				WILC_INTR2_ENABLE);
@@ -1136,4 +1235,6 @@ static const struct wilc_hif_func wilc_hif_spi = {
 	.hif_block_tx_ext = wilc_spi_write,
 	.hif_block_rx_ext = wilc_spi_read,
 	.hif_sync_ext = wilc_spi_sync_ext,
+	.hif_reset = wilc_spi_reset,
+	.hif_is_init = wilc_spi_is_init,
 };
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
index af12925a9d2b..2e249d96c480 100644
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
+++ b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
@@ -1,9 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/etherdevice.h>
+
 #include "wilc_wfi_cfgoperations.h"
-#include "host_interface.h"
-#include <linux/errno.h>
+#include "linux_wlan.h"
 
-#define NO_ENCRYPT		0
 #define ENCRYPT_ENABLED		BIT(0)
 #define WEP			BIT(1)
 #define WEP_EXTENDED		BIT(2)
@@ -12,7 +17,6 @@
 #define AES			BIT(5)
 #define TKIP			BIT(6)
 
-#define FRAME_TYPE_ID			0
 #define ACTION_CAT_ID			24
 #define ACTION_SUBTYPE_ID		25
 #define P2P_PUB_ACTION_SUBTYPE		30
@@ -79,23 +83,16 @@ static const struct wiphy_wowlan_support wowlan_support = {
 	.flags = WIPHY_WOWLAN_ANY
 };
 
-#define WILC_WFI_DWELL_PASSIVE 100
-#define WILC_WFI_DWELL_ACTIVE  40
-
-#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
-#define DEFAULT_LINK_SPEED			72
-
-#define IS_MANAGMEMENT				0x100
-#define IS_MANAGMEMENT_CALLBACK			0x080
-#define IS_MGMT_STATUS_SUCCES			0x040
-#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
-
-static struct network_info last_scanned_shadow[MAX_NUM_SCANNED_NETWORKS_SHADOW];
-static u32 last_scanned_cnt;
-struct timer_list wilc_during_ip_timer;
-static struct timer_list hAgingTimer;
-static u8 op_ifcs;
-
+#if KERNEL_VERSION(4, 7, 0) > LINUX_VERSION_CODE
+#define CHAN2G(_channel, _freq, _flags) {	 \
+		.band             = IEEE80211_BAND_2GHZ, \
+		.center_freq      = (_freq),		 \
+		.hw_value         = (_channel),		 \
+		.flags            = (_flags),		 \
+		.max_antenna_gain = 0,			 \
+		.max_power        = 30,			 \
+}
+#else
 #define CHAN2G(_channel, _freq, _flags) {	 \
 		.band             = NL80211_BAND_2GHZ, \
 		.center_freq      = (_freq),		 \
@@ -104,6 +101,7 @@ static u8 op_ifcs;
 		.max_antenna_gain = 0,			 \
 		.max_power        = 30,			 \
 }
+#endif
 
 static struct ieee80211_channel ieee80211_2ghz_channels[] = {
 	CHAN2G(1,  2412, 0),
@@ -151,54 +149,29 @@ struct p2p_mgmt_data {
 static u8 wlan_channel = INVALID_CHANNEL;
 static u8 curr_channel;
 static u8 p2p_oui[] = {0x50, 0x6f, 0x9A, 0x09};
-static u8 p2p_local_random = 0x01;
-static u8 p2p_recv_random;
 static u8 p2p_vendor_spec[] = {0xdd, 0x05, 0x00, 0x08, 0x40, 0x03};
-static bool wilc_ie;
 
-static struct ieee80211_supported_band WILC_WFI_band_2ghz = {
+static struct ieee80211_supported_band wilc_band_2ghz = {
 	.channels = ieee80211_2ghz_channels,
 	.n_channels = ARRAY_SIZE(ieee80211_2ghz_channels),
 	.bitrates = ieee80211_bitrates,
 	.n_bitrates = ARRAY_SIZE(ieee80211_bitrates),
 };
 
-struct add_key_params {
-	u8 key_idx;
-	bool pairwise;
-	u8 *mac_addr;
-};
-
-static struct add_key_params g_add_gtk_key_params;
-static struct wilc_wfi_key g_key_gtk_params;
-static struct add_key_params g_add_ptk_key_params;
-static struct wilc_wfi_key g_key_ptk_params;
-static struct wilc_wfi_wep_key g_key_wep_params;
-static bool g_ptk_keys_saved;
-static bool g_gtk_keys_saved;
-static bool g_wep_keys_saved;
-
 #define AGING_TIME	(9 * 1000)
-#define during_ip_time	15000
 
-static void clear_shadow_scan(void)
+void clear_shadow_scan(struct wilc_priv *priv)
 {
 	int i;
 
-	if (op_ifcs == 0) {
-		del_timer_sync(&hAgingTimer);
-
-		for (i = 0; i < last_scanned_cnt; i++) {
-			if (last_scanned_shadow[last_scanned_cnt].ies) {
-				kfree(last_scanned_shadow[i].ies);
-				last_scanned_shadow[last_scanned_cnt].ies = NULL;
-			}
+	for (i = 0; i < priv->scanned_cnt; i++) {
+		kfree(priv->scanned_shadow[i].ies);
+		priv->scanned_shadow[i].ies = NULL;
 
-			kfree(last_scanned_shadow[i].join_params);
-			last_scanned_shadow[i].join_params = NULL;
-		}
-		last_scanned_cnt = 0;
+		kfree(priv->scanned_shadow[i].join_params);
+		priv->scanned_shadow[i].join_params = NULL;
 	}
+	priv->scanned_cnt = 0;
 }
 
 static u32 get_rssi_avg(struct network_info *network_info)
@@ -220,25 +193,35 @@ static void refresh_scan(struct wilc_priv *priv, bool direct_scan)
 	struct wiphy *wiphy = priv->dev->ieee80211_ptr->wiphy;
 	int i;
 
-	for (i = 0; i < last_scanned_cnt; i++) {
+	for (i = 0; i < priv->scanned_cnt; i++) {
 		struct network_info *network_info;
 		s32 freq;
 		struct ieee80211_channel *channel;
 		int rssi;
 		struct cfg80211_bss *bss;
 
-		network_info = &last_scanned_shadow[i];
+		network_info = &priv->scanned_shadow[i];
+
+		if (!network_info)
+			continue;
 
 		if (!memcmp("DIRECT-", network_info->ssid, 7) && !direct_scan)
 			continue;
 
+	#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
 						      NL80211_BAND_2GHZ);
+	#else
+		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
+						      IEEE80211_BAND_2GHZ);
+	#endif
 		channel = ieee80211_get_channel(wiphy, freq);
 		rssi = get_rssi_avg(network_info);
 		bss = cfg80211_inform_bss(wiphy,
 					  channel,
+			#if KERNEL_VERSION(3, 18, 0) <= LINUX_VERSION_CODE
 					  CFG80211_BSS_FTYPE_UNKNOWN,
+			#endif
 					  network_info->bssid,
 					  network_info->tsf_hi,
 					  network_info->cap_info,
@@ -251,67 +234,89 @@ static void refresh_scan(struct wilc_priv *priv, bool direct_scan)
 	}
 }
 
-static void reset_shadow_found(void)
+static void reset_shadow_found(struct wilc_priv *priv)
 {
 	int i;
 
-	for (i = 0; i < last_scanned_cnt; i++)
-		last_scanned_shadow[i].found = 0;
+	for (i = 0; i < priv->scanned_cnt; i++)
+		priv->scanned_shadow[i].found = 0;
 }
 
-static void update_scan_time(void)
+static void update_scan_time(struct wilc_priv *priv)
 {
 	int i;
 
-	for (i = 0; i < last_scanned_cnt; i++)
-		last_scanned_shadow[i].time_scan = jiffies;
+	for (i = 0; i < priv->scanned_cnt; i++)
+		priv->scanned_shadow[i].time_scan = jiffies;
 }
 
-static void remove_network_from_shadow(unsigned long arg)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void remove_network_from_shadow(struct timer_list *t)
+#else
+void remove_network_from_shadow(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_priv *priv = from_timer(priv, t, aging_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)arg;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 	unsigned long now = jiffies;
 	int i, j;
 
-	for (i = 0; i < last_scanned_cnt; i++) {
-		if (time_after(now, last_scanned_shadow[i].time_scan +
-			       (unsigned long)(SCAN_RESULT_EXPIRE))) {
-			kfree(last_scanned_shadow[i].ies);
-			last_scanned_shadow[i].ies = NULL;
+	for (i = 0; i < priv->scanned_cnt; i++) {
+		if (!time_after(now, priv->scanned_shadow[i].time_scan +
+				(unsigned long)(SCAN_RESULT_EXPIRE)))
+			continue;
 
-			kfree(last_scanned_shadow[i].join_params);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Network expired in ScanShadow: %s\n",
+			   priv->scanned_shadow[i].ssid);
+		kfree(priv->scanned_shadow[i].ies);
+		priv->scanned_shadow[i].ies = NULL;
 
-			for (j = i; (j < last_scanned_cnt - 1); j++)
-				last_scanned_shadow[j] = last_scanned_shadow[j + 1];
+		kfree(priv->scanned_shadow[i].join_params);
 
-			last_scanned_cnt--;
-		}
-	}
+		for (j = i; (j < priv->scanned_cnt - 1); j++)
+			priv->scanned_shadow[j] = priv->scanned_shadow[j + 1];
 
-	if (last_scanned_cnt != 0) {
-		hAgingTimer.data = arg;
-		mod_timer(&hAgingTimer, jiffies + msecs_to_jiffies(AGING_TIME));
+		priv->scanned_cnt--;
 	}
-}
 
-static void clear_duringIP(unsigned long arg)
-{
-	wilc_optaining_ip = false;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Number of cached networks: %d\n",
+		   priv->scanned_cnt);
+
+	if (priv->scanned_cnt != 0) {
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		priv->aging_timer.data = (unsigned long) priv;
+	#endif
+		mod_timer(&priv->aging_timer,
+			  jiffies + msecs_to_jiffies(AGING_TIME));
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "No need to restart Aging timer\n");
+	}
 }
 
-static int is_network_in_shadow(struct network_info *pstrNetworkInfo,
-				void *user_void)
+static int is_network_in_shadow(struct network_info *nw_info,
+				struct wilc_priv *priv)
 {
 	int state = -1;
 	int i;
 
-	if (last_scanned_cnt == 0) {
-		hAgingTimer.data = (unsigned long)user_void;
-		mod_timer(&hAgingTimer, jiffies + msecs_to_jiffies(AGING_TIME));
+	if (priv->scanned_cnt == 0) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Starting Aging timer\n");
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		priv->aging_timer.data = (unsigned long) priv;
+	#endif
+		mod_timer(&priv->aging_timer,
+			  jiffies + msecs_to_jiffies(AGING_TIME));
 		state = -1;
 	} else {
-		for (i = 0; i < last_scanned_cnt; i++) {
-			if (memcmp(last_scanned_shadow[i].bssid,
-				   pstrNetworkInfo->bssid, 6) == 0) {
+		for (i = 0; i < priv->scanned_cnt; i++) {
+			if (memcmp(priv->scanned_shadow[i].bssid,
+				   nw_info->bssid, 6) == 0) {
 				state = i;
 				break;
 			}
@@ -320,244 +325,311 @@ static int is_network_in_shadow(struct network_info *pstrNetworkInfo,
 	return state;
 }
 
-static void add_network_to_shadow(struct network_info *pstrNetworkInfo,
-				  void *user_void, void *pJoinParams)
+static void add_network_to_shadow(struct network_info *nw_info,
+				  struct wilc_priv *priv, void *join_params)
 {
-	int ap_found = is_network_in_shadow(pstrNetworkInfo, user_void);
+	int ap_found = is_network_in_shadow(nw_info, priv);
 	u32 ap_index = 0;
 	u8 rssi_index = 0;
+	struct network_info *shadow_nw_info;
 
-	if (last_scanned_cnt >= MAX_NUM_SCANNED_NETWORKS_SHADOW)
+	if (priv->scanned_cnt >= MAX_NUM_SCANNED_NETWORKS_SHADOW) {
+		PRINT_INFO(priv->dev, CFG80211_DBG,
+			   "Shadow network reached its maximum limit\n");
 		return;
-
+	}
 	if (ap_found == -1) {
-		ap_index = last_scanned_cnt;
-		last_scanned_cnt++;
+		ap_index = priv->scanned_cnt;
+		priv->scanned_cnt++;
 	} else {
 		ap_index = ap_found;
 	}
-	rssi_index = last_scanned_shadow[ap_index].rssi_history.index;
-	last_scanned_shadow[ap_index].rssi_history.samples[rssi_index++] = pstrNetworkInfo->rssi;
+	shadow_nw_info = &priv->scanned_shadow[ap_index];
+	rssi_index = shadow_nw_info->rssi_history.index;
+	shadow_nw_info->rssi_history.samples[rssi_index++] = nw_info->rssi;
 	if (rssi_index == NUM_RSSI) {
 		rssi_index = 0;
-		last_scanned_shadow[ap_index].rssi_history.full = true;
-	}
-	last_scanned_shadow[ap_index].rssi_history.index = rssi_index;
-	last_scanned_shadow[ap_index].rssi = pstrNetworkInfo->rssi;
-	last_scanned_shadow[ap_index].cap_info = pstrNetworkInfo->cap_info;
-	last_scanned_shadow[ap_index].ssid_len = pstrNetworkInfo->ssid_len;
-	memcpy(last_scanned_shadow[ap_index].ssid,
-	       pstrNetworkInfo->ssid, pstrNetworkInfo->ssid_len);
-	memcpy(last_scanned_shadow[ap_index].bssid,
-	       pstrNetworkInfo->bssid, ETH_ALEN);
-	last_scanned_shadow[ap_index].beacon_period = pstrNetworkInfo->beacon_period;
-	last_scanned_shadow[ap_index].dtim_period = pstrNetworkInfo->dtim_period;
-	last_scanned_shadow[ap_index].ch = pstrNetworkInfo->ch;
-	last_scanned_shadow[ap_index].ies_len = pstrNetworkInfo->ies_len;
-	last_scanned_shadow[ap_index].tsf_hi = pstrNetworkInfo->tsf_hi;
+		shadow_nw_info->rssi_history.full = true;
+	}
+	shadow_nw_info->rssi_history.index = rssi_index;
+	shadow_nw_info->rssi = nw_info->rssi;
+	shadow_nw_info->cap_info = nw_info->cap_info;
+	shadow_nw_info->ssid_len = nw_info->ssid_len;
+	memcpy(shadow_nw_info->ssid, nw_info->ssid, nw_info->ssid_len);
+	memcpy(shadow_nw_info->bssid, nw_info->bssid, ETH_ALEN);
+	shadow_nw_info->beacon_period = nw_info->beacon_period;
+	shadow_nw_info->dtim_period = nw_info->dtim_period;
+	shadow_nw_info->ch = nw_info->ch;
+	shadow_nw_info->tsf_hi = nw_info->tsf_hi;
 	if (ap_found != -1)
-		kfree(last_scanned_shadow[ap_index].ies);
-	last_scanned_shadow[ap_index].ies = kmalloc(pstrNetworkInfo->ies_len,
-						    GFP_KERNEL);
-	memcpy(last_scanned_shadow[ap_index].ies,
-	       pstrNetworkInfo->ies, pstrNetworkInfo->ies_len);
-	last_scanned_shadow[ap_index].time_scan = jiffies;
-	last_scanned_shadow[ap_index].time_scan_cached = jiffies;
-	last_scanned_shadow[ap_index].found = 1;
+		kfree(shadow_nw_info->ies);
+	shadow_nw_info->ies = kmemdup(nw_info->ies, nw_info->ies_len,
+				      GFP_KERNEL);
+	if (shadow_nw_info->ies)
+		shadow_nw_info->ies_len = nw_info->ies_len;
+	else
+		shadow_nw_info->ies_len = 0;
+	shadow_nw_info->time_scan = jiffies;
+	shadow_nw_info->time_scan_cached = jiffies;
+	shadow_nw_info->found = 1;
 	if (ap_found != -1)
-		kfree(last_scanned_shadow[ap_index].join_params);
-	last_scanned_shadow[ap_index].join_params = pJoinParams;
+		kfree(shadow_nw_info->join_params);
+	shadow_nw_info->join_params = join_params;
 }
 
-static void CfgScanResult(enum scan_event scan_event,
-			  struct network_info *network_info,
-			  void *user_void,
-			  void *join_params)
+static void cfg_scan_result(enum scan_event scan_event,
+			    struct network_info *network_info,
+			    void *user_void, void *join_params)
 {
 	struct wilc_priv *priv;
 	struct wiphy *wiphy;
-	s32 s32Freq;
+	s32 freq;
 	struct ieee80211_channel *channel;
 	struct cfg80211_bss *bss = NULL;
 
 	priv = user_void;
-	if (priv->bCfgScanning) {
-		if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
-			wiphy = priv->dev->ieee80211_ptr->wiphy;
+	if (!priv->cfg_scanning)
+		return;
 
-			if (!wiphy)
-				return;
+	if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
+		wiphy = priv->dev->ieee80211_ptr->wiphy;
 
-			if (wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&
-			    (((s32)network_info->rssi * 100) < 0 ||
-			    ((s32)network_info->rssi * 100) > 100))
-				return;
+		if (!wiphy || !network_info)
+			return;
 
-			if (network_info) {
-				s32Freq = ieee80211_channel_to_frequency((s32)network_info->ch, NL80211_BAND_2GHZ);
-				channel = ieee80211_get_channel(wiphy, s32Freq);
-
-				if (!channel)
-					return;
-
-				if (network_info->new_network) {
-					if (priv->u32RcvdChCount < MAX_NUM_SCANNED_NETWORKS) {
-						priv->u32RcvdChCount++;
-
-						add_network_to_shadow(network_info, priv, join_params);
-
-						if (!(memcmp("DIRECT-", network_info->ssid, 7))) {
-							bss = cfg80211_inform_bss(wiphy,
-										  channel,
-										  CFG80211_BSS_FTYPE_UNKNOWN,
-										  network_info->bssid,
-										  network_info->tsf_hi,
-										  network_info->cap_info,
-										  network_info->beacon_period,
-										  (const u8 *)network_info->ies,
-										  (size_t)network_info->ies_len,
-										  (s32)network_info->rssi * 100,
-										  GFP_KERNEL);
-							cfg80211_put_bss(wiphy, bss);
-						}
-					}
-				} else {
-					u32 i;
-
-					for (i = 0; i < priv->u32RcvdChCount; i++) {
-						if (memcmp(last_scanned_shadow[i].bssid, network_info->bssid, 6) == 0) {
-							last_scanned_shadow[i].rssi = network_info->rssi;
-							last_scanned_shadow[i].time_scan = jiffies;
-							break;
-						}
-					}
-				}
+		if (wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&
+		    (((s32)network_info->rssi * 100) < 0 ||
+		    ((s32)network_info->rssi * 100) > 100))
+			return;
+
+		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
+						      NL80211_BAND_2GHZ);
+		channel = ieee80211_get_channel(wiphy, freq);
+
+		if (!channel)
+			return;
+		PRINT_D(priv->dev, CFG80211_DBG,
+			"Network Info:: CHANNEL Frequency: %d, RSSI: %d, CapabilityInfo: %d, BeaconPeriod: %d\n",
+			channel->center_freq,
+			((s32)network_info->rssi * 100),
+			network_info->cap_info,
+			network_info->beacon_period);
+
+		if (network_info->new_network) {
+			if (priv->rcvd_ch_cnt >= MAX_NUM_SCANNED_NETWORKS) {
+				PRINT_ER(priv->dev,
+					 "Discovered networks exceeded the max limit\n");
+				return;
 			}
-		} else if (scan_event == SCAN_EVENT_DONE) {
-			refresh_scan(priv, false);
 
-			mutex_lock(&priv->scan_req_lock);
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				    "Network %s found\n",
+				    network_info->ssid);
+			priv->rcvd_ch_cnt++;
+
+			add_network_to_shadow(network_info, priv, join_params);
+
+			if (memcmp("DIRECT-", network_info->ssid, 7))
+				return;
 
-			if (priv->pstrScanReq) {
-				struct cfg80211_scan_info info = {
-					.aborted = false,
-				};
+			bss = cfg80211_inform_bss(wiphy,
+						  channel,
+			#if KERNEL_VERSION(3, 18, 0) <= LINUX_VERSION_CODE
+						  CFG80211_BSS_FTYPE_UNKNOWN,
+			#endif
+						  network_info->bssid,
+						  network_info->tsf_hi,
+						  network_info->cap_info,
+						  network_info->beacon_period,
+						  (const u8 *)network_info->ies,
+						  (size_t)network_info->ies_len,
+						  (s32)network_info->rssi * 100,
+						  GFP_KERNEL);
+			cfg80211_put_bss(wiphy, bss);
+		} else {
+			u32 i;
 
-				cfg80211_scan_done(priv->pstrScanReq, &info);
-				priv->u32RcvdChCount = 0;
-				priv->bCfgScanning = false;
-				priv->pstrScanReq = NULL;
+			for (i = 0; i < priv->rcvd_ch_cnt; i++) {
+				if (memcmp(priv->scanned_shadow[i].bssid,
+					   network_info->bssid, 6) == 0)
+					break;
 			}
-			mutex_unlock(&priv->scan_req_lock);
-		} else if (scan_event == SCAN_EVENT_ABORTED) {
-			mutex_lock(&priv->scan_req_lock);
 
-			if (priv->pstrScanReq) {
-				struct cfg80211_scan_info info = {
-					.aborted = false,
-				};
+			if (i >= priv->rcvd_ch_cnt)
+				return;
 
-				update_scan_time();
-				refresh_scan(priv, false);
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "Update RSSI of %s\n",
+				   priv->scanned_shadow[i].ssid);
+			priv->scanned_shadow[i].rssi = network_info->rssi;
+			priv->scanned_shadow[i].time_scan = jiffies;
+		}
+	} else if (scan_event == SCAN_EVENT_DONE) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Done[%p]\n",
+			   priv->dev);
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Refreshing Scan ...\n");
+		refresh_scan(priv, false);
+
+		if (priv->rcvd_ch_cnt > 0)
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "%d Network(s) found\n", priv->rcvd_ch_cnt);
+		else
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "No networks found\n");
+		mutex_lock(&priv->scan_req_lock);
+
+		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			struct cfg80211_scan_info info = {
+				.aborted = false,
+			};
+
+			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
+			priv->rcvd_ch_cnt = 0;
+			priv->cfg_scanning = false;
+			priv->scan_req = NULL;
+		}
+		mutex_unlock(&priv->scan_req_lock);
+	} else if (scan_event == SCAN_EVENT_ABORTED) {
+		mutex_lock(&priv->scan_req_lock);
+
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Aborted\n");
+		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			struct cfg80211_scan_info info = {
+				.aborted = false,
+			};
+			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
 
-				cfg80211_scan_done(priv->pstrScanReq, &info);
-				priv->bCfgScanning = false;
-				priv->pstrScanReq = NULL;
-			}
-			mutex_unlock(&priv->scan_req_lock);
+			update_scan_time(priv);
+			refresh_scan(priv, false);
+			priv->cfg_scanning = false;
+			priv->scan_req = NULL;
 		}
+		mutex_unlock(&priv->scan_req_lock);
 	}
 }
 
-int wilc_connecting;
-
-static void CfgConnectResult(enum conn_event enuConnDisconnEvent,
-			     struct connect_info *pstrConnectInfo,
-			     u8 u8MacStatus,
-			     struct disconnect_info *pstrDisconnectNotifInfo,
-			     void *pUserVoid)
+static inline bool cfg_scan_time_expired(struct wilc_priv *priv, int i)
 {
-	struct wilc_priv *priv;
-	struct net_device *dev;
-	struct host_if_drv *pstrWFIDrv;
-	u8 NullBssid[ETH_ALEN] = {0};
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	wilc_connecting = 0;
-
-	priv = pUserVoid;
-	dev = priv->dev;
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-
-	if (enuConnDisconnEvent == CONN_DISCONN_EVENT_CONN_RESP) {
-		u16 u16ConnectStatus;
+	unsigned long now = jiffies;
 
-		u16ConnectStatus = pstrConnectInfo->status;
+	if (time_after(now, priv->scanned_shadow[i].time_scan_cached +
+		       (unsigned long)(nl80211_SCAN_RESULT_EXPIRE - (1 * HZ))))
+		return true;
+	else
+		return false;
+}
 
-		if ((u8MacStatus == MAC_DISCONNECTED) &&
-		    (pstrConnectInfo->status == SUCCESSFUL_STATUSCODE)) {
-			u16ConnectStatus = WLAN_STATUS_UNSPECIFIED_FAILURE;
-			wilc_wlan_set_bssid(priv->dev, NullBssid,
+static void cfg_connect_result(enum conn_event conn_disconn_evt,
+			       struct connect_info *conn_info,
+			       u8 mac_status,
+			       struct disconnect_info *disconn_info,
+			       void *priv_data)
+{
+	struct wilc_priv *priv = priv_data;
+	struct net_device *dev = priv->dev;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+	struct host_if_drv *wfi_drv = priv->hif_drv;
+	u8 null_bssid[ETH_ALEN] = {0};
+
+	vif->connecting = false;
+
+	if (conn_disconn_evt == EVENT_CONN_RESP) {
+		u16 connect_status;
+
+		connect_status = conn_info->status;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connection response received = %d\n",
+			   mac_status);
+		if (mac_status == MAC_STATUS_DISCONNECTED &&
+		    conn_info->status == WLAN_STATUS_SUCCESS) {
+			connect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			wilc_wlan_set_bssid(priv->dev, null_bssid,
 					    STATION_MODE);
-			eth_zero_addr(wilc_connected_ssid);
 
-			if (!pstrWFIDrv->p2p_connect)
+			if (!wfi_drv->p2p_connect)
 				wlan_channel = INVALID_CHANNEL;
 
-			netdev_err(dev, "Unspecified failure\n");
+			PRINT_ER(dev, "Unspecified failure\n");
 		}
 
-		if (u16ConnectStatus == WLAN_STATUS_SUCCESS) {
-			bool bNeedScanRefresh = false;
+		if (connect_status == WLAN_STATUS_SUCCESS) {
+			bool scan_refresh = false;
 			u32 i;
 
-			memcpy(priv->au8AssociatedBss, pstrConnectInfo->bssid, ETH_ALEN);
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"Connection Successful: BSSID: %x%x%x%x%x%x\n",
+				conn_info->bssid[0], conn_info->bssid[1],
+				conn_info->bssid[2], conn_info->bssid[3],
+				conn_info->bssid[4], conn_info->bssid[5]);
+			memcpy(priv->associated_bss, conn_info->bssid,
+			       ETH_ALEN);
 
-			for (i = 0; i < last_scanned_cnt; i++) {
-				if (memcmp(last_scanned_shadow[i].bssid,
-					   pstrConnectInfo->bssid,
+			for (i = 0; i < priv->scanned_cnt; i++) {
+				if (memcmp(priv->scanned_shadow[i].bssid,
+					   conn_info->bssid,
 					   ETH_ALEN) == 0) {
-					unsigned long now = jiffies;
-
-					if (time_after(now,
-						       last_scanned_shadow[i].time_scan_cached +
-						       (unsigned long)(nl80211_SCAN_RESULT_EXPIRE - (1 * HZ))))
-						bNeedScanRefresh = true;
+					if (cfg_scan_time_expired(priv, i))
+						scan_refresh = true;
 
 					break;
 				}
 			}
 
-			if (bNeedScanRefresh)
+			if (scan_refresh)
 				refresh_scan(priv, true);
 		}
 
-		cfg80211_connect_result(dev, pstrConnectInfo->bssid,
-					pstrConnectInfo->req_ies, pstrConnectInfo->req_ies_len,
-					pstrConnectInfo->resp_ies, pstrConnectInfo->resp_ies_len,
-					u16ConnectStatus, GFP_KERNEL);
-	} else if (enuConnDisconnEvent == CONN_DISCONN_EVENT_DISCONN_NOTIF)    {
-		wilc_optaining_ip = false;
-		p2p_local_random = 0x01;
-		p2p_recv_random = 0x00;
-		wilc_ie = false;
-		eth_zero_addr(priv->au8AssociatedBss);
-		wilc_wlan_set_bssid(priv->dev, NullBssid, STATION_MODE);
-		eth_zero_addr(wilc_connected_ssid);
-
-		if (!pstrWFIDrv->p2p_connect)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association request info elements length = %d\n",
+			   conn_info->req_ies_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association response info elements length = %d\n",
+			   conn_info->resp_ies_len);
+		cfg80211_connect_result(dev, conn_info->bssid,
+					conn_info->req_ies,
+					conn_info->req_ies_len,
+					conn_info->resp_ies,
+					conn_info->resp_ies_len, connect_status,
+					GFP_KERNEL);
+	} else if (conn_disconn_evt == EVENT_DISCONN_NOTIF) {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		vif->obtaining_ip = false;
+#endif
+		PRINT_ER(vif->ndev,
+			 "Received MAC_STATUS_DISCONNECTED from firmware with reason %d on dev [%p]\n",
+			 disconn_info->reason, priv->dev);
+		priv->p2p.local_random = 0x01;
+		priv->p2p.recv_random = 0x00;
+		priv->p2p.is_wilc_ie = false;
+		eth_zero_addr(priv->associated_bss);
+		wilc_wlan_set_bssid(priv->dev, null_bssid, STATION_MODE);
+
+		if (!wfi_drv->p2p_connect)
 			wlan_channel = INVALID_CHANNEL;
-		if ((pstrWFIDrv->IFC_UP) && (dev == wl->vif[1]->ndev))
-			pstrDisconnectNotifInfo->reason = 3;
-		else if ((!pstrWFIDrv->IFC_UP) && (dev == wl->vif[1]->ndev))
-			pstrDisconnectNotifInfo->reason = 1;
-
-		cfg80211_disconnected(dev, pstrDisconnectNotifInfo->reason, pstrDisconnectNotifInfo->ie,
-				      pstrDisconnectNotifInfo->ie_len, false,
+		if (wfi_drv->ifc_up && dev == wl->vif[1]->ndev)
+			disconn_info->reason = 3;
+		else if (!wfi_drv->ifc_up && dev == wl->vif[1]->ndev)
+			disconn_info->reason = 1;
+
+#if KERNEL_VERSION(4, 2, 0) > LINUX_VERSION_CODE
+		cfg80211_disconnected(dev, disconn_info->reason,
+				      disconn_info->ie, disconn_info->ie_len,
 				      GFP_KERNEL);
+#else
+		cfg80211_disconnected(dev, disconn_info->reason,
+				      disconn_info->ie, disconn_info->ie_len,
+				      false, GFP_KERNEL);
+#endif
 	}
 }
 
@@ -565,291 +637,442 @@ static int set_channel(struct wiphy *wiphy,
 		       struct cfg80211_chan_def *chandef)
 {
 	u32 channelnum = 0;
-	struct wilc_priv *priv;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 	int result = 0;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
 
 	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting channel %d with frequency %d\n",
+		   channelnum, chandef->chan->center_freq);
 
 	curr_channel = channelnum;
 	result = wilc_set_mac_chnl_num(vif, channelnum);
 
 	if (result != 0)
-		netdev_err(priv->dev, "Error in setting channel\n");
+		PRINT_ER(priv->dev, "Error in setting channel %d\n",
+			 channelnum);
 
 	return result;
 }
 
+static inline int wilc_wfi_cfg_alloc_fill_ssid(struct wilc_vif *vif,
+			     struct cfg80211_scan_request *request,
+			     struct hidden_network *ntwk)
+{
+	int i;
+	int slot_id = 0;
+
+	ntwk->net_info = kcalloc(request->n_ssids, sizeof(*ntwk->net_info),
+				 GFP_KERNEL);
+	if (!ntwk->net_info)
+		goto out;
+
+	ntwk->n_ssids = request->n_ssids;
+
+	for (i = 0; i < request->n_ssids; i++) {
+		if (request->ssids[i].ssid_len > 0) {
+			struct hidden_net_info *info = &ntwk->net_info[slot_id];
+
+			info->ssid = kmemdup(request->ssids[i].ssid,
+					     request->ssids[i].ssid_len,
+					     GFP_KERNEL);
+			if (!info->ssid)
+				goto out_free;
+
+			info->ssid_len = request->ssids[i].ssid_len;
+			slot_id++;
+		} else {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Received one NULL SSID\n");
+			ntwk->n_ssids -= 1;
+		}
+	}
+	return 0;
+
+out_free:
+
+	for (i = 0; i < slot_id; i++)
+		kfree(ntwk->net_info[i].ssid);
+
+	kfree(ntwk->net_info);
+out:
+
+	return -ENOMEM;
+}
+
 static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 {
-	struct wilc_priv *priv;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 	u32 i;
-	s32 s32Error = 0;
-	u8 au8ScanChanList[MAX_NUM_SCANNED_NETWORKS];
-	struct hidden_network strHiddenNetwork;
-	struct wilc_vif *vif;
+	s32 ret = 0;
+	u8 scan_ch_list[MAX_NUM_SCANNED_NETWORKS];
+	struct hidden_network hidden_ntwk;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	priv->scan_req = request;
 
-	priv->pstrScanReq = request;
+	priv->rcvd_ch_cnt = 0;
 
-	priv->u32RcvdChCount = 0;
+	reset_shadow_found(priv);
 
-	reset_shadow_found();
+	priv->cfg_scanning = true;
+	if (request->n_channels > MAX_NUM_SCANNED_NETWORKS) {
+		PRINT_ER(priv->dev, "Requested scanned channels over\n");
+		return -EINVAL;
+	}
 
-	priv->bCfgScanning = true;
-	if (request->n_channels <= MAX_NUM_SCANNED_NETWORKS) {
-		for (i = 0; i < request->n_channels; i++)
-			au8ScanChanList[i] = (u8)ieee80211_frequency_to_channel(request->channels[i]->center_freq);
+	for (i = 0; i < request->n_channels; i++) {
+		u16 freq = request->channels[i]->center_freq;
 
-		if (request->n_ssids >= 1) {
-			strHiddenNetwork.net_info =
-				kmalloc_array(request->n_ssids,
-					      sizeof(struct hidden_network),
-					      GFP_KERNEL);
-			if (!strHiddenNetwork.net_info)
-				return -ENOMEM;
-			strHiddenNetwork.n_ssids = request->n_ssids;
-
-			for (i = 0; i < request->n_ssids; i++) {
-				if (request->ssids[i].ssid_len != 0) {
-					strHiddenNetwork.net_info[i].ssid = kmalloc(request->ssids[i].ssid_len, GFP_KERNEL);
-					memcpy(strHiddenNetwork.net_info[i].ssid, request->ssids[i].ssid, request->ssids[i].ssid_len);
-					strHiddenNetwork.net_info[i].ssid_len = request->ssids[i].ssid_len;
-				} else {
-					strHiddenNetwork.n_ssids -= 1;
-				}
-			}
-			s32Error = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
-					     au8ScanChanList,
-					     request->n_channels,
-					     (const u8 *)request->ie,
-					     request->ie_len, CfgScanResult,
-					     (void *)priv, &strHiddenNetwork);
-		} else {
-			s32Error = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
-					     au8ScanChanList,
-					     request->n_channels,
-					     (const u8 *)request->ie,
-					     request->ie_len, CfgScanResult,
-					     (void *)priv, NULL);
-		}
+		scan_ch_list[i] = (u8)ieee80211_frequency_to_channel(freq);
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"ScanChannel List[%d] = %d",
+			i, scan_ch_list[i]);
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Requested num of channel %d\n",
+		   request->n_channels);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Scan Request IE len =  %d\n",
+		   request->ie_len);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Number of SSIDs %d\n",
+		   request->n_ssids);
+	if (request->n_ssids >= 1) {
+		if (wilc_wfi_cfg_alloc_fill_ssid(vif, request,
+						 &hidden_ntwk))
+			return -ENOMEM;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Trigger Scan Request\n");
+		ret = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
+				scan_ch_list,
+				request->n_channels,
+				(const u8 *)request->ie,
+				request->ie_len, cfg_scan_result,
+				(void *)priv, &hidden_ntwk);
 	} else {
-		netdev_err(priv->dev, "Requested scanned channels over\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Trigger Scan Request\n");
+		ret = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
+				scan_ch_list,
+				request->n_channels,
+				(const u8 *)request->ie,
+				request->ie_len, cfg_scan_result,
+				(void *)priv, NULL);
 	}
 
-	if (s32Error != 0)
-		s32Error = -EBUSY;
+	if (ret != 0) {
+		ret = -EBUSY;
+		PRINT_WRN(vif->ndev, CFG80211_DBG,
+			  "Device is busy: Error(%d)\n", ret);
+	}
 
-	return s32Error;
+	return ret;
 }
 
 static int connect(struct wiphy *wiphy, struct net_device *dev,
 		   struct cfg80211_connect_params *sme)
 {
-	s32 s32Error = 0;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	struct host_if_drv *wfi_drv = priv->hif_drv;
+	struct network_info *nw_info;
+	int ret;
 	u32 i;
 	u32 sel_bssi_idx = UINT_MAX;
-	u8 u8security = NO_ENCRYPT;
-	enum AUTHTYPE tenuAuth_type = ANY;
-
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	struct network_info *pstrNetworkInfo = NULL;
-	struct wilc_vif *vif;
+	u8 security = NO_ENCRYPT;
+	enum authtype auth_type = ANY;
+	u32 cipher_group;
+
+	vif->connecting = true;
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Connecting to SSID [%s] on netdev [%p] host if [%x]\n",
+		   sme->ssid, dev, (u32)priv->hif_drv);
+	if (!(strncmp(sme->ssid, "DIRECT-", 7))) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connected to Direct network,OBSS disabled\n");
+		wfi_drv->p2p_connect = 1;
+	} else {
+		wfi_drv->p2p_connect = 0;
+	}
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required SSID= %s\n, AuthType= %d\n",
+		sme->ssid, sme->auth_type);
 
-	wilc_connecting = 1;
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
+	for (i = 0; i < priv->scanned_cnt; i++) {
+		if (sme->ssid_len != priv->scanned_shadow[i].ssid_len ||
+		    memcmp(priv->scanned_shadow[i].ssid, sme->ssid,
+			   sme->ssid_len))
+			continue;
 
-	if (!(strncmp(sme->ssid, "DIRECT-", 7)))
-		pstrWFIDrv->p2p_connect = 1;
-	else
-		pstrWFIDrv->p2p_connect = 0;
-
-	for (i = 0; i < last_scanned_cnt; i++) {
-		if ((sme->ssid_len == last_scanned_shadow[i].ssid_len) &&
-		    memcmp(last_scanned_shadow[i].ssid,
-			   sme->ssid,
-			   sme->ssid_len) == 0) {
-			if (!sme->bssid) {
-				if (sel_bssi_idx == UINT_MAX ||
-				    last_scanned_shadow[i].rssi >
-				    last_scanned_shadow[sel_bssi_idx].rssi)
-					sel_bssi_idx = i;
-			} else {
-				if (memcmp(last_scanned_shadow[i].bssid,
-					   sme->bssid,
-					   ETH_ALEN) == 0) {
-					sel_bssi_idx = i;
-					break;
-				}
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"Network with required SSID is found %s\n",
+			sme->ssid);
+		if (!sme->bssid) {
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"BSSID is not passed from the user\n");
+			if (sel_bssi_idx == UINT_MAX ||
+			    get_rssi_avg(&priv->scanned_shadow[i]) >
+			    get_rssi_avg(&priv->scanned_shadow[sel_bssi_idx]))
+				sel_bssi_idx = i;
+		} else {
+			if (memcmp(priv->scanned_shadow[i].bssid,
+				   sme->bssid,
+				   ETH_ALEN) == 0) {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"BSSID is passed from the user and matched\n");
+				sel_bssi_idx = i;
+				break;
 			}
 		}
 	}
 
-	if (sel_bssi_idx < last_scanned_cnt) {
-		pstrNetworkInfo = &last_scanned_shadow[sel_bssi_idx];
+	if (sel_bssi_idx < priv->scanned_cnt) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Required bss is in scan results\n");
+		nw_info = &priv->scanned_shadow[sel_bssi_idx];
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"network BSSID to be associated: %x%x%x%x%x%x\n",
+			nw_info->bssid[0], nw_info->bssid[1],
+			nw_info->bssid[2], nw_info->bssid[3],
+			nw_info->bssid[4], nw_info->bssid[5]);
 	} else {
-		s32Error = -ENOENT;
-		wilc_connecting = 0;
-		return s32Error;
+		ret = -ENOENT;
+		vif->connecting = false;
+		if (priv->scanned_cnt == 0)
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "No Scan results yet\n");
+		else
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Required bss not in scan results: Error(%d)\n",
+				   ret);
+		goto out_error;
 	}
 
-	memset(priv->WILC_WFI_wep_key, 0, sizeof(priv->WILC_WFI_wep_key));
-	memset(priv->WILC_WFI_wep_key_len, 0, sizeof(priv->WILC_WFI_wep_key_len));
-
-	if (sme->crypto.cipher_group != NO_ENCRYPT) {
-		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) {
-			u8security = ENCRYPT_ENABLED | WEP;
-
-			priv->WILC_WFI_wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->WILC_WFI_wep_key[sme->key_idx], sme->key, sme->key_len);
+	if (ether_addr_equal_unaligned(vif->bssid, nw_info->bssid)) {
+		ret = -EALREADY;
+		goto out_error;
+	}
 
-			g_key_wep_params.key_len = sme->key_len;
-			g_key_wep_params.key = kmalloc(sme->key_len, GFP_KERNEL);
-			memcpy(g_key_wep_params.key, sme->key, sme->key_len);
-			g_key_wep_params.key_idx = sme->key_idx;
-			g_wep_keys_saved = true;
+	memset(priv->wep_key, 0, sizeof(priv->wep_key));
+	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.wpa_versions=%x\n",
+		sme->crypto.wpa_versions);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.cipher_group=%x\n",
+		sme->crypto.cipher_group);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.n_ciphers_pairwise=%d\n",
+		sme->crypto.n_ciphers_pairwise);
+	for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)
+		PRINT_D(vif->ndev, CORECONFIG_DBG,
+			"sme->crypto.ciphers_pairwise[%d]=%x\n", i,
+			sme->crypto.ciphers_pairwise[i]);
+
+	cipher_group = sme->crypto.cipher_group;
+	if (cipher_group != NO_ENCRYPT) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   ">> sme->crypto.wpa_versions: %x\n",
+			   sme->crypto.wpa_versions);
+		if (cipher_group == WLAN_CIPHER_SUITE_WEP40) {
+			security = ENCRYPT_ENABLED | WEP;
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"WEP Default Key Idx = %d\n", sme->key_idx);
+
+			for (i = 0; i < sme->key_len; i++)
+				PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"WEP Key Value[%d] = %d\n", i, sme->key[i]);
+
+			priv->wep_key_len[sme->key_idx] = sme->key_len;
+			memcpy(priv->wep_key[sme->key_idx], sme->key,
+			       sme->key_len);
 
 			wilc_set_wep_default_keyid(vif, sme->key_idx);
 			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
 						 sme->key_idx);
-		} else if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104)   {
-			u8security = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
+		} else if (cipher_group == WLAN_CIPHER_SUITE_WEP104) {
+			security = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
 
-			priv->WILC_WFI_wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->WILC_WFI_wep_key[sme->key_idx], sme->key, sme->key_len);
-
-			g_key_wep_params.key_len = sme->key_len;
-			g_key_wep_params.key = kmalloc(sme->key_len, GFP_KERNEL);
-			memcpy(g_key_wep_params.key, sme->key, sme->key_len);
-			g_key_wep_params.key_idx = sme->key_idx;
-			g_wep_keys_saved = true;
+			priv->wep_key_len[sme->key_idx] = sme->key_len;
+			memcpy(priv->wep_key[sme->key_idx], sme->key,
+			       sme->key_len);
 
 			wilc_set_wep_default_keyid(vif, sme->key_idx);
 			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
 						 sme->key_idx);
-		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)   {
-			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
-				u8security = ENCRYPT_ENABLED | WPA2 | TKIP;
+		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
+			if (cipher_group == WLAN_CIPHER_SUITE_TKIP)
+				security = ENCRYPT_ENABLED | WPA2 | TKIP;
 			else
-				u8security = ENCRYPT_ENABLED | WPA2 | AES;
-		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)   {
-			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
-				u8security = ENCRYPT_ENABLED | WPA | TKIP;
+				security = ENCRYPT_ENABLED | WPA2 | AES;
+		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) {
+			if (cipher_group == WLAN_CIPHER_SUITE_TKIP)
+				security = ENCRYPT_ENABLED | WPA | TKIP;
 			else
-				u8security = ENCRYPT_ENABLED | WPA | AES;
+				security = ENCRYPT_ENABLED | WPA | AES;
 		} else {
-			s32Error = -ENOTSUPP;
-			netdev_err(dev, "Not supported cipher\n");
-			wilc_connecting = 0;
-			return s32Error;
+			ret = -ENOTSUPP;
+			PRINT_ER(dev, "Unsupported cipher\n");
+			goto out_error;
 		}
 	}
 
 	if ((sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) ||
 	    (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {
 		for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++) {
-			if (sme->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP)
-				u8security = u8security | TKIP;
+			u32 ciphers_pairwise = sme->crypto.ciphers_pairwise[i];
+
+			if (ciphers_pairwise == WLAN_CIPHER_SUITE_TKIP)
+				security = security | TKIP;
 			else
-				u8security = u8security | AES;
+				security = security | AES;
 		}
 	}
 
-	switch (sme->auth_type)	{
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding key with cipher group %x\n",
+		   cipher_group);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Authentication Type = %d\n",
+		   sme->auth_type);
+	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-		tenuAuth_type = OPEN_SYSTEM;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In OPEN SYSTEM\n");
+		auth_type = OPEN_SYSTEM;
 		break;
 
 	case NL80211_AUTHTYPE_SHARED_KEY:
-		tenuAuth_type = SHARED_KEY;
+		auth_type = SHARED_KEY;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In SHARED KEY\n");
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Automatic Authentication type= %d\n",
+			   sme->auth_type);
 		break;
 	}
 
 	if (sme->crypto.n_akm_suites) {
-		switch (sme->crypto.akm_suites[0]) {
-		case WLAN_AKM_SUITE_8021X:
-			tenuAuth_type = IEEE8021;
-			break;
-
-		default:
-			break;
-		}
+		if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X)
+			auth_type = IEEE8021;
 	}
 
-	curr_channel = pstrNetworkInfo->ch;
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required Channel = %d\n",
+		nw_info->ch);
+	curr_channel = nw_info->ch;
 
-	if (!pstrWFIDrv->p2p_connect)
-		wlan_channel = pstrNetworkInfo->ch;
+	if (!wfi_drv->p2p_connect)
+		wlan_channel = nw_info->ch;
 
-	wilc_wlan_set_bssid(dev, pstrNetworkInfo->bssid, STATION_MODE);
+	wilc_wlan_set_bssid(dev, nw_info->bssid, STATION_MODE);
 
-	s32Error = wilc_set_join_req(vif, pstrNetworkInfo->bssid, sme->ssid,
-				     sme->ssid_len, sme->ie, sme->ie_len,
-				     CfgConnectResult, (void *)priv,
-				     u8security, tenuAuth_type,
-				     pstrNetworkInfo->ch,
-				     pstrNetworkInfo->join_params);
-	if (s32Error != 0) {
-		netdev_err(dev, "wilc_set_join_req(): Error\n");
-		s32Error = -ENOENT;
-		wilc_connecting = 0;
-		return s32Error;
+	ret = wilc_set_join_req(vif, nw_info->bssid, sme->ssid,
+				sme->ssid_len, sme->ie, sme->ie_len,
+				cfg_connect_result, (void *)priv,
+				security, auth_type,
+				nw_info->ch,
+				nw_info->join_params);
+	if (ret) {
+		u8 null_bssid[ETH_ALEN] = {0};
+
+		PRINT_ER(dev, "wilc_set_join_req(): Error(%d)\n", ret);
+		ret = -ENOENT;
+		wilc_wlan_set_bssid(dev, null_bssid, STATION_MODE);
+		goto out_error;
 	}
 
-	return s32Error;
+out_error:
+	vif->connecting = false;
+	return ret;
 }
 
-static int disconnect(struct wiphy *wiphy, struct net_device *dev, u16 reason_code)
+static int disconnect(struct wiphy *wiphy, struct net_device *dev,
+		      u16 reason_code)
 {
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	u8 NullBssid[ETH_ALEN] = {0};
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	struct wilc *wilc = vif->wilc;
+	struct host_if_drv *wfi_drv;
+	int ret;
+	u8 null_bssid[ETH_ALEN] = {0};
 
-	wilc_connecting = 0;
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	wilc = vif->wilc;
+	vif->connecting = false;
 
 	if (!wilc)
 		return -EIO;
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+	if (!wfi_drv->p2p_connect)
+		wlan_channel = INVALID_CHANNEL;
+	wilc_wlan_set_bssid(priv->dev, null_bssid, STATION_MODE);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Disconnecting with reason code(%d)\n", reason_code);
+	priv->p2p.local_random = 0x01;
+	priv->p2p.recv_random = 0x00;
+	priv->p2p.is_wilc_ie = false;
+	wfi_drv->p2p_timeout = 0;
+
+	ret = wilc_disconnect(vif, reason_code);
+	if (ret != 0) {
+		PRINT_ER(priv->dev, "Error in disconnecting (%d)\n", ret);
+		ret = -EINVAL;
+	}
 
-	if (wilc->close) {
-		/* already disconnected done */
-		cfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);
-		return 0;
+	return ret;
+}
+
+static inline void wilc_wfi_cfg_copy_wep_info(struct wilc_priv *priv,
+					      u8 key_index,
+					      struct key_params *params)
+{
+	priv->wep_key_len[key_index] = params->key_len;
+	memcpy(priv->wep_key[key_index], params->key, params->key_len);
+}
+
+static int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)
+{
+	if (!priv->wilc_gtk[idx]) {
+		priv->wilc_gtk[idx] = kzalloc(sizeof(*priv->wilc_gtk[idx]),
+					      GFP_KERNEL);
+		if (!priv->wilc_gtk[idx])
+			return -ENOMEM;
 	}
 
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-	if (!pstrWFIDrv->p2p_connect)
-		wlan_channel = INVALID_CHANNEL;
-	wilc_wlan_set_bssid(priv->dev, NullBssid, STATION_MODE);
+	if (!priv->wilc_ptk[idx]) {
+		priv->wilc_ptk[idx] = kzalloc(sizeof(*priv->wilc_ptk[idx]),
+					      GFP_KERNEL);
+		if (!priv->wilc_ptk[idx])
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,
+				      struct key_params *params)
+{
+	kfree(key_info->key);
+
+	key_info->key = kmemdup(params->key, params->key_len, GFP_KERNEL);
+	if (!key_info->key)
+		return -ENOMEM;
 
-	p2p_local_random = 0x01;
-	p2p_recv_random = 0x00;
-	wilc_ie = false;
-	pstrWFIDrv->p2p_timeout = 0;
+	kfree(key_info->seq);
 
-	s32Error = wilc_disconnect(vif, reason_code);
-	if (s32Error != 0) {
-		netdev_err(priv->dev, "Error in disconnecting\n");
-		s32Error = -EINVAL;
+	if (params->seq_len > 0) {
+		key_info->seq = kmemdup(params->seq, params->seq_len,
+					GFP_KERNEL);
+		if (!key_info->seq)
+			return -ENOMEM;
 	}
 
-	return s32Error;
+	key_info->cipher = params->cipher;
+	key_info->key_len = params->key_len;
+	key_info->seq_len = params->seq_len;
+
+	return 0;
 }
 
 static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
@@ -857,210 +1080,140 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 		   const u8 *mac_addr, struct key_params *params)
 
 {
-	s32 s32Error = 0, KeyLen = params->key_len;
-	struct wilc_priv *priv;
-	const u8 *pu8RxMic = NULL;
-	const u8 *pu8TxMic = NULL;
-	u8 u8mode = NO_ENCRYPT;
-	u8 u8gmode = NO_ENCRYPT;
-	u8 u8pmode = NO_ENCRYPT;
-	enum AUTHTYPE tenuAuth_type = ANY;
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(netdev);
-	wl = vif->wilc;
-
-	switch (params->cipher)	{
+	int ret = 0, keylen = params->key_len;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	const u8 *rx_mic = NULL;
+	const u8 *tx_mic = NULL;
+	u8 mode = NO_ENCRYPT;
+	u8 op_mode;
+	int i;
+	struct wilc_vif *vif = netdev_priv(netdev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Adding key with cipher suite = %x\n", params->cipher);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "%x %x %d\n", (u32)wiphy,
+		   (u32)netdev, key_index);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "key %x %x %x\n", params->key[0],
+		   params->key[1],
+		   params->key[2]);
+	switch (params->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
 		if (priv->wdev->iftype == NL80211_IFTYPE_AP) {
-			priv->WILC_WFI_wep_key_len[key_index] = params->key_len;
-			memcpy(priv->WILC_WFI_wep_key[key_index], params->key, params->key_len);
+			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
 
-			tenuAuth_type = OPEN_SYSTEM;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Key len= %d\n",
+				   params->key_len);
+
+			for (i = 0; i < params->key_len; i++)
+				PRINT_INFO(vif->ndev, CFG80211_DBG,
+					   "WEP AP key val[%d] = %x\n", i,
+					   params->key[i]);
 
 			if (params->cipher == WLAN_CIPHER_SUITE_WEP40)
-				u8mode = ENCRYPT_ENABLED | WEP;
+				mode = ENCRYPT_ENABLED | WEP;
 			else
-				u8mode = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
+				mode = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
 
-			wilc_add_wep_key_bss_ap(vif, params->key,
-						params->key_len, key_index,
-						u8mode, tenuAuth_type);
+			ret = wilc_add_wep_key_bss_ap(vif, params->key,
+						      params->key_len,
+						      key_index, mode,
+						      OPEN_SYSTEM);
 			break;
 		}
-		if (memcmp(params->key, priv->WILC_WFI_wep_key[key_index], params->key_len)) {
-			priv->WILC_WFI_wep_key_len[key_index] = params->key_len;
-			memcpy(priv->WILC_WFI_wep_key[key_index], params->key, params->key_len);
-
-			wilc_add_wep_key_bss_sta(vif, params->key,
-						 params->key_len, key_index);
+		if (memcmp(params->key, priv->wep_key[key_index],
+			   params->key_len)) {
+			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
+
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Key length = %d\n",
+				   params->key_len);
+			ret = wilc_add_wep_key_bss_sta(vif, params->key,
+						       params->key_len,
+						       key_index);
 		}
 
 		break;
 
 	case WLAN_CIPHER_SUITE_TKIP:
 	case WLAN_CIPHER_SUITE_CCMP:
-		if (priv->wdev->iftype == NL80211_IFTYPE_AP || priv->wdev->iftype == NL80211_IFTYPE_P2P_GO) {
-			if (!priv->wilc_gtk[key_index]) {
-				priv->wilc_gtk[key_index] = kmalloc(sizeof(struct wilc_wfi_key), GFP_KERNEL);
-				priv->wilc_gtk[key_index]->key = NULL;
-				priv->wilc_gtk[key_index]->seq = NULL;
-			}
-			if (!priv->wilc_ptk[key_index]) {
-				priv->wilc_ptk[key_index] = kmalloc(sizeof(struct wilc_wfi_key), GFP_KERNEL);
-				priv->wilc_ptk[key_index]->key = NULL;
-				priv->wilc_ptk[key_index]->seq = NULL;
+		if (priv->wdev->iftype == NL80211_IFTYPE_AP ||
+		    priv->wdev->iftype == NL80211_IFTYPE_P2P_GO) {
+			struct wilc_wfi_key *key;
+
+			ret = wilc_wfi_cfg_allocate_wpa_entry(priv, key_index);
+			if (ret)
+				return -ENOMEM;
+
+			if (params->key_len > 16 &&
+			    params->cipher == WLAN_CIPHER_SUITE_TKIP) {
+				tx_mic = params->key + 24;
+				rx_mic = params->key + 16;
+				keylen = params->key_len - 16;
 			}
 
 			if (!pairwise) {
 				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
-					u8gmode = ENCRYPT_ENABLED | WPA | TKIP;
+					mode = ENCRYPT_ENABLED | WPA | TKIP;
 				else
-					u8gmode = ENCRYPT_ENABLED | WPA2 | AES;
+					mode = ENCRYPT_ENABLED | WPA2 | AES;
 
-				priv->wilc_groupkey = u8gmode;
-
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8TxMic = params->key + 24;
-					pu8RxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-				kfree(priv->wilc_gtk[key_index]->key);
-
-				priv->wilc_gtk[key_index]->key = kmalloc(params->key_len, GFP_KERNEL);
-				memcpy(priv->wilc_gtk[key_index]->key, params->key, params->key_len);
-				kfree(priv->wilc_gtk[key_index]->seq);
-
-				if ((params->seq_len) > 0) {
-					priv->wilc_gtk[key_index]->seq = kmalloc(params->seq_len, GFP_KERNEL);
-					memcpy(priv->wilc_gtk[key_index]->seq, params->seq, params->seq_len);
-				}
-
-				priv->wilc_gtk[key_index]->cipher = params->cipher;
-				priv->wilc_gtk[key_index]->key_len = params->key_len;
-				priv->wilc_gtk[key_index]->seq_len = params->seq_len;
-
-				wilc_add_rx_gtk(vif, params->key, KeyLen,
-						key_index, params->seq_len,
-						params->seq, pu8RxMic,
-						pu8TxMic, AP_MODE, u8gmode);
+				priv->wilc_groupkey = mode;
 
+				key = priv->wilc_gtk[key_index];
 			} else {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"STA Address: %x%x%x%x%x\n",
+					mac_addr[0], mac_addr[1], mac_addr[2],
+					mac_addr[3], mac_addr[4]);
 				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
-					u8pmode = ENCRYPT_ENABLED | WPA | TKIP;
+					mode = ENCRYPT_ENABLED | WPA | TKIP;
 				else
-					u8pmode = priv->wilc_groupkey | AES;
-
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8TxMic = params->key + 24;
-					pu8RxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-
-				kfree(priv->wilc_ptk[key_index]->key);
-
-				priv->wilc_ptk[key_index]->key = kmalloc(params->key_len, GFP_KERNEL);
-
-				kfree(priv->wilc_ptk[key_index]->seq);
-
-				if ((params->seq_len) > 0)
-					priv->wilc_ptk[key_index]->seq = kmalloc(params->seq_len, GFP_KERNEL);
-
-				memcpy(priv->wilc_ptk[key_index]->key, params->key, params->key_len);
-
-				if ((params->seq_len) > 0)
-					memcpy(priv->wilc_ptk[key_index]->seq, params->seq, params->seq_len);
-
-				priv->wilc_ptk[key_index]->cipher = params->cipher;
-				priv->wilc_ptk[key_index]->key_len = params->key_len;
-				priv->wilc_ptk[key_index]->seq_len = params->seq_len;
+					mode = priv->wilc_groupkey | AES;
 
-				wilc_add_ptk(vif, params->key, KeyLen,
-					     mac_addr, pu8RxMic, pu8TxMic,
-					     AP_MODE, u8pmode, key_index);
+				key = priv->wilc_ptk[key_index];
 			}
-			break;
-		}
-
-		{
-			u8mode = 0;
-			if (!pairwise) {
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8RxMic = params->key + 24;
-					pu8TxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
+			ret = wilc_wfi_cfg_copy_wpa_info(key, params);
+			if (ret)
+				return -ENOMEM;
 
-				if (!g_gtk_keys_saved && netdev == wl->vif[0]->ndev) {
-					g_add_gtk_key_params.key_idx = key_index;
-					g_add_gtk_key_params.pairwise = pairwise;
-					if (!mac_addr) {
-						g_add_gtk_key_params.mac_addr = NULL;
-					} else {
-						g_add_gtk_key_params.mac_addr = kmalloc(ETH_ALEN, GFP_KERNEL);
-						memcpy(g_add_gtk_key_params.mac_addr, mac_addr, ETH_ALEN);
-					}
-					g_key_gtk_params.key_len = params->key_len;
-					g_key_gtk_params.seq_len = params->seq_len;
-					g_key_gtk_params.key =  kmalloc(params->key_len, GFP_KERNEL);
-					memcpy(g_key_gtk_params.key, params->key, params->key_len);
-					if (params->seq_len > 0) {
-						g_key_gtk_params.seq =  kmalloc(params->seq_len, GFP_KERNEL);
-						memcpy(g_key_gtk_params.seq, params->seq, params->seq_len);
-					}
-					g_key_gtk_params.cipher = params->cipher;
-					g_gtk_keys_saved = true;
-				}
+			op_mode = AP_MODE;
+		} else {
+			if (params->key_len > 16 &&
+			    params->cipher == WLAN_CIPHER_SUITE_TKIP) {
+				rx_mic = params->key + 24;
+				tx_mic = params->key + 16;
+				keylen = params->key_len - 16;
+			}
 
-				wilc_add_rx_gtk(vif, params->key, KeyLen,
-						key_index, params->seq_len,
-						params->seq, pu8RxMic,
-						pu8TxMic, STATION_MODE,
-						u8mode);
-			} else {
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8RxMic = params->key + 24;
-					pu8TxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
+			op_mode = STATION_MODE;
+		}
 
-				if (!g_ptk_keys_saved && netdev == wl->vif[0]->ndev) {
-					g_add_ptk_key_params.key_idx = key_index;
-					g_add_ptk_key_params.pairwise = pairwise;
-					if (!mac_addr) {
-						g_add_ptk_key_params.mac_addr = NULL;
-					} else {
-						g_add_ptk_key_params.mac_addr = kmalloc(ETH_ALEN, GFP_KERNEL);
-						memcpy(g_add_ptk_key_params.mac_addr, mac_addr, ETH_ALEN);
-					}
-					g_key_ptk_params.key_len = params->key_len;
-					g_key_ptk_params.seq_len = params->seq_len;
-					g_key_ptk_params.key =  kmalloc(params->key_len, GFP_KERNEL);
-					memcpy(g_key_ptk_params.key, params->key, params->key_len);
-					if (params->seq_len > 0) {
-						g_key_ptk_params.seq =  kmalloc(params->seq_len, GFP_KERNEL);
-						memcpy(g_key_ptk_params.seq, params->seq, params->seq_len);
-					}
-					g_key_ptk_params.cipher = params->cipher;
-					g_ptk_keys_saved = true;
-				}
+		if (!pairwise)
+			ret = wilc_add_rx_gtk(vif, params->key, keylen,
+					      key_index, params->seq_len,
+					      params->seq, rx_mic, tx_mic,
+					      op_mode, mode);
+		else
+			ret = wilc_add_ptk(vif, params->key, keylen, mac_addr,
+					   rx_mic, tx_mic, op_mode, mode,
+					   key_index);
 
-				wilc_add_ptk(vif, params->key, KeyLen,
-					     mac_addr, pu8RxMic, pu8TxMic,
-					     STATION_MODE, u8mode, key_index);
-			}
-		}
 		break;
 
 	default:
-		netdev_err(netdev, "Not supported cipher\n");
-		s32Error = -ENOTSUPP;
+		PRINT_ER(netdev, "Unsupported cipher\n");
+		ret = -ENOTSUPP;
 	}
 
-	return s32Error;
+	return ret;
 }
 
 static int del_key(struct wiphy *wiphy, struct net_device *netdev,
@@ -1068,23 +1221,13 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 		   bool pairwise,
 		   const u8 *mac_addr)
 {
-	struct wilc_priv *priv;
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(netdev);
-	wl = vif->wilc;
+	int ret = 0;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(netdev);
+	struct wilc *wl = vif->wilc;
 
 	if (netdev == wl->vif[0]->ndev) {
-		g_ptk_keys_saved = false;
-		g_gtk_keys_saved = false;
-		g_wep_keys_saved = false;
-
-		kfree(g_key_wep_params.key);
-		g_key_wep_params.key = NULL;
-
-		if ((priv->wilc_gtk[key_index]) != NULL) {
+		if (priv->wilc_gtk[key_index]) {
 			kfree(priv->wilc_gtk[key_index]->key);
 			priv->wilc_gtk[key_index]->key = NULL;
 			kfree(priv->wilc_gtk[key_index]->seq);
@@ -1094,7 +1237,7 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 			priv->wilc_gtk[key_index] = NULL;
 		}
 
-		if ((priv->wilc_ptk[key_index]) != NULL) {
+		if (priv->wilc_ptk[key_index]) {
 			kfree(priv->wilc_ptk[key_index]->key);
 			priv->wilc_ptk[key_index]->key = NULL;
 			kfree(priv->wilc_ptk[key_index]->seq);
@@ -1102,49 +1245,39 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 			kfree(priv->wilc_ptk[key_index]);
 			priv->wilc_ptk[key_index] = NULL;
 		}
-
-		kfree(g_key_ptk_params.key);
-		g_key_ptk_params.key = NULL;
-		kfree(g_key_ptk_params.seq);
-		g_key_ptk_params.seq = NULL;
-
-		kfree(g_key_gtk_params.key);
-		g_key_gtk_params.key = NULL;
-		kfree(g_key_gtk_params.seq);
-		g_key_gtk_params.seq = NULL;
-
 	}
 
-	if (key_index >= 0 && key_index <= 3) {
-		if (priv->WILC_WFI_wep_key_len[key_index]) {
-			memset(priv->WILC_WFI_wep_key[key_index], 0,
-			       priv->WILC_WFI_wep_key_len[key_index]);
-			priv->WILC_WFI_wep_key_len[key_index] = 0;
-			wilc_remove_wep_key(vif, key_index);
-		}
-	} else {
-		wilc_remove_key(priv->hif_drv, mac_addr);
+	if (key_index <= 3 && priv->wep_key_len[key_index]) {
+		memset(priv->wep_key[key_index], 0,
+		       priv->wep_key_len[key_index]);
+		priv->wep_key_len[key_index] = 0;
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Removing WEP key with index = %d\n",
+			   key_index);
+		ret = wilc_remove_wep_key(vif, key_index);
 	}
 
-	return 0;
+	return ret;
 }
 
 static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-		   bool pairwise,
-		   const u8 *mac_addr, void *cookie, void (*callback)(void *cookie, struct key_params *))
+		   bool pairwise, const u8 *mac_addr, void *cookie,
+		   void (*callback)(void *cookie, struct key_params *))
 {
-	struct wilc_priv *priv;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
 	struct  key_params key_params;
-
-	priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(netdev);
 
 	if (!pairwise) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Getting group key idx: %x\n", key_index);
 		key_params.key = priv->wilc_gtk[key_index]->key;
 		key_params.cipher = priv->wilc_gtk[key_index]->cipher;
 		key_params.key_len = priv->wilc_gtk[key_index]->key_len;
 		key_params.seq = priv->wilc_gtk[key_index]->seq;
 		key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
 	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting pairwise key\n");
 		key_params.key = priv->wilc_ptk[key_index]->key;
 		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
 		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
@@ -1157,73 +1290,97 @@ static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 	return 0;
 }
 
-static int set_default_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-			   bool unicast, bool multicast)
+static int set_default_key(struct wiphy *wiphy, struct net_device *netdev,
+			   u8 key_index, bool unicast, bool multicast)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
 	wilc_set_wep_default_keyid(vif, key_index);
 
 	return 0;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int get_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_info *sinfo)
+#else
+static int get_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_info *sinfo)
+#endif
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 	u32 i = 0;
 	u32 associatedsta = ~0;
 	u32 inactive_time = 0;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-
 	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Getting station parameters\n");
 		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
-			if (!(memcmp(mac, priv->assoc_stainfo.au8Sta_AssociatedBss[i], ETH_ALEN))) {
+			if (!(memcmp(mac,
+				     priv->assoc_stainfo.sta_associated_bss[i],
+				     ETH_ALEN))) {
 				associatedsta = i;
 				break;
 			}
 		}
 
 		if (associatedsta == ~0) {
-			netdev_err(dev, "sta required is not associated\n");
+			PRINT_ER(dev, "sta required is not associated\n");
 			return -ENOENT;
 		}
 
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 		sinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME);
+#else
+		sinfo->filled |= STATION_INFO_INACTIVE_TIME;
+#endif
 
 		wilc_get_inactive_time(vif, mac, &inactive_time);
 		sinfo->inactive_time = 1000 * inactive_time;
-	}
-
-	if (vif->iftype == STATION_MODE) {
-		struct rf_info strStatistics;
-
-		wilc_get_statistics(vif, &strStatistics);
-
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Inactive time %d\n",
+			   sinfo->inactive_time);
+	} else if (vif->iftype == STATION_MODE) {
+		struct rf_info stats;
+
+		if (!wilc->initialized) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "driver not initialized\n");
+			return -EBUSY;
+		}
+		wilc_get_statistics(vif, &stats, true);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) |
-						BIT(NL80211_STA_INFO_RX_PACKETS) |
-						BIT(NL80211_STA_INFO_TX_PACKETS) |
-						BIT(NL80211_STA_INFO_TX_FAILED) |
-						BIT(NL80211_STA_INFO_TX_BITRATE);
-
-		sinfo->signal = strStatistics.rssi;
-		sinfo->rx_packets = strStatistics.rx_cnt;
-		sinfo->tx_packets = strStatistics.tx_cnt + strStatistics.tx_fail_cnt;
-		sinfo->tx_failed = strStatistics.tx_fail_cnt;
-		sinfo->txrate.legacy = strStatistics.link_speed * 10;
-
-		if ((strStatistics.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH) &&
-		    (strStatistics.link_speed != DEFAULT_LINK_SPEED))
-			wilc_enable_tcp_ack_filter(true);
-		else if (strStatistics.link_speed != DEFAULT_LINK_SPEED)
-			wilc_enable_tcp_ack_filter(false);
+			      BIT(NL80211_STA_INFO_RX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_FAILED) |
+			      BIT(NL80211_STA_INFO_TX_BITRATE);
+#else
+		sinfo->filled |= STATION_INFO_SIGNAL |
+			      STATION_INFO_RX_PACKETS |
+			      STATION_INFO_TX_PACKETS |
+			      STATION_INFO_TX_FAILED |
+			      STATION_INFO_TX_BITRATE;
+#endif
+		sinfo->signal = stats.rssi;
+		sinfo->rx_packets = stats.rx_cnt;
+		sinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;
+		sinfo->tx_failed = stats.tx_fail_cnt;
+		sinfo->txrate.legacy = stats.link_speed * 10;
+
+		if (stats.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
+		    stats.link_speed != DEFAULT_LINK_SPEED)
+			wilc_enable_tcp_ack_filter(vif, true);
+		else if (stats.link_speed != DEFAULT_LINK_SPEED)
+			wilc_enable_tcp_ack_filter(vif, false);
+
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "*** stats[%d][%d][%d][%d][%d]\n", sinfo->signal,
+			   sinfo->rx_packets, sinfo->tx_packets,
+			   sinfo->tx_failed, sinfo->txrate.legacy);
 	}
 	return 0;
 }
@@ -1231,65 +1388,94 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 static int change_bss(struct wiphy *wiphy, struct net_device *dev,
 		      struct bss_parameters *params)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Changing Bss parametrs\n");
 	return 0;
 }
 
 static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
-	s32 s32Error = 0;
-	struct cfg_param_attr pstrCfgParamVal;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	int ret;
+	struct cfg_param_attr cfg_param_val;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	pstrCfgParamVal.flag = 0;
+	cfg_param_val.flag = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting Wiphy params\n");
 
 	if (changed & WIPHY_PARAM_RETRY_SHORT) {
-		pstrCfgParamVal.flag  |= RETRY_SHORT;
-		pstrCfgParamVal.short_retry_limit = priv->dev->ieee80211_ptr->wiphy->retry_short;
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_RETRY_SHORT %d\n",
+			   wiphy->retry_short);
+		cfg_param_val.flag  |= RETRY_SHORT;
+		cfg_param_val.short_retry_limit = wiphy->retry_short;
 	}
 	if (changed & WIPHY_PARAM_RETRY_LONG) {
-		pstrCfgParamVal.flag |= RETRY_LONG;
-		pstrCfgParamVal.long_retry_limit = priv->dev->ieee80211_ptr->wiphy->retry_long;
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_RETRY_LONG %d\n",
+			   wiphy->retry_long);
+		cfg_param_val.flag |= RETRY_LONG;
+		cfg_param_val.long_retry_limit = wiphy->retry_long;
 	}
 	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
-		pstrCfgParamVal.flag |= FRAG_THRESHOLD;
-		pstrCfgParamVal.frag_threshold = priv->dev->ieee80211_ptr->wiphy->frag_threshold;
+		if (wiphy->frag_threshold > 255 &&
+		    wiphy->frag_threshold < 7937) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Setting WIPHY_PARAM_FRAG_THRESHOLD %d\n",
+				   wiphy->frag_threshold);
+			cfg_param_val.flag |= FRAG_THRESHOLD;
+			cfg_param_val.frag_threshold = wiphy->frag_threshold;
+		} else {
+			PRINT_ER(vif->ndev,
+				 "Fragmentation threshold out of range\n");
+			return -EINVAL;
+		}
 	}
 
 	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
-		pstrCfgParamVal.flag |= RTS_THRESHOLD;
-		pstrCfgParamVal.rts_threshold = priv->dev->ieee80211_ptr->wiphy->rts_threshold;
-	}
+		if (wiphy->rts_threshold > 255) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Setting WIPHY_PARAM_RTS_THRESHOLD %d\n",
+				   wiphy->rts_threshold);
+			cfg_param_val.flag |= RTS_THRESHOLD;
+			cfg_param_val.rts_threshold = wiphy->rts_threshold;
+		} else {
+			PRINT_ER(vif->ndev, "RTS threshold out of range\n");
+			return -EINVAL;
+		}
+	}
 
-	s32Error = wilc_hif_set_cfg(vif, &pstrCfgParamVal);
-	if (s32Error)
-		netdev_err(priv->dev, "Error in setting WIPHY PARAMS\n");
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting CFG params in the host interface\n");
+	ret = wilc_hif_set_cfg(vif, &cfg_param_val);
+	if (ret)
+		PRINT_ER(priv->dev, "Error in setting WIPHY PARAMS\n");
 
-	return s32Error;
+	return ret;
 }
 
 static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		     struct cfg80211_pmksa *pmksa)
 {
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 	u32 i;
-	s32 s32Error = 0;
+	int ret = 0;
 	u8 flag = 0;
-	struct wilc_vif *vif;
-	struct wilc_priv *priv = wiphy_priv(wiphy);
 
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting PMKSA\n");
 
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
 			flag = PMKID_FOUND;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "PMKID already exists\n");
 			break;
 		}
 	}
 	if (i < WILC_MAX_NUM_PMKIDS) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting PMKID in private structure\n");
 		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
 		       ETH_ALEN);
 		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
@@ -1297,28 +1483,34 @@ static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		if (!(flag == PMKID_FOUND))
 			priv->pmkid_list.numpmkid++;
 	} else {
-		netdev_err(netdev, "Invalid PMKID index\n");
-		s32Error = -EINVAL;
+		PRINT_ER(netdev, "Invalid PMKID index\n");
+		ret = -EINVAL;
 	}
 
-	if (!s32Error)
-		s32Error = wilc_set_pmkid_info(vif, &priv->pmkid_list);
-
-	return s32Error;
+	if (!ret) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting pmkid in the host interface\n");
+		ret = wilc_set_pmkid_info(vif, &priv->pmkid_list);
+	}
+	return ret;
 }
 
 static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		     struct cfg80211_pmksa *pmksa)
 {
 	u32 i;
-	s32 s32Error = 0;
-
+	int ret = 0;
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Deleting PMKSA keys\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
-			memset(&priv->pmkid_list.pmkidlist[i], 0, sizeof(struct host_if_pmkid));
+			PRINT_INFO(netdev, CFG80211_DBG,
+				   "Reseting PMKID values\n");
+			memset(&priv->pmkid_list.pmkidlist[i], 0,
+			       sizeof(struct host_if_pmkid));
 			break;
 		}
 	}
@@ -1334,69 +1526,93 @@ static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		}
 		priv->pmkid_list.numpmkid--;
 	} else {
-		s32Error = -EINVAL;
+		ret = -EINVAL;
 	}
 
-	return s32Error;
+	return ret;
 }
 
 static int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
 {
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Flushing  PMKID key values\n");
 	memset(&priv->pmkid_list, 0, sizeof(struct host_if_pmkid_attr));
 
 	return 0;
 }
 
-static void WILC_WFI_CfgParseRxAction(u8 *buf, u32 len)
+static inline void wilc_wfi_cfg_parse_ch_attr(struct wilc_vif *vif, u8 *buf,
+					      u8 ch_list_attr_idx,
+					      u8 op_ch_attr_idx)
 {
-	u32 index = 0;
-	u32 i = 0, j = 0;
+	int i = 0;
+	int j = 0;
+
+	if (ch_list_attr_idx) {
+		u8 limit = ch_list_attr_idx + 3 + buf[ch_list_attr_idx + 1];
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Modify channel list attribute\n");
+		for (i = ch_list_attr_idx + 3; i < limit; i++) {
+			if (buf[i] == 0x51) {
+				for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
+					buf[j] = wlan_channel;
+				break;
+			}
+		}
+	}
+
+	if (op_ch_attr_idx) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Modify operating channel attribute\n");
+		buf[op_ch_attr_idx + 6] = 0x51;
+		buf[op_ch_attr_idx + 7] = wlan_channel;
+	}
+}
 
+static void wilc_wfi_cfg_parse_rx_action(struct wilc_vif *vif, u8 *buf,
+					 u32 len, bool p2p_mode)
+{
+	u32 index = 0;
 	u8 op_channel_attr_index = 0;
 	u8 channel_list_attr_index = 0;
 
 	while (index < len) {
-		if (buf[index] == GO_INTENT_ATTR_ID)
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x00 << 1);
-
+		if (buf[index] == GO_INTENT_ATTR_ID) {
+			if (!p2p_mode)
+				buf[index + 3] = (buf[index + 3]  & 0x01) |
+						 (0x0f << 1);
+			else
+				buf[index + 3] = (buf[index + 3]  & 0x01) |
+						 (0x00 << 1);
+		}
 		if (buf[index] ==  CHANLIST_ATTR_ID)
 			channel_list_attr_index = index;
 		else if (buf[index] ==  OPERCHAN_ATTR_ID)
 			op_channel_attr_index = index;
 		index += buf[index + 1] + 3;
 	}
-	if (wlan_channel != INVALID_CHANNEL) {
-		if (channel_list_attr_index) {
-			for (i = channel_list_attr_index + 3; i < ((channel_list_attr_index + 3) + buf[channel_list_attr_index + 1]); i++) {
-				if (buf[i] == 0x51) {
-					for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
-						buf[j] = wlan_channel;
-					break;
-				}
-			}
-		}
-
-		if (op_channel_attr_index) {
-			buf[op_channel_attr_index + 6] = 0x51;
-			buf[op_channel_attr_index + 7] = wlan_channel;
-		}
-	}
+	if (wlan_channel != INVALID_CHANNEL)
+		wilc_wfi_cfg_parse_ch_attr(vif, buf, channel_list_attr_index,
+					   op_channel_attr_index);
 }
 
-static void WILC_WFI_CfgParseTxAction(u8 *buf, u32 len, bool bOperChan, u8 iftype)
+static void wilc_wfi_cfg_parse_tx_action(struct wilc_vif *vif, u8 *buf,
+					 u32 len, bool oper_ch, u8 p2p_mode)
 {
 	u32 index = 0;
-	u32 i = 0, j = 0;
-
 	u8 op_channel_attr_index = 0;
 	u8 channel_list_attr_index = 0;
 
 	while (index < len) {
 		if (buf[index] == GO_INTENT_ATTR_ID) {
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x0f << 1);
-
+			if (!p2p_mode)
+				buf[index + 3] = (buf[index + 3]  & 0x01) |
+						 (0x00 << 1);
+			else
+				buf[index + 3] = (buf[index + 3]  & 0x01) |
+						 (0x0f << 1);
 			break;
 		}
 
@@ -1406,112 +1622,143 @@ static void WILC_WFI_CfgParseTxAction(u8 *buf, u32 len, bool bOperChan, u8 iftyp
 			op_channel_attr_index = index;
 		index += buf[index + 1] + 3;
 	}
-	if (wlan_channel != INVALID_CHANNEL && bOperChan) {
-		if (channel_list_attr_index) {
-			for (i = channel_list_attr_index + 3; i < ((channel_list_attr_index + 3) + buf[channel_list_attr_index + 1]); i++) {
-				if (buf[i] == 0x51) {
-					for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
-						buf[j] = wlan_channel;
-					break;
-				}
+	if (wlan_channel != INVALID_CHANNEL && oper_ch)
+		wilc_wfi_cfg_parse_ch_attr(vif, buf, channel_list_attr_index,
+					   op_channel_attr_index);
+}
+
+static void wilc_wfi_cfg_parse_rx_vendor_spec(struct wilc_priv *priv, u8 *buff,
+					      u32 size)
+{
+	int i;
+	u8 subtype;
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	subtype = buff[P2P_PUB_ACTION_SUBTYPE];
+	if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) &&
+	    !priv->p2p.is_wilc_ie) {
+		for (i = P2P_PUB_ACTION_SUBTYPE; i < size; i++) {
+			if (!memcmp(p2p_vendor_spec, &buff[i], 6)) {
+				priv->p2p.recv_random = buff[i + 6];
+				priv->p2p.is_wilc_ie = true;
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "WILC Vendor specific IE:%02x\n",
+					   priv->p2p.recv_random);
+				break;
 			}
 		}
+	}
+
+	if (priv->p2p.local_random <= priv->p2p.recv_random) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "PEER WILL BE GO LocaRand=%02x RecvRand %02x\n",
+			   priv->p2p.local_random, priv->p2p.recv_random);
+		return;
+	}
+
+	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP ||
+	    subtype == P2P_INV_REQ || subtype == P2P_INV_RSP) {
+		for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < size; i++) {
+			if (buff[i] == P2PELEM_ATTR_ID &&
+			    !(memcmp(p2p_oui, &buff[i + 2], 4))) {
+				bool p2p_mode = vif->attr_sysfs.p2p_mode;
 
-		if (op_channel_attr_index) {
-			buf[op_channel_attr_index + 6] = 0x51;
-			buf[op_channel_attr_index + 7] = wlan_channel;
+				wilc_wfi_cfg_parse_rx_action(vif, &buff[i + 6],
+							     size - (i + 6),
+							     p2p_mode);
+				break;
+			}
 		}
 	}
 }
 
-void WILC_WFI_p2p_rx(struct net_device *dev, u8 *buff, u32 size)
+void wilc_wfi_p2p_rx(struct net_device *dev, u8 *buff, u32 size)
 {
-	struct wilc_priv *priv;
+	struct wilc_priv *priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
+	struct host_if_drv *wfi_drv = priv->hif_drv;
+	struct wilc_vif *vif = netdev_priv(dev);
 	u32 header, pkt_offset;
-	struct host_if_drv *pstrWFIDrv;
-	u32 i = 0;
-	s32 s32Freq;
-
-	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
+	s32 freq;
+	__le16 fc;
 
 	memcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);
 
 	pkt_offset = GET_PKT_OFFSET(header);
 
+	fc = ((struct ieee80211_hdr *)buff)->frame_control;
 	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
-		if (buff[FRAME_TYPE_ID] == IEEE80211_STYPE_PROBE_RESP) {
-			cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, true, GFP_KERNEL);
-			return;
-		} else {
-			if (pkt_offset & IS_MGMT_STATUS_SUCCES)
-				cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, true, GFP_KERNEL);
-			else
-				cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, false, GFP_KERNEL);
-			return;
-		}
-	} else {
-		s32Freq = ieee80211_channel_to_frequency(curr_channel, NL80211_BAND_2GHZ);
+		bool ack = false;
 
-		if (ieee80211_is_action(buff[FRAME_TYPE_ID])) {
-			if (priv->bCfgScanning && time_after_eq(jiffies, (unsigned long)pstrWFIDrv->p2p_timeout)) {
-				netdev_dbg(dev, "Receiving action wrong ch\n");
-				return;
-			}
-			if (buff[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-				switch (buff[ACTION_SUBTYPE_ID]) {
-				case GAS_INITIAL_REQ:
-					break;
+		if (ieee80211_is_probe_resp(fc) ||
+		    pkt_offset & IS_MGMT_STATUS_SUCCES)
+			ack = true;
 
-				case GAS_INITIAL_RSP:
-					break;
+		cfg80211_mgmt_tx_status(priv->wdev, priv->tx_cookie, buff, size,
+					ack, GFP_KERNEL);
+		return;
+	}
 
-				case PUBLIC_ACT_VENDORSPEC:
-					if (!memcmp(p2p_oui, &buff[ACTION_SUBTYPE_ID + 1], 4)) {
-						if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP))	{
-							if (!wilc_ie) {
-								for (i = P2P_PUB_ACTION_SUBTYPE; i < size; i++)	{
-									if (!memcmp(p2p_vendor_spec, &buff[i], 6)) {
-										p2p_recv_random = buff[i + 6];
-										wilc_ie = true;
-										break;
-									}
-								}
-							}
-						}
-						if (p2p_local_random > p2p_recv_random)	{
-							if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP ||
-							     buff[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)) {
-								for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < size; i++) {
-									if (buff[i] == P2PELEM_ATTR_ID && !(memcmp(p2p_oui, &buff[i + 2], 4))) {
-										WILC_WFI_CfgParseRxAction(&buff[i + 6], size - (i + 6));
-										break;
-									}
-								}
-							}
-						} else {
-							netdev_dbg(dev, "PEER WILL BE GO LocaRand=%02x RecvRand %02x\n", p2p_local_random, p2p_recv_random);
-						}
-					}
-
-					if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP) && (wilc_ie))	{
-						cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size - 7, 0);
-						return;
-					}
-					break;
+	PRINT_D(vif->ndev, GENERIC_DBG, "Rx Frame Type:%x\n", fc);
 
-				default:
-					netdev_dbg(dev, "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n", buff[ACTION_SUBTYPE_ID]);
-					break;
-				}
-			}
-		}
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+	freq = ieee80211_channel_to_frequency(curr_channel, NL80211_BAND_2GHZ);
+ #else
+	freq = ieee80211_channel_to_frequency(curr_channel,
+					      IEEE80211_BAND_2GHZ);
+ #endif
+	if (!ieee80211_is_action(fc)) {
+		cfg80211_rx_mgmt(priv->wdev, freq, 0, buff, size, 0);
+		return;
+	}
+
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		   "Rx Action Frame Type: %x %x\n",
+		   buff[ACTION_SUBTYPE_ID],
+		   buff[P2P_PUB_ACTION_SUBTYPE]);
+	if (priv->cfg_scanning &&
+	    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {
+		PRINT_WRN(dev, GENERIC_DBG, "Receiving action wrong ch\n");
+		return;
+	}
+	if (buff[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
+		u8 subtype = buff[P2P_PUB_ACTION_SUBTYPE];
+
+		switch (buff[ACTION_SUBTYPE_ID]) {
+		case GAS_INITIAL_REQ:
+			PRINT_D(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL REQ %x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
 
-		cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size, 0);
+		case GAS_INITIAL_RSP:
+			PRINT_D(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL RSP %x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
+
+		case PUBLIC_ACT_VENDORSPEC:
+			if (!memcmp(p2p_oui, &buff[ACTION_SUBTYPE_ID + 1], 4))
+				wilc_wfi_cfg_parse_rx_vendor_spec(priv, buff,
+								  size);
+
+			if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) &&
+			    priv->p2p.is_wilc_ie)
+				size -= 7;
+
+			break;
+
+		default:
+			PRINT_WRN(dev, GENERIC_DBG,
+				   "Not handled action frame type:%x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
+		}
 	}
+
+	cfg80211_rx_mgmt(priv->wdev, freq, 0, buff, size, 0);
 }
 
-static void WILC_WFI_mgmt_tx_complete(void *priv, int status)
+static void wilc_wfi_mgmt_tx_complete(void *priv, int status)
 {
 	struct p2p_mgmt_data *pv_data = priv;
 
@@ -1519,35 +1766,42 @@ static void WILC_WFI_mgmt_tx_complete(void *priv, int status)
 	kfree(pv_data);
 }
 
-static void WILC_WFI_RemainOnChannelReady(void *pUserVoid)
+static void wilc_wfi_remain_on_channel_ready(void *priv_data)
 {
 	struct wilc_priv *priv;
 
-	priv = pUserVoid;
+	priv = priv_data;
 
-	priv->bInP2PlistenState = true;
+	PRINT_INFO(priv->dev, HOSTINF_DBG, "Remain on channel ready\n");
+	priv->p2p_listen_state = true;
 
 	cfg80211_ready_on_channel(priv->wdev,
-				  priv->strRemainOnChanParams.u64ListenCookie,
-				  priv->strRemainOnChanParams.pstrListenChan,
-				  priv->strRemainOnChanParams.u32ListenDuration,
+				  priv->remain_on_ch_params.listen_cookie,
+				  priv->remain_on_ch_params.listen_ch,
+				  priv->remain_on_ch_params.listen_duration,
 				  GFP_KERNEL);
 }
 
-static void WILC_WFI_RemainOnChannelExpired(void *pUserVoid, u32 u32SessionID)
+static void wilc_wfi_remain_on_channel_expired(void *data, u32 session_id)
 {
-	struct wilc_priv *priv;
+	struct wilc_priv *priv = data;
+	struct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;
+
+	if (session_id != params->listen_session_id) {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Received ID 0x%x Expected ID 0x%x (No match)\n",
+			   session_id,
+			   priv->remain_on_ch_params.listen_session_id);
+		return;
+	}
 
-	priv = pUserVoid;
 
-	if (u32SessionID == priv->strRemainOnChanParams.u32ListenSessionID) {
-		priv->bInP2PlistenState = false;
+	PRINT_INFO(priv->dev, GENERIC_DBG,
+		   "Remain on channel expired\n");
+	priv->p2p_listen_state = false;
 
-		cfg80211_remain_on_channel_expired(priv->wdev,
-						   priv->strRemainOnChanParams.u64ListenCookie,
-						   priv->strRemainOnChanParams.pstrListenChan,
-						   GFP_KERNEL);
-	}
+	cfg80211_remain_on_channel_expired(priv->wdev, params->listen_cookie,
+					   params->listen_ch, GFP_KERNEL);
 }
 
 static int remain_on_channel(struct wiphy *wiphy,
@@ -1555,174 +1809,260 @@ static int remain_on_channel(struct wiphy *wiphy,
 			     struct ieee80211_channel *chan,
 			     unsigned int duration, u64 *cookie)
 {
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	int ret = 0;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Remaining on channel %d\n",
+		   chan->hw_value);
 
 	if (wdev->iftype == NL80211_IFTYPE_AP) {
-		netdev_dbg(vif->ndev, "Required while in AP mode\n");
-		return s32Error;
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Required while in AP mode\n");
+		return ret;
 	}
 
 	curr_channel = chan->hw_value;
 
-	priv->strRemainOnChanParams.pstrListenChan = chan;
-	priv->strRemainOnChanParams.u64ListenCookie = *cookie;
-	priv->strRemainOnChanParams.u32ListenDuration = duration;
-	priv->strRemainOnChanParams.u32ListenSessionID++;
+	priv->remain_on_ch_params.listen_ch = chan;
+	priv->remain_on_ch_params.listen_cookie = *cookie;
+	priv->remain_on_ch_params.listen_duration = duration;
+	priv->remain_on_ch_params.listen_session_id++;
 
 	return wilc_remain_on_channel(vif,
-				priv->strRemainOnChanParams.u32ListenSessionID,
+				priv->remain_on_ch_params.listen_session_id,
 				duration, chan->hw_value,
-				WILC_WFI_RemainOnChannelExpired,
-				WILC_WFI_RemainOnChannelReady, (void *)priv);
+				wilc_wfi_remain_on_channel_expired,
+				wilc_wfi_remain_on_channel_ready, (void *)priv);
 }
 
 static int cancel_remain_on_channel(struct wiphy *wiphy,
 				    struct wireless_dev *wdev,
 				    u64 cookie)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Cancel remain on channel\n");
 
 	return wilc_listen_state_expired(vif,
-			priv->strRemainOnChanParams.u32ListenSessionID);
+			priv->remain_on_ch_params.listen_session_id);
+}
+
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
+static void wilc_wfi_cfg_tx_vendor_spec(struct wilc_priv *priv,
+					struct p2p_mgmt_data *mgmt_tx,
+					struct cfg80211_mgmt_tx_params *params,
+					u8 iftype, u32 buf_len)
+#else
+static void wilc_wfi_cfg_tx_vendor_spec(struct wilc_priv *priv,
+					struct p2p_mgmt_data *mgmt_tx,
+					const u8 *buf, size_t len,
+					u8 iftype, u32 buf_len)
+#endif
+{
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	u32 i;
+	u8 subtype = buf[P2P_PUB_ACTION_SUBTYPE];
+
+	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) {
+		if (priv->p2p.local_random == 1 &&
+		    priv->p2p.recv_random < priv->p2p.local_random) {
+			get_random_bytes(&priv->p2p.local_random, 1);
+			priv->p2p.local_random++;
+		}
+	}
+
+	if (priv->p2p.local_random <= priv->p2p.recv_random ||
+	    !(subtype == GO_NEG_REQ || subtype == GO_NEG_RSP ||
+	      subtype == P2P_INV_REQ || subtype == P2P_INV_RSP))
+		return;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "LOCAL WILL BE GO LocaRand=%02x RecvRand %02x\n",
+		   priv->p2p.local_random, priv->p2p.recv_random);
+	for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < len; i++) {
+		if (buf[i] == P2PELEM_ATTR_ID &&
+		    !memcmp(p2p_oui, &buf[i + 2], 4)) {
+			bool oper_ch = false;
+			u8 *tx_buff = &mgmt_tx->buff[i + 6];
+
+			if (subtype == P2P_INV_REQ || subtype == P2P_INV_RSP)
+				oper_ch = true;
+
+			wilc_wfi_cfg_parse_tx_action(vif, tx_buff,
+						     len - (i + 6), oper_ch,
+						     vif->attr_sysfs.p2p_mode);
+			break;
+		}
+	}
+
+	if (subtype != P2P_INV_REQ && subtype != P2P_INV_RSP) {
+		int vendor_spec_len = sizeof(p2p_vendor_spec);
+
+		memcpy(&mgmt_tx->buff[len], p2p_vendor_spec,
+		       vendor_spec_len);
+		mgmt_tx->buff[len + vendor_spec_len] = priv->p2p.local_random;
+		mgmt_tx->size = buf_len;
+	}
 }
 
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 static int mgmt_tx(struct wiphy *wiphy,
 		   struct wireless_dev *wdev,
 		   struct cfg80211_mgmt_tx_params *params,
 		   u64 *cookie)
+#else
+static int mgmt_tx(struct wiphy *wiphy,
+		   struct wireless_dev *wdev,
+		   struct ieee80211_channel *chan, bool offchan,
+		   unsigned int wait, const u8 *buf, size_t len,
+		   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
 {
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 	struct ieee80211_channel *chan = params->chan;
 	unsigned int wait = params->wait;
 	const u8 *buf = params->buf;
 	size_t len = params->len;
+#endif
 	const struct ieee80211_mgmt *mgmt;
 	struct p2p_mgmt_data *mgmt_tx;
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	u32 i;
-	struct wilc_vif *vif;
-	u32 buf_len = len + sizeof(p2p_vendor_spec) + sizeof(p2p_local_random);
-
-	vif = netdev_priv(wdev->netdev);
-	priv = wiphy_priv(wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct host_if_drv *wfi_drv = priv->hif_drv;
+	struct wilc_vif *vif = netdev_priv(wdev->netdev);
+	u32 buf_len = len + sizeof(p2p_vendor_spec) +
+		      sizeof(priv->p2p.local_random);
+	int ret = 0;
 
 	*cookie = (unsigned long)buf;
-	priv->u64tx_cookie = *cookie;
-	mgmt = (const struct ieee80211_mgmt *) buf;
+	priv->tx_cookie = *cookie;
+	mgmt = (const struct ieee80211_mgmt *)buf;
 
-	if (ieee80211_is_mgmt(mgmt->frame_control)) {
-		mgmt_tx = kmalloc(sizeof(struct p2p_mgmt_data), GFP_KERNEL);
-		if (!mgmt_tx)
-			return -EFAULT;
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "This function transmits only management frames\n");
+		goto out;
+	}
 
-		mgmt_tx->buff = kmalloc(buf_len, GFP_KERNEL);
-		if (!mgmt_tx->buff) {
-			kfree(mgmt_tx);
-			return -ENOMEM;
-		}
+	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);
+	if (!mgmt_tx) {
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
+		return -ENOMEM;
+	}
 
-		memcpy(mgmt_tx->buff, buf, len);
-		mgmt_tx->size = len;
+	mgmt_tx->buff = kmalloc(buf_len, GFP_KERNEL);
+	if (!mgmt_tx->buff) {
+		ret = -ENOMEM;
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx buff\n");
+		kfree(mgmt_tx);
+		goto out;
+	}
 
-		if (ieee80211_is_probe_resp(mgmt->frame_control)) {
-			wilc_set_mac_chnl_num(vif, chan->hw_value);
-			curr_channel = chan->hw_value;
-		} else if (ieee80211_is_action(mgmt->frame_control))   {
-			if (buf[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-				if (buf[ACTION_SUBTYPE_ID] != PUBLIC_ACT_VENDORSPEC ||
-				    buf[P2P_PUB_ACTION_SUBTYPE] != GO_NEG_CONF)	{
-					wilc_set_mac_chnl_num(vif,
-							      chan->hw_value);
-					curr_channel = chan->hw_value;
-				}
-				switch (buf[ACTION_SUBTYPE_ID])	{
-				case GAS_INITIAL_REQ:
-					break;
+	memcpy(mgmt_tx->buff, buf, len);
+	mgmt_tx->size = len;
 
-				case GAS_INITIAL_RSP:
-					break;
+	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "TX: Probe Response\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
+		wilc_set_mac_chnl_num(vif, chan->hw_value);
+		curr_channel = chan->hw_value;
+		goto out_txq_add_pkt;
+	}
 
-				case PUBLIC_ACT_VENDORSPEC:
-				{
-					if (!memcmp(p2p_oui, &buf[ACTION_SUBTYPE_ID + 1], 4)) {
-						if ((buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP)) {
-							if (p2p_local_random == 1 && p2p_recv_random < p2p_local_random) {
-								get_random_bytes(&p2p_local_random, 1);
-								p2p_local_random++;
-							}
-						}
-
-						if ((buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP ||
-						     buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)) {
-							if (p2p_local_random > p2p_recv_random)	{
-								for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < len; i++) {
-									if (buf[i] == P2PELEM_ATTR_ID && !(memcmp(p2p_oui, &buf[i + 2], 4))) {
-										if (buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)
-											WILC_WFI_CfgParseTxAction(&mgmt_tx->buff[i + 6], len - (i + 6), true, vif->iftype);
-										else
-											WILC_WFI_CfgParseTxAction(&mgmt_tx->buff[i + 6], len - (i + 6), false, vif->iftype);
-										break;
-									}
-								}
-
-								if (buf[P2P_PUB_ACTION_SUBTYPE] != P2P_INV_REQ && buf[P2P_PUB_ACTION_SUBTYPE] != P2P_INV_RSP) {
-									memcpy(&mgmt_tx->buff[len], p2p_vendor_spec, sizeof(p2p_vendor_spec));
-									mgmt_tx->buff[len + sizeof(p2p_vendor_spec)] = p2p_local_random;
-									mgmt_tx->size = buf_len;
-								}
-							}
-						}
-
-					} else {
-						netdev_dbg(vif->ndev, "Not a P2P public action frame\n");
-					}
+	if (!ieee80211_is_action(mgmt->frame_control))
+		goto out_txq_add_pkt;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "ACTION FRAME:%x\n",
+		   (u16)mgmt->frame_control);
+	if (buf[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
+		if (buf[ACTION_SUBTYPE_ID] != PUBLIC_ACT_VENDORSPEC ||
+		    buf[P2P_PUB_ACTION_SUBTYPE] != GO_NEG_CONF) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Setting channel: %d\n",
+				   chan->hw_value);
+			wilc_set_mac_chnl_num(vif,
+					      chan->hw_value);
+			curr_channel = chan->hw_value;
+		}
+		switch (buf[ACTION_SUBTYPE_ID]) {
+		case GAS_INITIAL_REQ:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL REQ %x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
 
-					break;
-				}
+		case GAS_INITIAL_RSP:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL RSP %x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
 
-				default:
-				{
-					netdev_dbg(vif->ndev, "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n", buf[ACTION_SUBTYPE_ID]);
-					break;
-				}
-				}
-			}
+		case PUBLIC_ACT_VENDORSPEC:
+			if (!memcmp(p2p_oui, &buf[ACTION_SUBTYPE_ID + 1], 4))
+			#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
+				wilc_wfi_cfg_tx_vendor_spec(priv, mgmt_tx,
+							    params,
+							    vif->iftype,
+							    buf_len);
+			#else
+				wilc_wfi_cfg_tx_vendor_spec(priv, mgmt_tx, buf,
+							    len, vif->iftype,
+							    buf_len);
+			#endif
+			else
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "Not a P2P public action frame\n");
 
-			pstrWFIDrv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
-		}
+			break;
 
-		wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
-					   mgmt_tx->buff, mgmt_tx->size,
-					   WILC_WFI_mgmt_tx_complete);
+		default:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Not handled action frame type:%x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
+		}
 	}
-	return 0;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "TX: ACTION FRAME Type:%x : Chan:%d\n",
+		   buf[ACTION_SUBTYPE_ID], chan->hw_value);
+	wfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
+
+out_txq_add_pkt:
+
+	txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,	 mgmt_tx->buff, mgmt_tx->size,
+			 wilc_wfi_mgmt_tx_complete);
+
+out:
+
+	return ret;
 }
 
 static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
 			       struct wireless_dev *wdev,
 			       u64 cookie)
 {
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct host_if_drv *wfi_drv = priv->hif_drv;
+
+	wfi_drv->p2p_timeout = jiffies;
+
+	if (!priv->p2p_listen_state) {
+		struct wilc_wfi_p2p_listen_params *params;
 
-	priv = wiphy_priv(wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-	pstrWFIDrv->p2p_timeout = jiffies;
+		params = &priv->remain_on_ch_params;
 
-	if (!priv->bInP2PlistenState) {
 		cfg80211_remain_on_channel_expired(priv->wdev,
-						   priv->strRemainOnChanParams.u64ListenCookie,
-						   priv->strRemainOnChanParams.pstrListenChan,
+						   params->listen_cookie,
+						   params->listen_ch,
 						   GFP_KERNEL);
 	}
 
@@ -1732,161 +2072,224 @@ static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
 void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 			      u16 frame_type, bool reg)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->wdev->netdev);
-	wl = vif->wilc;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->wdev->netdev);
+	struct wilc *wl = vif->wilc;
 
 	if (!frame_type)
 		return;
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Frame registering Frame Type: %x: Boolean: %d\n",
+		   frame_type, reg);
 	switch (frame_type) {
 	case PROBE_REQ:
-	{
 		vif->frame_reg[0].type = frame_type;
 		vif->frame_reg[0].reg = reg;
-	}
-	break;
+		break;
 
 	case ACTION:
-	{
 		vif->frame_reg[1].type = frame_type;
 		vif->frame_reg[1].reg = reg;
-	}
-	break;
+		break;
 
 	default:
-	{
 		break;
 	}
-	}
 
-	if (!wl->initialized)
+	if (!wl->initialized) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Return since mac is closed\n");
 		return;
+	}
 	wilc_frame_register(vif, frame_type, reg);
 }
 
 static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
 			       s32 rssi_thold, u32 rssi_hyst)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Setting CQM RSSi Function\n");
 	return 0;
 }
 
 static int dump_station(struct wiphy *wiphy, struct net_device *dev,
 			int idx, u8 *mac, struct station_info *sinfo)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	int ret = 0;
 
 	if (idx != 0)
 		return -ENOENT;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Dumping station information\n");
 
-	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+	ret = wilc_get_rssi(vif, &sinfo->signal);
 
-	wilc_get_rssi(vif, &sinfo->signal);
+	if (ret)
+		return ret;
+
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+#else
+	sinfo->filled |= STATION_INFO_SIGNAL;
+#endif
 
-	memcpy(mac, priv->au8AssociatedBss, ETH_ALEN);
 	return 0;
 }
 
 static int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
 			  bool enabled, int timeout)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -ENOENT;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	if (!priv->hif_drv)
+	if (!priv->hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -EIO;
+	}
+
+	/* Can't set PS during obtaining IP */
+	if (vif->obtaining_ip == true) {
+		PRINT_ER(dev,
+			 "Device obtaining IP, Power Managment will be handled after IP Obtained\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Save the Current state of the PS = %d\n", enabled);
+
+		/* Save the current status of the PS */
+		store_power_save_current_state(vif, enabled);
+
+		return 0;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   " Power save Enabled= %d , TimeOut = %d\n", enabled,
+		   timeout);
 
-	if (wilc_enable_ps)
-		wilc_set_power_mgmt(vif, enabled, timeout);
+	wilc_set_power_mgmt(vif, enabled, timeout);
 
 	return 0;
 }
 
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
-			       enum nl80211_iftype type, struct vif_params *params)
+			       enum nl80211_iftype type,
+			       struct vif_params *params)
+#else
+static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
+			       enum nl80211_iftype type, u32 *flags,
+			       struct vif_params *params)
+#endif
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	priv = wiphy_priv(wiphy);
-	wl = vif->wilc;
-	p2p_local_random = 0x01;
-	p2p_recv_random = 0x00;
-	wilc_ie = false;
-	wilc_optaining_ip = false;
-	del_timer(&wilc_during_ip_timer);
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+	struct net_device *net_device_1 = wilc_get_if_netdev(wl, P2P_IFC);
+	struct net_device *net_device_2 = wilc_get_if_netdev(wl, WLAN_IFC);
+	struct wilc_vif *vif_1 = netdev_priv(net_device_1);
+	struct wilc_vif *vif_2 = netdev_priv(net_device_2);
+
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "In Change virtual interface function\n");
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "Wireless interface name =%s\n", dev->name);
+	priv->p2p.local_random = 0x01;
+	priv->p2p.recv_random = 0x00;
+	priv->p2p.is_wilc_ie = false;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Changing virtual interface, enable scan\n");
+	handle_pwrsave_for_IP(vif, IP_STATE_DEFAULT);
+#endif
 
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
-		wilc_connecting = 0;
+		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_STATION\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev->iftype = type;
 		vif->monitor_flag = 0;
 		vif->iftype = STATION_MODE;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+					 STATION_MODE, vif->ifc_id, false);
 		wilc_set_operation_mode(vif, STATION_MODE);
 
-		memset(priv->assoc_stainfo.au8Sta_AssociatedBss, 0, MAX_NUM_STA * ETH_ALEN);
+		memset(priv->assoc_stainfo.sta_associated_bss, 0,
+		       MAX_NUM_STA * ETH_ALEN);
 
-		wilc_enable_ps = true;
-		wilc_set_power_mgmt(vif, 1, 0);
+		wilc_set_power_mgmt(vif_1, 1, 0);
+		wilc_set_power_mgmt(vif_2, 1, 0);
 		break;
 
 	case NL80211_IFTYPE_P2P_CLIENT:
-		wilc_connecting = 0;
+		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_P2P_CLIENT\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev->iftype = type;
 		vif->monitor_flag = 0;
 		vif->iftype = CLIENT_MODE;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+					 STATION_MODE, vif->ifc_id, false);
 		wilc_set_operation_mode(vif, STATION_MODE);
 
-		wilc_enable_ps = false;
-		wilc_set_power_mgmt(vif, 0, 0);
+		wilc_set_power_mgmt(vif_1, 0, 0);
+		wilc_set_power_mgmt(vif_2, 0, 0);
 		break;
 
 	case NL80211_IFTYPE_AP:
-		wilc_enable_ps = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_AP\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev->iftype = type;
 		vif->iftype = AP_MODE;
-
 		if (wl->initialized) {
 			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
-						 0, vif->ifc_id);
+						 AP_MODE, vif->ifc_id, false);
 			wilc_set_operation_mode(vif, AP_MODE);
-			wilc_set_power_mgmt(vif, 0, 0);
+			wilc_set_power_mgmt(vif_1, 0, 0);
+			wilc_set_power_mgmt(vif_2, 0, 0);
 		}
 		break;
 
 	case NL80211_IFTYPE_P2P_GO:
-		wilc_optaining_ip = true;
-		mod_timer(&wilc_during_ip_timer,
-			  jiffies + msecs_to_jiffies(during_ip_time));
-		wilc_set_operation_mode(vif, AP_MODE);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_GO\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "start duringIP timer\n");
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_for_IP(vif, IP_STATE_GO_ASSIGNING);
+#endif
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev->iftype = type;
 		vif->iftype = GO_MODE;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+					AP_MODE, vif->ifc_id, false);
+		wilc_set_operation_mode(vif, AP_MODE);
+		wilc_set_power_mgmt(vif_1, 0, 0);
+		wilc_set_power_mgmt(vif_2, 0, 0);
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_MONITOR\n");
+		dev->ieee80211_ptr->iftype = type;
+		dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		priv->wdev->iftype = type;
+		vif->iftype = MONITOR_MODE;
+		if (wl->initialized) {
+			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+						 MONITOR_MODE, vif->ifc_id,
+						 false);
 
-		wilc_enable_ps = false;
-		wilc_set_power_mgmt(vif, 0, 0);
+			wilc_set_operation_mode(vif, MONITOR_MODE);
+			wilc_set_power_mgmt(vif_1, 0, 0);
+			wilc_set_power_mgmt(vif_2, 0, 0);
+		}
 		break;
 
 	default:
-		netdev_err(dev, "Unknown interface type= %d\n", type);
+		PRINT_ER(dev, "Unknown interface type= %d\n", type);
 		return -EINVAL;
 	}
 
@@ -1896,22 +2299,22 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 static int start_ap(struct wiphy *wiphy, struct net_device *dev,
 		    struct cfg80211_ap_settings *settings)
 {
-	struct cfg80211_beacon_data *beacon = &(settings->beacon);
-	struct wilc_priv *priv;
-	s32 s32Error = 0;
-	struct wilc *wl;
-	struct wilc_vif *vif;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct cfg80211_beacon_data *beacon = &settings->beacon;
+	int ret;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Starting ap\n");
 
-	s32Error = set_channel(wiphy, &settings->chandef);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Interval= %d\n DTIM period= %d\n Head length= %d Tail length= %d\n",
+		   settings->beacon_interval, settings->dtim_period,
+		   beacon->head_len, beacon->tail_len);
+	ret = set_channel(wiphy, &settings->chandef);
 
-	if (s32Error != 0)
-		netdev_err(dev, "Error in setting channel\n");
+	if (ret != 0)
+		PRINT_ER(dev, "Error in setting channel\n");
 
-	wilc_wlan_set_bssid(dev, wl->vif[vif->idx]->src_addr, AP_MODE);
+	wilc_wlan_set_bssid(dev, dev->dev_addr, AP_MODE);
 	wilc_set_power_mgmt(vif, 0, 0);
 
 	return wilc_add_beacon(vif, settings->beacon_interval,
@@ -1923,11 +2326,10 @@ static int start_ap(struct wiphy *wiphy, struct net_device *dev,
 static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
 			 struct cfg80211_beacon_data *beacon)
 {
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Setting beacon\n");
 
 	return wilc_add_beacon(vif, 0, 0, beacon->head_len,
 				   (u8 *)beacon->head, beacon->tail_len,
@@ -1936,148 +2338,244 @@ static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
 
 static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
 {
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	u8 NullBssid[ETH_ALEN] = {0};
-
-	if (!wiphy)
-		return -EFAULT;
+	int ret;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	u8 null_bssid[ETH_ALEN] = {0};
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting beacon\n");
 
-	wilc_wlan_set_bssid(dev, NullBssid, AP_MODE);
+	wilc_wlan_set_bssid(dev, null_bssid, AP_MODE);
 
-	s32Error = wilc_del_beacon(vif);
+	ret = wilc_del_beacon(vif);
 
-	if (s32Error)
-		netdev_err(dev, "Host delete beacon fail\n");
+	if (ret)
+		PRINT_ER(dev, "Host delete beacon fail\n");
 
-	return s32Error;
+	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int add_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_parameters *params)
+#else
+static int add_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_parameters *params)
+#endif
 {
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct add_sta_param strStaParams = { {0} };
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
+	int ret = 0;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct add_sta_param sta_params = { {0} };
+	struct wilc_vif *vif = netdev_priv(dev);
+	u8 *assoc_bss = priv->assoc_stainfo.sta_associated_bss[params->aid];
 
 	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		memcpy(strStaParams.bssid, mac, ETH_ALEN);
-		memcpy(priv->assoc_stainfo.au8Sta_AssociatedBss[params->aid], mac, ETH_ALEN);
-		strStaParams.aid = params->aid;
-		strStaParams.rates_len = params->supported_rates_len;
-		strStaParams.rates = params->supported_rates;
-
+		memcpy(sta_params.bssid, mac, ETH_ALEN);
+		memcpy(assoc_bss, mac, ETH_ALEN);
+		sta_params.aid = params->aid;
+		sta_params.rates_len = params->supported_rates_len;
+		sta_params.rates = params->supported_rates;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding station parameters %d\n", params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   assoc_bss[0], assoc_bss[1], assoc_bss[2],
+			   assoc_bss[3], assoc_bss[4], assoc_bss[5]);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG, "ASSOC ID = %d\n",
+			   sta_params.aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Number of supported rates = %d\n",
+			   sta_params.rates_len);
 		if (!params->ht_capa) {
-			strStaParams.ht_supported = false;
+			sta_params.ht_supported = false;
 		} else {
-			strStaParams.ht_supported = true;
-			strStaParams.ht_capa = *params->ht_capa;
+			sta_params.ht_supported = true;
+			sta_params.ht_capa = *params->ht_capa;
 		}
 
-		strStaParams.flags_mask = params->sta_flags_mask;
-		strStaParams.flags_set = params->sta_flags_set;
-
-		s32Error = wilc_add_station(vif, &strStaParams);
-		if (s32Error)
-			netdev_err(dev, "Host add station fail\n");
+		sta_params.flags_mask = params->sta_flags_mask;
+		sta_params.flags_set = params->sta_flags_set;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   sta_params.ht_supported);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Capability Info = %d\n",
+			   sta_params.ht_capa.cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "AMPDU Params = %d\n",
+			   sta_params.ht_capa.ampdu_params_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "HT Extended params= %d\n",
+			   sta_params.ht_capa.extended_ht_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Tx Beamforming Cap= %d\n",
+			   sta_params.ht_capa.tx_BF_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Antenna selection info = %d\n",
+			   sta_params.ht_capa.antenna_selection_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   sta_params.flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   sta_params.flags_set);
+		ret = wilc_add_station(vif, &sta_params);
+		if (ret)
+			PRINT_ER(dev, "Host add station fail\n");
 	}
 
-	return s32Error;
+	return ret;
 }
 
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 static int del_station(struct wiphy *wiphy, struct net_device *dev,
 		       struct station_del_parameters *params)
+#elif KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac)
+#else
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac)
+#endif
 {
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 	const u8 *mac = params->mac;
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
+#endif
+	int ret = 0;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct sta_info *info;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
+	if (!(vif->iftype == AP_MODE || vif->iftype == GO_MODE))
+		return ret;
 
-	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		if (!mac)
-			s32Error = wilc_del_allstation(vif,
-				     priv->assoc_stainfo.au8Sta_AssociatedBss);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting station\n");
 
-		s32Error = wilc_del_station(vif, mac);
+	info = &priv->assoc_stainfo;
 
-		if (s32Error)
-			netdev_err(dev, "Host delete station fail\n");
+	if (!mac) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "All associated stations\n");
+		ret = wilc_del_allstation(vif, info->sta_associated_bss);
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "With mac address: %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 	}
-	return s32Error;
+
+	ret = wilc_del_station(vif, mac);
+	if (ret)
+		PRINT_ER(dev, "Host delete station fail\n");
+
+	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int change_station(struct wiphy *wiphy, struct net_device *dev,
 			  const u8 *mac, struct station_parameters *params)
+#else
+static int change_station(struct wiphy *wiphy, struct net_device *dev,
+			  u8 *mac, struct station_parameters *params)
+#endif
 {
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct add_sta_param strStaParams = { {0} };
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
+	int ret = 0;
+	struct add_sta_param sta_params = { {0} };
+	struct wilc_vif *vif = netdev_priv(dev);
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
+	PRINT_D(vif->ndev, CFG80211_DBG, "Change station paramters\n");
 
 	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		memcpy(strStaParams.bssid, mac, ETH_ALEN);
-		strStaParams.aid = params->aid;
-		strStaParams.rates_len = params->supported_rates_len;
-		strStaParams.rates = params->supported_rates;
-
+		memcpy(sta_params.bssid, mac, ETH_ALEN);
+		sta_params.aid = params->aid;
+		sta_params.rates_len = params->supported_rates_len;
+		sta_params.rates = params->supported_rates;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			  sta_params.bssid[0], sta_params.bssid[1],
+			  sta_params.bssid[2], sta_params.bssid[3],
+			  sta_params.bssid[4],
+			  sta_params.bssid[5]);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "ASSOC ID = %d\n",
+			   sta_params.aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of supported rates = %d\n",
+			   sta_params.rates_len);
 		if (!params->ht_capa) {
-			strStaParams.ht_supported = false;
+			sta_params.ht_supported = false;
 		} else {
-			strStaParams.ht_supported = true;
-			strStaParams.ht_capa = *params->ht_capa;
+			sta_params.ht_supported = true;
+			sta_params.ht_capa = *params->ht_capa;
 		}
 
-		strStaParams.flags_mask = params->sta_flags_mask;
-		strStaParams.flags_set = params->sta_flags_set;
-
-		s32Error = wilc_edit_station(vif, &strStaParams);
-		if (s32Error)
-			netdev_err(dev, "Host edit station fail\n");
+		sta_params.flags_mask = params->sta_flags_mask;
+		sta_params.flags_set = params->sta_flags_set;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   sta_params.ht_supported);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Capability Info = %d\n",
+			   sta_params.ht_capa.cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "AMPDU Params = %d\n",
+			   sta_params.ht_capa.ampdu_params_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "HT Extended params= %d\n",
+			   sta_params.ht_capa.extended_ht_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Tx Beamforming Cap= %d\n",
+			   sta_params.ht_capa.tx_BF_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Antenna selection info = %d\n",
+			   sta_params.ht_capa.antenna_selection_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   sta_params.flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   sta_params.flags_set);
+		ret = wilc_edit_station(vif, &sta_params);
+		if (ret)
+			PRINT_ER(dev, "Host edit station fail\n");
 	}
-	return s32Error;
+	return ret;
 }
 
+#if KERNEL_VERSION(4, 12, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     unsigned char name_assign_type,
+					     enum nl80211_iftype type,
+					     struct vif_params *params)
+#elif KERNEL_VERSION(4, 1, 0) <= LINUX_VERSION_CODE
 static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 					     const char *name,
 					     unsigned char name_assign_type,
 					     enum nl80211_iftype type,
+					     u32 *flags,
 					     struct vif_params *params)
+#elif KERNEL_VERSION(3, 7, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#else
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#endif
 {
-	struct wilc_vif *vif;
-	struct wilc_priv *priv;
-	struct net_device *new_ifc = NULL;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->wdev->netdev);
+	struct net_device *new_ifc;
 
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->wdev->netdev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding monitor interface[%p]\n",
+		   priv->wdev->netdev);
 
 	if (type == NL80211_IFTYPE_MONITOR) {
-		new_ifc = WILC_WFI_init_mon_interface(name, vif->ndev);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Initializing mon ifc virtual device driver\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding monitor interface[%p]\n", vif->ndev);
+		new_ifc = wilc_wfi_init_mon_interface(name, vif->ndev);
 		if (new_ifc) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+			"Setting monitor flag in private structure\n");
 			vif = netdev_priv(priv->wdev->netdev);
 			vif->monitor_flag = 1;
+		} else {
+			PRINT_ER(vif->ndev,
+				 "Error in initializing monitor interface\n");
 		}
 	}
 	return priv->wdev;
@@ -2085,18 +2583,22 @@ static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 
 static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 {
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+
+	PRINT_INFO(priv->dev, HOSTAPD_DBG, "Deleting virtual interface\n");
 	return 0;
 }
 
 static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
 {
 	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	if (!wow && wilc_wlan_get_num_conn_ifcs(vif->wilc))
-		vif->wilc->suspend_event = true;
-	else
-		vif->wilc->suspend_event = false;
+	if (!wow)
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "No wake up triggers defined\n");
+	else if (wow->any == 0)
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "The only supported wake up trigger (any) is not set\n");
 
 	return 0;
 }
@@ -2106,7 +2608,7 @@ static int wilc_resume(struct wiphy *wiphy)
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	netdev_info(vif->ndev, "cfg resume\n");
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "cfg resume\n");
 	return 0;
 }
 
@@ -2115,7 +2617,8 @@ static void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	netdev_info(vif->ndev, "cfg set wake up = %d\n", enabled);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "cfg set wake up = %d\n", enabled);
+	host_int_set_wowlan_trigger(vif, (u8)enabled);
 }
 
 static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
@@ -2126,13 +2629,14 @@ static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(priv->dev);
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting tx power %d\n", tx_power);
 	if (tx_power < 0)
 		tx_power = 0;
 	else if (tx_power > 18)
 		tx_power = 18;
 	ret = wilc_set_tx_power(vif, tx_power);
 	if (ret)
-		netdev_err(vif->ndev, "Failed to set tx power\n");
+		PRINT_ER(vif->ndev, "Failed to set tx power\n");
 
 	return ret;
 }
@@ -2143,17 +2647,34 @@ static int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 	int ret;
 	struct wilc_priv *priv = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(priv->dev);
-	struct wilc *wl;
-
-	wl = vif->wilc;
+	struct wilc *wl = vif->wilc;
 
 	/* If firmware is not started, return. */
 	if (!wl->initialized)
 		return -EIO;
-
+	*dbm = 0;
 	ret = wilc_get_tx_power(vif, (u8 *)dbm);
 	if (ret)
-		netdev_err(vif->ndev, "Failed to get tx power\n");
+		PRINT_ER(vif->ndev, "Failed to get tx power\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Got tx power %d\n", *dbm);
+
+	return ret;
+}
+
+static int set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	int ret;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Select antenna mode %d\n", tx_ant);
+	if (!tx_ant || !rx_ant)
+		return -EINVAL;
+
+	ret = wilc_set_antenna(vif, (u8)(tx_ant-1));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx antenna\n");
 
 	return ret;
 }
@@ -2198,60 +2719,76 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.set_wakeup = wilc_set_wakeup,
 	.set_tx_power = set_tx_power,
 	.get_tx_power = get_tx_power,
-
+	.set_antenna = set_antenna,
 };
 
-static struct wireless_dev *WILC_WFI_CfgAlloc(void)
+static struct wireless_dev *wilc_wfi_cfg_alloc(struct net_device *net)
 {
 	struct wireless_dev *wdev;
 
-	wdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);
-	if (!wdev)
-		goto _fail_;
+	PRINT_INFO(net, CFG80211_DBG, "Allocating wireless device\n");
+	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
+	if (!wdev) {
+		PRINT_ER(net, "Cannot allocate wireless device\n");
+		goto out;
+	}
 
 	wdev->wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(struct wilc_priv));
-	if (!wdev->wiphy)
-		goto _fail_mem_;
-
-	WILC_WFI_band_2ghz.ht_cap.ht_supported = 1;
-	WILC_WFI_band_2ghz.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
-	WILC_WFI_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-	WILC_WFI_band_2ghz.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
-	WILC_WFI_band_2ghz.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
+	if (!wdev->wiphy) {
+		PRINT_ER(net, "Cannot allocate wiphy\n");
+		goto free_mem;
+	}
 
-	wdev->wiphy->bands[NL80211_BAND_2GHZ] = &WILC_WFI_band_2ghz;
+	wilc_band_2ghz.ht_cap.ht_supported = 1;
+	wilc_band_2ghz.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+	wilc_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
+	wilc_band_2ghz.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
+	wilc_band_2ghz.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
 
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+	wdev->wiphy->bands[NL80211_BAND_2GHZ] = &wilc_band_2ghz;
+#else
+	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &wilc_band_2ghz;
+#endif
 	return wdev;
 
-_fail_mem_:
+free_mem:
 	kfree(wdev);
-_fail_:
+out:
 	return NULL;
 }
 
-struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *dev)
+struct wireless_dev *wilc_create_wiphy(struct net_device *net,
+				       struct device *dev)
 {
 	struct wilc_priv *priv;
 	struct wireless_dev *wdev;
-	s32 s32Error = 0;
+	int ret;
 
-	wdev = WILC_WFI_CfgAlloc();
+	PRINT_INFO(net, CFG80211_DBG, "Registering wifi device\n");
+	wdev = wilc_wfi_cfg_alloc(net);
 	if (!wdev) {
-		netdev_err(net, "wiphy new allocate failed\n");
+		PRINT_ER(net, "wiphy new allocate failed\n");
 		return NULL;
 	}
 
 	priv = wdev_priv(wdev);
 	priv->wdev = wdev;
 	wdev->wiphy->max_scan_ssids = MAX_NUM_PROBED_SSID;
-#ifdef CONFIG_PM
+#if KERNEL_VERSION(3, 11, 0) <= LINUX_VERSION_CODE
 	wdev->wiphy->wowlan = &wowlan_support;
+#else
+	wdev->wiphy->wowlan = wowlan_support;
 #endif
 	wdev->wiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;
+	PRINT_D(net, CFG80211_DBG, "Max number of PMKIDs = %d\n",
+		wdev->wiphy->max_num_pmkids);
 	wdev->wiphy->max_scan_ie_len = 1000;
 	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 	wdev->wiphy->cipher_suites = cipher_suites;
 	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
+	wdev->wiphy->available_antennas_tx = 0x3;
+	wdev->wiphy->available_antennas_rx = 0x3;
 	wdev->wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
 
 	wdev->wiphy->max_remain_on_channel_duration = 500;
@@ -2263,11 +2800,21 @@ struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *de
 	wdev->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 	wdev->iftype = NL80211_IFTYPE_STATION;
 
+	PRINT_D(net, CFG80211_DBG,
+		"Max scan ids= %d,Max scan IE len= %d,Signal Type= %d,Interface Modes= %d,Interface Type= %d\n",
+		wdev->wiphy->max_scan_ssids, wdev->wiphy->max_scan_ie_len,
+		wdev->wiphy->signal_type, wdev->wiphy->interface_modes,
+		wdev->iftype);
+
 	set_wiphy_dev(wdev->wiphy, dev);
 
-	s32Error = wiphy_register(wdev->wiphy);
-	if (s32Error)
-		netdev_err(net, "Cannot register wiphy device\n");
+	ret = wiphy_register(wdev->wiphy);
+	if (ret) {
+		PRINT_ER(net, "Cannot register wiphy device\n");
+		wiphy_free(wdev->wiphy);
+		kfree(wdev);
+		return NULL;
+	}
 
 	priv->dev = net;
 	return wdev;
@@ -2275,69 +2822,80 @@ struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *de
 
 int wilc_init_host_int(struct net_device *net)
 {
-	int s32Error = 0;
-
-	struct wilc_priv *priv;
-
-	priv = wdev_priv(net->ieee80211_ptr);
-	if (op_ifcs == 0) {
-		setup_timer(&hAgingTimer, remove_network_from_shadow, 0);
-		setup_timer(&wilc_during_ip_timer, clear_duringIP, 0);
-	}
-	op_ifcs++;
+	int ret;
+	struct wilc_priv *priv = wdev_priv(net->ieee80211_ptr);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	priv->gbAutoRateAdjusted = false;
+	PRINT_INFO(net, INIT_DBG, "Host[%p][%p]\n", net, net->ieee80211_ptr);
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	timer_setup(&vif->during_ip_timer, clear_during_ip, 0);
+	#endif
+	timer_setup(&priv->eap_buff_timer, eap_buff_timeout, 0);
+	timer_setup(&priv->aging_timer, remove_network_from_shadow, 0);
+#else
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	setup_timer(&vif->during_ip_timer, clear_during_ip, 0);
+	#endif
+	setup_timer(&priv->eap_buff_timer, eap_buff_timeout, 0);
+	setup_timer(&priv->aging_timer, remove_network_from_shadow, 0);
+#endif
 
-	priv->bInP2PlistenState = false;
+	priv->p2p_listen_state = false;
 
 	mutex_init(&priv->scan_req_lock);
-	s32Error = wilc_init(net, &priv->hif_drv);
-	if (s32Error)
-		netdev_err(net, "Error while initializing hostinterface\n");
+	ret = wilc_init(net, &priv->hif_drv);
+	if (ret)
+		PRINT_ER(net, "Error while initializing hostinterface\n");
 
-	return s32Error;
+	return ret;
 }
 
-int wilc_deinit_host_int(struct net_device *net)
+void wilc_deinit_host_int(struct net_device *net)
 {
-	int s32Error = 0;
-	struct wilc_vif *vif;
-	struct wilc_priv *priv;
-
-	priv = wdev_priv(net->ieee80211_ptr);
-	vif = netdev_priv(priv->dev);
-
-	priv->gbAutoRateAdjusted = false;
-
-	priv->bInP2PlistenState = false;
+	int ret;
+	struct wilc_priv *priv = wdev_priv(net->ieee80211_ptr);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
 
-	op_ifcs--;
+	priv->p2p_listen_state = false;
 
-	s32Error = wilc_deinit(vif);
+	mutex_destroy(&priv->scan_req_lock);
+	ret = wilc_deinit(vif);
 
-	clear_shadow_scan();
-	if (op_ifcs == 0)
-		del_timer_sync(&wilc_during_ip_timer);
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	del_timer_sync(&vif->during_ip_timer);
+#endif
+	del_timer_sync(&priv->eap_buff_timer);
+	del_timer_sync(&priv->aging_timer);
 
-	if (s32Error)
-		netdev_err(net, "Error while deinitializing host interface\n");
+	clear_shadow_scan(priv);
 
-	return s32Error;
+	if (ret)
+		PRINT_ER(net, "Error while deinitializing host interface\n");
 }
 
 void wilc_free_wiphy(struct net_device *net)
 {
-	if (!net)
+	PRINT_INFO(net, CFG80211_DBG, "Unregistering wiphy\n");
+	if (!net) {
+		PRINT_INFO(net, INIT_DBG, "net_device is NULL\n");
 		return;
+	}
 
-	if (!net->ieee80211_ptr)
+	if (!net->ieee80211_ptr) {
+		PRINT_INFO(net, INIT_DBG, "ieee80211_ptr is NULL\n");
 		return;
+	}
 
-	if (!net->ieee80211_ptr->wiphy)
+	if (!net->ieee80211_ptr->wiphy) {
+		PRINT_INFO(net, INIT_DBG, "wiphy is NULL\n");
 		return;
+	}
 
 	wiphy_unregister(net->ieee80211_ptr->wiphy);
 
+	PRINT_INFO(net, INIT_DBG, "Freeing wiphy\n");
 	wiphy_free(net->ieee80211_ptr->wiphy);
 	kfree(net->ieee80211_ptr);
 }
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
index dfb7ec272935..e9115a6e1a79 100644
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
+++ b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
@@ -1,24 +1,38 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/*!
- *  @file	wilc_wfi_cfgoperations.h
- *  @brief	Definitions for the network module
- *  @author	syounan
- *  @sa		wilc_oswrapper.h top level OS wrapper file
- *  @date	31 Aug 2010
- *  @version	1.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
+
 #ifndef NM_WFI_CFGOPERATIONS
 #define NM_WFI_CFGOPERATIONS
 #include "wilc_wfi_netdevice.h"
 
-struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *dev);
+#define NO_ENCRYPT		0
+
+extern struct net_device *wilc_wfi_mon; /* global monitor netdev */
+
+struct wireless_dev *wilc_create_wiphy(struct net_device *net,
+				       struct device *dev);
 void wilc_free_wiphy(struct net_device *net);
-int wilc_deinit_host_int(struct net_device *net);
+void wilc_deinit_host_int(struct net_device *net);
 int wilc_init_host_int(struct net_device *net);
-void WILC_WFI_monitor_rx(u8 *buff, u32 size);
-int WILC_WFI_deinit_mon_interface(void);
-struct net_device *WILC_WFI_init_mon_interface(const char *name, struct net_device *real_dev);
+void wilc_wfi_monitor_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+void wilc_wfi_deinit_mon_interface(void);
+struct net_device *wilc_wfi_init_mon_interface(const char *name,
+					       struct net_device *real_dev);
 void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 			      u16 frame_type, bool reg);
+void wilc_sysfs_init(struct wilc_vif *vif1, struct wilc_vif *vif2);
+void wilc_sysfs_exit(void);
+void filter_shadow_scan(struct wilc_priv *priv, u8 *ch_freq_list,
+			u8 ch_list_len);
+
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void remove_network_from_shadow(struct timer_list *t);
+#else
+void remove_network_from_shadow(unsigned long arg);
+#endif
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wfi_netdevice.h b/drivers/staging/wilc1000/wilc_wfi_netdevice.h
index e6f4d84971c3..12f48f3b46b1 100644
--- a/drivers/staging/wilc1000/wilc_wfi_netdevice.h
+++ b/drivers/staging/wilc1000/wilc_wfi_netdevice.h
@@ -1,76 +1,57 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/*!
- *  @file	wilc_wfi_netdevice.h
- *  @brief	Definitions for the network module
- *  @author	mdaftedar
- *  @date	01 MAR 2012
- *  @version	1.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
  */
+
 #ifndef WILC_WFI_NETDEVICE
 #define WILC_WFI_NETDEVICE
 
-#define WILC_WFI_RX_INTR 0x0001
-#define WILC_WFI_TX_INTR 0x0002
-
-#define WILC_WFI_TIMEOUT 5
-#define WILC_MAX_NUM_PMKIDS  16
-#define PMKID_LEN  16
-#define PMKID_FOUND 1
- #define NUM_STA_ASSOCIATED 8
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/moduleparam.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/in.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/ip.h>
 #include <linux/tcp.h>
-#include <linux/skbuff.h>
 #include <linux/ieee80211.h>
 #include <net/cfg80211.h>
 #include <net/ieee80211_radiotap.h>
 #include <linux/if_arp.h>
-#include <linux/in6.h>
-#include <asm/checksum.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+#include <linux/gpio/consumer.h>
+#else
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#endif
+
 #include "host_interface.h"
 #include "wilc_wlan.h"
-#include <linux/wireless.h>
-#include <linux/completion.h>
-#include <linux/mutex.h>
+#include "wilc_wlan_cfg.h"
 
-#define FLOW_CONTROL_LOWER_THRESHOLD	128
-#define FLOW_CONTROL_UPPER_THRESHOLD	256
+#define FLOW_CTRL_LOW_THRESHLD		128
+#define FLOW_CTRL_UP_THRESHLD		256
 
-enum stats_flags {
-	WILC_WFI_RX_PKT = BIT(0),
-	WILC_WFI_TX_PKT = BIT(1),
-};
+#define WILC_MAX_NUM_PMKIDS			16
+#define PMKID_LEN				16
+#define PMKID_FOUND				1
+#define NUM_STA_ASSOCIATED			8
+
+#define NUM_REG_FRAME				2
 
-struct WILC_WFI_stats {
+#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
+#define DEFAULT_LINK_SPEED			72
+
+#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
+
+#define ANT_SWTCH_INVALID_GPIO_CTRL		0
+#define ANT_SWTCH_SNGL_GPIO_CTRL		1
+#define ANT_SWTCH_DUAL_GPIO_CTRL		2
+
+struct wilc_wfi_stats {
 	unsigned long rx_packets;
 	unsigned long tx_packets;
 	unsigned long rx_bytes;
 	unsigned long tx_bytes;
 	u64 rx_time;
 	u64 tx_time;
-
 };
 
-/*
- * This structure is private to each device. It is used to pass
- * packets in and out, so there is place for a packet
- */
-
-#define num_reg_frame 2
-
 struct wilc_wfi_key {
 	u8 *key;
 	u8 *seq;
@@ -86,59 +67,62 @@ struct wilc_wfi_wep_key {
 };
 
 struct sta_info {
-	u8 au8Sta_AssociatedBss[MAX_NUM_STA][ETH_ALEN];
+	u8 sta_associated_bss[MAX_NUM_STA][ETH_ALEN];
 };
 
 /*Parameters needed for host interface for  remaining on channel*/
-struct wilc_wfi_p2pListenParams {
-	struct ieee80211_channel *pstrListenChan;
-	enum nl80211_channel_type tenuChannelType;
-	u32 u32ListenDuration;
-	u64 u64ListenCookie;
-	u32 u32ListenSessionID;
+struct wilc_wfi_p2p_listen_params {
+	struct ieee80211_channel *listen_ch;
+	u32 listen_duration;
+	u64 listen_cookie;
+	u32 listen_session_id;
 };
 
-struct wilc_priv {
-	struct wireless_dev *wdev;
-	struct cfg80211_scan_request *pstrScanReq;
+/* Struct to buffer eapol 1/4 frame */
+struct wilc_buffered_eap {
+	unsigned int size;
+	unsigned int pkt_offset;
+	u8 *buff;
+};
 
-	struct wilc_wfi_p2pListenParams strRemainOnChanParams;
-	u64 u64tx_cookie;
+struct wilc_p2p_var {
+	u8 local_random;
+	u8 recv_random;
+	bool is_wilc_ie;
+};
 
-	bool bCfgScanning;
-	u32 u32RcvdChCount;
+struct wilc_priv {
+	struct wireless_dev *wdev;
+	struct cfg80211_scan_request *scan_req;
+	struct wilc_wfi_p2p_listen_params remain_on_ch_params;
+	u64 tx_cookie;
+	bool cfg_scanning;
+	u32 rcvd_ch_cnt;
 
-	u8 au8AssociatedBss[ETH_ALEN];
+	u8 associated_bss[ETH_ALEN];
 	struct sta_info assoc_stainfo;
-	struct net_device_stats stats;
-	u8 monitor_flag;
-	int status;
-	struct WILC_WFI_packet *ppool;
-	struct WILC_WFI_packet *rx_queue; /* List of incoming packets */
-	int rx_int_enabled;
-	int tx_packetlen;
-	u8 *tx_packetdata;
 	struct sk_buff *skb;
-	spinlock_t lock;
 	struct net_device *dev;
-	struct napi_struct napi;
 	struct host_if_drv *hif_drv;
 	struct host_if_pmkid_attr pmkid_list;
-	struct WILC_WFI_stats netstats;
-	u8 WILC_WFI_wep_key[4][WLAN_KEY_LEN_WEP104];
-	u8 WILC_WFI_wep_key_len[4];
+	u8 wep_key[4][WLAN_KEY_LEN_WEP104];
+	u8 wep_key_len[4];
 	/* The real interface that the monitor is on */
 	struct net_device *real_ndev;
 	struct wilc_wfi_key *wilc_gtk[MAX_NUM_STA];
 	struct wilc_wfi_key *wilc_ptk[MAX_NUM_STA];
 	u8 wilc_groupkey;
-	/* mutexes */
+
 	struct mutex scan_req_lock;
-	/*  */
-	bool gbAutoRateAdjusted;
 
-	bool bInP2PlistenState;
+	bool p2p_listen_state;
+	struct wilc_buffered_eap *buffered_eap;
 
+	struct timer_list aging_timer;
+	struct timer_list eap_buff_timer;
+	struct network_info scanned_shadow[MAX_NUM_SCANNED_NETWORKS_SHADOW];
+	int scanned_cnt;
+	struct wilc_p2p_var p2p;
 };
 
 struct frame_reg {
@@ -146,46 +130,95 @@ struct frame_reg {
 	bool reg;
 };
 
+#define MAX_TCP_SESSION                25
+#define MAX_PENDING_ACKS               256
+
+struct ack_session_info {
+	u32 seq_num;
+	u32 bigger_ack_num;
+	u16 src_port;
+	u16 dst_port;
+	u16 status;
+};
+
+struct pending_acks {
+	u32 ack_num;
+	u32 session_index;
+	struct txq_entry_t  *txqe;
+};
+
+struct tcp_ack_filter {
+	struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
+	struct pending_acks pending_acks[MAX_PENDING_ACKS];
+	u32 pending_base;
+	u32 tcp_session;
+	u32 pending_acks_idx;
+	bool enabled;
+};
+
+struct sysfs_attr_group {
+	bool p2p_mode;
+	u8 ant_swtch_mode;
+	u8 antenna1;
+	u8 antenna2;
+};
+
 struct wilc_vif {
 	u8 idx;
 	u8 iftype;
 	int monitor_flag;
 	int mac_opened;
-	struct frame_reg frame_reg[num_reg_frame];
+	struct frame_reg frame_reg[NUM_REG_FRAME];
 	struct net_device_stats netstats;
 	struct wilc *wilc;
-	u8 src_addr[ETH_ALEN];
 	u8 bssid[ETH_ALEN];
 	struct host_if_drv *hif_drv;
 	struct net_device *ndev;
-	u8 mode;
 	u8 ifc_id;
+
+	struct sysfs_attr_group attr_sysfs;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	bool pwrsave_current_state;
+	struct timer_list during_ip_timer;
+	bool obtaining_ip;
+#endif
+	struct rf_info periodic_stats;
+	struct timer_list periodic_rssi;
+	struct tcp_ack_filter ack_filter;
+	bool connecting;
 };
 
 struct wilc {
 	const struct wilc_hif_func *hif_func;
 	int io_type;
-	int mac_status;
-	int gpio;
+	s8 mac_status;
+#if KERNEL_VERSION(3, 13, 0) < LINUX_VERSION_CODE
+	struct gpio_desc *gpio_irq;
+#else
+	int gpio_irq;
+#endif
 	bool initialized;
 	int dev_irq_num;
 	int close;
 	u8 vif_num;
 	struct wilc_vif *vif[NUM_CONCURRENT_IFC];
 	u8 open_ifcs;
-
+	/*protect head of transmit queue*/
 	struct mutex txq_add_to_head_cs;
+	/*protect txq_entry_t transmit queue*/
 	spinlock_t txq_spinlock;
-
+	/*protect rxq_entry_t receiver queue*/
 	struct mutex rxq_cs;
+	/* lock to protect hif access */
 	struct mutex hif_cs;
 
 	struct completion cfg_event;
 	struct completion sync_event;
 	struct completion txq_event;
 	struct completion txq_thread_started;
-
+	struct completion debug_thread_started;
 	struct task_struct *txq_thread;
+	struct task_struct *debug_thread;
 
 	int quit;
 	int cfg_frame_in_use;
@@ -197,42 +230,39 @@ struct wilc {
 	u32 rx_buffer_offset;
 	u8 *tx_buffer;
 
-	unsigned long txq_spinlock_flags;
-
-	struct txq_entry_t *txq_head;
-	struct txq_entry_t *txq_tail;
+	struct txq_handle txq[NQUEUES];
 	int txq_entries;
-	int txq_exit;
-
-	struct rxq_entry_t *rxq_head;
-	struct rxq_entry_t *rxq_tail;
-	int rxq_entries;
-	int rxq_exit;
 
-	unsigned char eth_src_address[NUM_CONCURRENT_IFC][6];
+	struct rxq_entry_t rxq_head;
 
 	const struct firmware *firmware;
 
 	struct device *dev;
-	bool suspend_event;
+	struct device *dt_dev;
+
+	enum wilc_chip_type chip;
 
-	struct rf_info dummy_statistics;
+	uint8_t power_status[DEV_MAX];
+	uint8_t keep_awake[DEV_MAX];
+	struct mutex cs;
+	int clients_count;
+	struct workqueue_struct *hif_workqueue;
+
+	struct wilc_cfg cfg;
+	void *bus_data;
 };
 
-struct WILC_WFI_mon_priv {
+struct wilc_wfi_mon_priv {
 	struct net_device *real_ndev;
 };
 
-int wilc1000_wlan_init(struct net_device *dev, struct wilc_vif *vif);
-
-void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset);
-void wilc_mac_indicate(struct wilc *wilc, int flag);
+void wilc_frmw_to_linux(struct wilc_vif *vif, u8 *buff, u32 size,
+			u32 pkt_offset, u8 status);
+void wilc_mac_indicate(struct wilc *wilc);
 void wilc_netdev_cleanup(struct wilc *wilc);
 int wilc_netdev_init(struct wilc **wilc, struct device *dev, int io_type,
-		     int gpio, const struct wilc_hif_func *ops);
-void wilc1000_wlan_deinit(struct net_device *dev);
-void WILC_WFI_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
-int wilc_wlan_get_firmware(struct net_device *dev);
-int wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
+		     const struct wilc_hif_func *ops);
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
+void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
index f49dfa82f1b8..60cc6ef0b054 100644
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ b/drivers/staging/wilc1000/wilc_wlan.c
@@ -1,99 +1,98 @@
-#include <linux/completion.h>
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+#include <linux/ip.h>
+
 #include "wilc_wfi_netdevice.h"
 #include "wilc_wlan_cfg.h"
+#include "linux_wlan.h"
 
-static CHIP_PS_STATE_T chip_ps_state = CHIP_WAKEDUP;
+#define WAKUP_TRAILS_TIMEOUT		(10000)
 
-static inline void acquire_bus(struct wilc *wilc, BUS_ACQUIRE_T acquire)
+#if KERNEL_VERSION(3, 12, 21) > LINUX_VERSION_CODE
+#define list_next_entry(pos, member) \
+	list_entry((pos)->member.next, typeof(*(pos)), member)
+#endif
+
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source)
 {
 	mutex_lock(&wilc->hif_cs);
 	if (acquire == ACQUIRE_AND_WAKEUP)
-		chip_wakeup(wilc);
+		chip_wakeup(wilc, source);
 }
 
-static inline void release_bus(struct wilc *wilc, BUS_RELEASE_T release)
+void release_bus(struct wilc *wilc, enum bus_release release, int source)
 {
 	if (release == RELEASE_ALLOW_SLEEP)
-		chip_allow_sleep(wilc);
+		chip_allow_sleep(wilc, source);
 	mutex_unlock(&wilc->hif_cs);
 }
 
-static void wilc_wlan_txq_remove(struct wilc *wilc, struct txq_entry_t *tqe)
+uint8_t reset_bus(struct wilc *wilc)
 {
-	if (tqe == wilc->txq_head) {
-		wilc->txq_head = tqe->next;
-		if (wilc->txq_head)
-			wilc->txq_head->prev = NULL;
-	} else if (tqe == wilc->txq_tail) {
-		wilc->txq_tail = (tqe->prev);
-		if (wilc->txq_tail)
-			wilc->txq_tail->next = NULL;
-	} else {
-		tqe->prev->next = tqe->next;
-		tqe->next->prev = tqe->prev;
-	}
+	uint8_t ret = 0;
+
+	if (wilc->io_type == HIF_SPI)
+		return wilc->hif_func->hif_reset(wilc);
+	return ret;
+}
+
+static void wilc_wlan_txq_remove(struct wilc *wilc, u8 q_num,
+				 struct txq_entry_t *tqe)
+{
+	list_del(&tqe->list);
 	wilc->txq_entries -= 1;
+	wilc->txq[q_num].count--;
 }
 
 static struct txq_entry_t *
-wilc_wlan_txq_remove_from_head(struct net_device *dev)
+wilc_wlan_txq_remove_from_head(struct net_device *dev, u8 q_num)
 {
-	struct txq_entry_t *tqe;
+	struct txq_entry_t *tqe = NULL;
 	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-	if (wilc->txq_head) {
-		tqe = wilc->txq_head;
-		wilc->txq_head = tqe->next;
-		if (wilc->txq_head)
-			wilc->txq_head->prev = NULL;
 
+	if (!list_empty(&wilc->txq[q_num].txq_head.list)) {
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
+		list_del(&tqe->list);
 		wilc->txq_entries -= 1;
-	} else {
-		tqe = NULL;
+		wilc->txq[q_num].count--;
 	}
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 	return tqe;
 }
 
-static void wilc_wlan_txq_add_to_tail(struct net_device *dev,
+static void wilc_wlan_txq_add_to_tail(struct net_device *dev, u8 q_num,
 				      struct txq_entry_t *tqe)
 {
 	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	if (!wilc->txq_head) {
-		tqe->next = NULL;
-		tqe->prev = NULL;
-		wilc->txq_head = tqe;
-		wilc->txq_tail = tqe;
-	} else {
-		tqe->next = NULL;
-		tqe->prev = wilc->txq_tail;
-		wilc->txq_tail->next = tqe;
-		wilc->txq_tail = tqe;
-	}
+	list_add_tail(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake the txq_handling\n");
 	complete(&wilc->txq_event);
 }
 
-static int wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
+static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif, u8 q_num,
 				     struct txq_entry_t *tqe)
 {
 	unsigned long flags;
@@ -103,169 +102,146 @@ static int wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	if (!wilc->txq_head) {
-		tqe->next = NULL;
-		tqe->prev = NULL;
-		wilc->txq_head = tqe;
-		wilc->txq_tail = tqe;
-	} else {
-		tqe->next = wilc->txq_head;
-		tqe->prev = NULL;
-		wilc->txq_head->prev = tqe;
-		wilc->txq_head = tqe;
-	}
+	list_add(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 	mutex_unlock(&wilc->txq_add_to_head_cs);
 	complete(&wilc->txq_event);
-
-	return 0;
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake up the txq_handler\n");
 }
 
-struct ack_session_info;
-struct ack_session_info {
-	u32 seq_num;
-	u32 bigger_ack_num;
-	u16 src_port;
-	u16 dst_port;
-	u16 status;
-};
-
-struct pending_acks_info {
-	u32 ack_num;
-	u32 session_index;
-	struct txq_entry_t  *txqe;
-};
-
 #define NOT_TCP_ACK			(-1)
 
-#define MAX_TCP_SESSION		25
-#define MAX_PENDING_ACKS		256
-static struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
-static struct pending_acks_info pending_acks_info[MAX_PENDING_ACKS];
-
-static u32 pending_base;
-static u32 tcp_session;
-static u32 pending_acks;
-
-static inline int add_tcp_session(u32 src_prt, u32 dst_prt, u32 seq)
+static inline void add_tcp_session(struct wilc_vif *vif, u32 src_prt,
+				  u32 dst_prt, u32 seq)
 {
-	if (tcp_session < 2 * MAX_TCP_SESSION) {
-		ack_session_info[tcp_session].seq_num = seq;
-		ack_session_info[tcp_session].bigger_ack_num = 0;
-		ack_session_info[tcp_session].src_port = src_prt;
-		ack_session_info[tcp_session].dst_port = dst_prt;
-		tcp_session++;
+	struct tcp_ack_filter *f = &vif->ack_filter;
+
+	if (f->tcp_session < 2 * MAX_TCP_SESSION) {
+		f->ack_session_info[f->tcp_session].seq_num = seq;
+		f->ack_session_info[f->tcp_session].bigger_ack_num = 0;
+		f->ack_session_info[f->tcp_session].src_port = src_prt;
+		f->ack_session_info[f->tcp_session].dst_port = dst_prt;
+		f->tcp_session++;
+		PRINT_INFO(vif->ndev, TCP_ENH, "TCP Session %d to Ack %d\n",
+			   f->tcp_session, seq);
 	}
-	return 0;
 }
 
-static inline int update_tcp_session(u32 index, u32 ack)
+static inline void update_tcp_session(struct wilc_vif *vif, u32 index, u32 ack)
 {
+	struct tcp_ack_filter *f = &vif->ack_filter;
+
 	if (index < 2 * MAX_TCP_SESSION &&
-	    ack > ack_session_info[index].bigger_ack_num)
-		ack_session_info[index].bigger_ack_num = ack;
-	return 0;
+	    ack > f->ack_session_info[index].bigger_ack_num)
+		f->ack_session_info[index].bigger_ack_num = ack;
 }
 
-static inline int add_tcp_pending_ack(u32 ack, u32 session_index,
+static inline void add_tcp_pending_ack(struct wilc_vif *vif, u32 ack,
+				      u32 session_index,
 				      struct txq_entry_t *txqe)
 {
-	if (pending_base + pending_acks < MAX_PENDING_ACKS) {
-		pending_acks_info[pending_base + pending_acks].ack_num = ack;
-		pending_acks_info[pending_base + pending_acks].txqe = txqe;
-		pending_acks_info[pending_base + pending_acks].session_index = session_index;
-		txqe->tcp_pending_ack_idx = pending_base + pending_acks;
-		pending_acks++;
+	struct tcp_ack_filter *f = &vif->ack_filter;
+	u32 i = f->pending_base + f->pending_acks_idx;
+
+	if (i < MAX_PENDING_ACKS) {
+		f->pending_acks[i].ack_num = ack;
+		f->pending_acks[i].txqe = txqe;
+		f->pending_acks[i].session_index = session_index;
+		txqe->ack_idx = i;
+		f->pending_acks_idx++;
 	}
-	return 0;
 }
 
 static inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)
 {
-	u8 *eth_hdr_ptr;
-	u8 *buffer = tqe->buffer;
-	unsigned short h_proto;
+	void *buffer = tqe->buffer;
+	const struct ethhdr *eth_hdr_ptr = buffer;
 	int i;
 	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	struct tcp_ack_filter *f = &vif->ack_filter;
+	const struct iphdr *ip_hdr_ptr;
+	const struct tcphdr *tcp_hdr_ptr;
+	u32 ihl, total_length, data_offset;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	eth_hdr_ptr = &buffer[0];
-	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
-	if (h_proto == ETH_P_IP) {
-		u8 *ip_hdr_ptr;
-		u8 protocol;
+	if (eth_hdr_ptr->h_proto != htons(ETH_P_IP))
+		goto out;
 
-		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
-		protocol = ip_hdr_ptr[9];
-
-		if (protocol == 0x06) {
-			u8 *tcp_hdr_ptr;
-			u32 IHL, total_length, data_offset;
-
-			tcp_hdr_ptr = &ip_hdr_ptr[IP_HDR_LEN];
-			IHL = (ip_hdr_ptr[0] & 0xf) << 2;
-			total_length = ((u32)ip_hdr_ptr[2] << 8) +
-					(u32)ip_hdr_ptr[3];
-			data_offset = ((u32)tcp_hdr_ptr[12] & 0xf0) >> 2;
-			if (total_length == (IHL + data_offset)) {
-				u32 seq_no, ack_no;
-
-				seq_no = ((u32)tcp_hdr_ptr[4] << 24) +
-					 ((u32)tcp_hdr_ptr[5] << 16) +
-					 ((u32)tcp_hdr_ptr[6] << 8) +
-					 (u32)tcp_hdr_ptr[7];
-
-				ack_no = ((u32)tcp_hdr_ptr[8] << 24) +
-					 ((u32)tcp_hdr_ptr[9] << 16) +
-					 ((u32)tcp_hdr_ptr[10] << 8) +
-					 (u32)tcp_hdr_ptr[11];
-
-				for (i = 0; i < tcp_session; i++) {
-					if (i < 2 * MAX_TCP_SESSION &&
-					    ack_session_info[i].seq_num == seq_no) {
-						update_tcp_session(i, ack_no);
-						break;
-					}
-				}
-				if (i == tcp_session)
-					add_tcp_session(0, 0, seq_no);
+	ip_hdr_ptr = buffer + ETH_HLEN;
+
+	if (ip_hdr_ptr->protocol != IPPROTO_TCP)
+		goto out;
 
-				add_tcp_pending_ack(ack_no, i, tqe);
+	ihl = ip_hdr_ptr->ihl << 2;
+	tcp_hdr_ptr = buffer + ETH_HLEN + ihl;
+	total_length = ntohs(ip_hdr_ptr->tot_len);
+
+	data_offset = tcp_hdr_ptr->doff << 2;
+	if (total_length == (ihl + data_offset)) {
+		u32 seq_no, ack_no;
+
+		seq_no = ntohl(tcp_hdr_ptr->seq);
+		ack_no = ntohl(tcp_hdr_ptr->ack_seq);
+		for (i = 0; i < f->tcp_session; i++) {
+			u32 j = f->ack_session_info[i].seq_num;
+
+			if (i < 2 * MAX_TCP_SESSION &&
+			    j == seq_no) {
+				update_tcp_session(vif, i, ack_no);
+				break;
 			}
 		}
+		if (i == f->tcp_session)
+			add_tcp_session(vif, 0, 0, seq_no);
+
+		add_tcp_pending_ack(vif, ack_no, i, tqe);
 	}
+
+out:
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 }
 
-static int wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
+static void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
 {
-	struct wilc_vif *vif;
-	struct wilc *wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	struct tcp_ack_filter *f = &vif->ack_filter;
 	u32 i = 0;
 	u32 dropped = 0;
+	unsigned long flags;
 
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+	for (i = f->pending_base;
+	     i < (f->pending_base + f->pending_acks_idx); i++) {
+		u32 index;
+		u32 bigger_ack_num;
+
+		if (i >= MAX_PENDING_ACKS)
+			break;
+
+		index = f->pending_acks[i].session_index;
 
-	spin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
-	for (i = pending_base; i < (pending_base + pending_acks); i++) {
-		if (i >= MAX_PENDING_ACKS ||
-		    pending_acks_info[i].session_index >= 2 * MAX_TCP_SESSION)
+		if (index >= 2 * MAX_TCP_SESSION)
 			break;
-		if (pending_acks_info[i].ack_num < ack_session_info[pending_acks_info[i].session_index].bigger_ack_num) {
+
+		bigger_ack_num = f->ack_session_info[index].bigger_ack_num;
+
+		if (f->pending_acks[i].ack_num < bigger_ack_num) {
 			struct txq_entry_t *tqe;
 
-			tqe = pending_acks_info[i].txqe;
+			PRINT_INFO(vif->ndev, TCP_ENH, "DROP ACK: %u\n",
+				   f->pending_acks[i].ack_num);
+			tqe = f->pending_acks[i].txqe;
 			if (tqe) {
-				wilc_wlan_txq_remove(wilc, tqe);
+				wilc_wlan_txq_remove(wilc, tqe->q_num, tqe);
 				tqe->status = 1;
 				if (tqe->tx_complete_func)
 					tqe->tx_complete_func(tqe->priv,
@@ -275,30 +251,53 @@ static int wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
 			}
 		}
 	}
-	pending_acks = 0;
-	tcp_session = 0;
+	f->pending_acks_idx = 0;
+	f->tcp_session = 0;
 
-	if (pending_base == 0)
-		pending_base = MAX_TCP_SESSION;
+	if (f->pending_base == 0)
+		f->pending_base = MAX_TCP_SESSION;
 	else
-		pending_base = 0;
+		f->pending_base = 0;
 
-	spin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
 	while (dropped > 0) {
-		wait_for_completion_timeout(&wilc->txq_event,
-					    msecs_to_jiffies(1));
+		if (!wait_for_completion_timeout(&wilc->txq_event,
+						msecs_to_jiffies(1)))
+			PRINT_ER(vif->ndev, "completion timedout\n");
 		dropped--;
 	}
-
-	return 1;
 }
 
-static bool enabled;
+static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+{
+	u8 *bssid, *bssid1;
+	int i = 0;
+	struct net_device *mon_netdev = NULL;
+
+	bssid = mac_header + 10;
+	bssid1 = mac_header + 4;
+	for (i = 0; i <= wilc->vif_num; i++) {
+		if (wilc->vif[i]->iftype == STATION_MODE)
+			if (ether_addr_equal_unaligned(bssid,
+						       wilc->vif[i]->bssid))
+				return wilc->vif[i]->ndev;
+		if (wilc->vif[i]->iftype == AP_MODE)
+			if (ether_addr_equal_unaligned(bssid1,
+						       wilc->vif[i]->bssid))
+				return wilc->vif[i]->ndev;
+		if (wilc->vif[i]->iftype == MONITOR_MODE)
+			mon_netdev = wilc->vif[i]->ndev;
+	}
+
+	if (!mon_netdev)
+		PRINT_WRN(wilc->vif[0]->ndev, GENERIC_DBG, "Invalid handle\n");
+	return mon_netdev;
+}
 
-void wilc_enable_tcp_ack_filter(bool value)
+void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)
 {
-	enabled = value;
+	vif->ack_filter.enabled = value;
 }
 
 static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
@@ -307,62 +306,251 @@ static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
 	struct txq_entry_t *tqe;
 	struct wilc *wilc = vif->wilc;
 
-	netdev_dbg(vif->ndev, "Adding config packet ...\n");
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding config packet ...\n");
 	if (wilc->quit) {
-		netdev_dbg(vif->ndev, "Return due to clear function\n");
+		PRINT_INFO(vif->ndev, TX_DBG, "Return due to clear function\n");
 		complete(&wilc->cfg_event);
 		return 0;
 	}
 
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-	if (!tqe)
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not initialized\n");
+		complete(&wilc->cfg_event);
 		return 0;
-
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+	if (!tqe) {
+		complete(&wilc->cfg_event);
+		return 0;
+	}
 	tqe->type = WILC_CFG_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = NULL;
 	tqe->priv = NULL;
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
+	tqe->q_num = AC_VO_Q;
+	tqe->ack_idx = NOT_TCP_ACK;
 
-	if (wilc_wlan_txq_add_to_head(vif, tqe)) {
-		kfree(tqe);
-		return 0;
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Adding the config packet at the Queue tail\n");
+
+	wilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe);
+
+	return 1;
+}
+
+static void ac_q_limit(struct wilc *wilc, u8 ac, u16 *q_limit)
+{
+	static u8 buffer[AC_BUFFER_SIZE];
+	static u16 end_index;
+	static bool initialized;
+	static u16 cnt[NQUEUES];
+	u8 factors[NQUEUES] = {1, 1, 1, 1};
+	static u16 sum;
+	u16 i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+	if (!initialized) {
+		for (i = 0; i < AC_BUFFER_SIZE; i++)
+			buffer[i] = i % NQUEUES;
+
+		for (i = 0; i < NQUEUES; i++) {
+			cnt[i] = AC_BUFFER_SIZE * factors[i] / NQUEUES;
+			sum += cnt[i];
+		}
+		end_index = AC_BUFFER_SIZE - 1;
+		initialized = 1;
 	}
 
+	cnt[buffer[end_index]] -= factors[buffer[end_index]];
+	cnt[ac] += factors[ac];
+	sum += (factors[ac] - factors[buffer[end_index]]);
+
+	buffer[end_index] = ac;
+	if (end_index > 0)
+		end_index--;
+	else
+		end_index = AC_BUFFER_SIZE - 1;
+
+	for (i = 0; i < NQUEUES; i++) {
+		if (!sum)
+			q_limit[i] = 1;
+		else
+			q_limit[i] = (cnt[i] * FLOW_CTRL_UP_THRESHLD / sum) + 1;
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+}
+
+static inline u8 ac_classify(struct wilc *wilc, struct txq_entry_t *tqe)
+{
+	u8 *eth_hdr_ptr;
+	u8 *buffer = tqe->buffer;
+	u8 ac;
+	u16 h_proto;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	eth_hdr_ptr = &buffer[0];
+	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
+	if (h_proto == ETH_P_IP) {
+		u8 *ip_hdr_ptr;
+		u32 IHL, DSCP;
+
+		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
+		IHL = (ip_hdr_ptr[0] & 0xf) << 2;
+		DSCP = (ip_hdr_ptr[1] & 0xfc);
+
+		switch (DSCP) {
+		case 0x20:
+		case 0x40:
+		case 0x08:
+			ac = AC_BK_Q;
+			break;
+		case 0x80:
+		case 0xA0:
+		case 0x28:
+			ac = AC_VI_Q;
+			break;
+		case 0xC0:
+		case 0xd0:
+		case 0xE0:
+		case 0x88:
+		case 0xB8:
+			ac = AC_VO_Q;
+			break;
+		default:
+			ac = AC_BE_Q;
+			break;
+		}
+	} else {
+		ac  = AC_BE_Q;
+	}
+
+	tqe->q_num = ac;
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return ac;
+}
+
+static inline int ac_balance(u8 *count, u8 *ratio)
+{
+	u8 i, max_count = 0;
+
+	if (!count || !ratio)
+		return -1;
+
+	for (i = 0; i < NQUEUES; i++)
+		if (count[i] > max_count)
+			max_count = count[i];
+
+	for (i = 0; i < NQUEUES; i++)
+		ratio[i] = max_count - count[i];
+
+	return 0;
+}
+
+static inline void ac_pkt_count(u32 reg, u8 *pkt_count)
+{
+	pkt_count[AC_BK_Q] = (reg & 0x000000fa) >> BK_AC_COUNT_POS;
+	pkt_count[AC_BE_Q] = (reg & 0x0000fe00) >> BE_AC_COUNT_POS;
+	pkt_count[AC_VI_Q] = (reg & 0x00fe0000) >> VI_AC_COUNT_POS;
+	pkt_count[AC_VO_Q] = (reg & 0xfe000000) >> VO_AC_COUNT_POS;
+}
+
+static inline u8 ac_change(struct wilc *wilc, u8 *ac)
+{
+	do {
+		if (wilc->txq[*ac].acm == 0)
+			return 0;
+		(*ac)++;
+	} while (*ac < NQUEUES);
 	return 1;
 }
 
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+static inline void ac_acm_bit(struct wilc *wilc, u32 reg)
+{
+	wilc->txq[AC_BK_Q].acm = (reg & 0x00000002) >> BK_AC_ACM_STAT_POS;
+	wilc->txq[AC_BE_Q].acm = (reg & 0x00000100) >> BE_AC_ACM_STAT_POS;
+	wilc->txq[AC_VI_Q].acm = (reg & 0x00010000) >> VI_AC_ACM_STAT_POS;
+	wilc->txq[AC_VO_Q].acm = (reg & 0x01000000) >> VO_AC_ACM_STAT_POS;
+}
+
+int txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			      u32 buffer_size, wilc_tx_complete_func_t func)
 {
 	struct txq_entry_t *tqe;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc;
+	u8 q_num;
+	u16 q_limit[NQUEUES] = {0, 0, 0, 0};
+
+	if (!vif) {
+		pr_info("%s vif is NULL\n", __func__);
+		return -1;
+	}
 
 	wilc = vif->wilc;
 
-	if (wilc->quit)
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "drv is quitting, return from net_pkt\n");
+		func(priv, 0);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "not_init, return from net_pkt\n");
+		func(priv, 0);
 		return 0;
+	}
 
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
 
-	if (!tqe)
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "malloc failed, return from net_pkt\n");
+		func(priv, 0);
 		return 0;
+	}
 	tqe->type = WILC_NET_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = func;
 	tqe->priv = priv;
 
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
-	if (enabled)
-		tcp_process(dev, tqe);
-	wilc_wlan_txq_add_to_tail(dev, tqe);
+	q_num = ac_classify(wilc, tqe);
+	if (ac_change(wilc, &q_num)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "No suitable non-ACM queue\n");
+		kfree(tqe);
+		return 0;
+	}
+	ac_q_limit(wilc, q_num, q_limit);
+
+	if ((q_num == AC_VO_Q && wilc->txq[q_num].count <= q_limit[AC_VO_Q]) ||
+	    (q_num == AC_VI_Q && wilc->txq[q_num].count <= q_limit[AC_VI_Q]) ||
+	    (q_num == AC_BE_Q && wilc->txq[q_num].count <= q_limit[AC_BE_Q]) ||
+	    (q_num == AC_BK_Q && wilc->txq[q_num].count <= q_limit[AC_BK_Q])) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "Adding mgmt packet at the Queue tail\n");
+		tqe->ack_idx = NOT_TCP_ACK;
+		if (vif->ack_filter.enabled)
+			tcp_process(dev, tqe);
+		wilc_wlan_txq_add_to_tail(dev, q_num, tqe);
+	} else {
+		tqe->status = 0;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv, tqe->status);
+		kfree(tqe);
+	}
+
 	return wilc->txq_entries;
 }
 
-int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			       u32 buffer_size, wilc_tx_complete_func_t func)
 {
 	struct txq_entry_t *tqe;
@@ -371,472 +559,836 @@ int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 
 	wilc = vif->wilc;
 
-	if (wilc->quit)
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "drv is quitting\n");
+		func(priv, 0);
 		return 0;
+	}
 
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not_init\n");
+		func(priv, 0);
+		return 0;
+	}
 	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
 
-	if (!tqe)
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Queue malloc failed\n");
+		func(priv, 0);
 		return 0;
+	}
 	tqe->type = WILC_MGMT_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = func;
 	tqe->priv = priv;
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
-	wilc_wlan_txq_add_to_tail(dev, tqe);
+	tqe->q_num = AC_BE_Q;
+	tqe->ack_idx = NOT_TCP_ACK;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding Mgmt packet to Queue tail\n");
+	wilc_wlan_txq_add_to_tail(dev, AC_BE_Q, tqe);
 	return 1;
 }
 
-static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)
+static struct txq_entry_t *txq_get_first(struct wilc *wilc, u8 q_num)
 {
-	struct txq_entry_t *tqe;
+	struct txq_entry_t *tqe = NULL;
 	unsigned long flags;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	tqe = wilc->txq_head;
+	if (!list_empty(&wilc->txq[q_num].txq_head.list))
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
 	return tqe;
 }
 
-static struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,
-						  struct txq_entry_t *tqe)
+static struct txq_entry_t *txq_get_next(struct wilc *wilc,
+					struct txq_entry_t *tqe, u8 q_num)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	tqe = tqe->next;
+	if (!list_is_last(&tqe->list, &wilc->txq[q_num].txq_head.list))
+		tqe = list_next_entry(tqe, list);
+	else
+		tqe = NULL;
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
 	return tqe;
 }
 
-static int wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
+static void rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
 {
+	struct wilc_vif *vif = wilc->vif[0];
+
 	if (wilc->quit)
-		return 0;
+		return;
 
 	mutex_lock(&wilc->rxq_cs);
-	if (!wilc->rxq_head) {
-		rqe->next = NULL;
-		wilc->rxq_head = rqe;
-		wilc->rxq_tail = rqe;
+	list_add_tail(&rqe->list, &wilc->rxq_head.list);
+	PRINT_INFO(vif->ndev, RX_DBG, "Added to RX queue\n");
+	mutex_unlock(&wilc->rxq_cs);
+}
+
+static struct rxq_entry_t *rxq_remove(struct wilc *wilc)
+{
+	struct wilc_vif *vif = wilc->vif[0];
+	struct rxq_entry_t *rqe = NULL;
+
+	PRINT_INFO(vif->ndev, RX_DBG, "Getting rxQ element\n");
+
+	mutex_lock(&wilc->rxq_cs);
+	if (!list_empty(&wilc->rxq_head.list)) {
+		rqe = list_first_entry(&wilc->rxq_head.list, struct rxq_entry_t,
+				       list);
+		list_del(&rqe->list);
 	} else {
-		wilc->rxq_tail->next = rqe;
-		rqe->next = NULL;
-		wilc->rxq_tail = rqe;
+		PRINT_INFO(vif->ndev, RX_DBG, "Nothing to get from Q\n");
 	}
-	wilc->rxq_entries += 1;
 	mutex_unlock(&wilc->rxq_cs);
-	return wilc->rxq_entries;
+	return rqe;
 }
 
-static struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)
+static int chip_allow_sleep_wilc1000(struct wilc *wilc, int source)
 {
-	if (wilc->rxq_head) {
-		struct rxq_entry_t *rqe;
+	u32 reg = 0;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	u32 wakeup_reg, wakeup_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	u32 trials = 100;
+	int ret;
 
-		mutex_lock(&wilc->rxq_cs);
-		rqe = wilc->rxq_head;
-		wilc->rxq_head = wilc->rxq_head->next;
-		wilc->rxq_entries -= 1;
-		mutex_unlock(&wilc->rxq_cs);
-		return rqe;
+	if (wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = 0xf0;
+		wakeup_bit = BIT(0);
+		from_host_to_fw_reg = 0xfa;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);
+	} else {
+		wakeup_reg = 0x1;
+		wakeup_bit = BIT(1);
+		from_host_to_fw_reg = 0x0b;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);
+	}
+
+	while (trials--) {
+		ret = hif_func->hif_read_reg(wilc, to_host_from_fw_reg, &reg);
+		if (!ret)
+			return -EIO;
+		if ((reg & to_host_from_fw_bit) == 0)
+			break;
+	}
+	if (!trials)
+		pr_warn("FW not responding\n");
+
+	/* Clear bit 1 */
+	ret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+	if (!ret)
+		return -EIO;
+	if (reg & wakeup_bit) {
+		reg &= ~wakeup_bit;
+		ret = hif_func->hif_write_reg(wilc, wakeup_reg, reg);
+		if (!ret)
+			return -EIO;
 	}
-	return NULL;
+
+	ret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+	if (!ret)
+		return -EIO;
+	if (reg & from_host_to_fw_bit) {
+		reg &= ~from_host_to_fw_bit;
+		ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);
+		if (!ret)
+			return -EIO;
+	}
+
+	return 0;
 }
 
-void chip_allow_sleep(struct wilc *wilc)
+static int chip_allow_sleep_wilc3000(struct wilc *wilc, int source)
 {
 	u32 reg = 0;
+	int ret;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
 
-	wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-
-	wilc->hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));
-	wilc->hif_func->hif_write_reg(wilc, 0xfa, 0);
+	if (wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		ret = hif_func->hif_read_reg(wilc, 0xf0, &reg);
+		if (!ret)
+			return -EIO;
+		ret = hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));
+		if (!ret)
+			return -EIO;
+	} else {
+		ret = hif_func->hif_read_reg(wilc, 0x1, &reg);
+		if (!ret)
+			return -EIO;
+		ret = hif_func->hif_write_reg(wilc, 0x1, reg & ~BIT(1));
+		if (!ret)
+			return -EIO;
+	}
+	return 0;
 }
-EXPORT_SYMBOL_GPL(chip_allow_sleep);
 
-void chip_wakeup(struct wilc *wilc)
+void chip_allow_sleep(struct wilc *wilc, int source)
 {
-	u32 reg, clk_status_reg;
+	int ret = 0;
 
-	if ((wilc->io_type & 0x1) == HIF_SPI) {
-		do {
-			wilc->hif_func->hif_read_reg(wilc, 1, &reg);
-			wilc->hif_func->hif_write_reg(wilc, 1, reg | BIT(1));
-			wilc->hif_func->hif_write_reg(wilc, 1, reg & ~BIT(1));
+	if (((source == DEV_WIFI) && (wilc->keep_awake[DEV_BT] == true)) ||
+	    ((source == DEV_BT) && (wilc->keep_awake[DEV_WIFI] == true)))
+		pr_warn("Another device is preventing allow sleep operation. request source is %s\n",
+			  (source == DEV_WIFI ? "Wifi" : "BT"));
+	else
+		if (wilc->chip == WILC_1000)
+			ret = chip_allow_sleep_wilc1000(wilc, source);
+		else
+			ret = chip_allow_sleep_wilc3000(wilc, source);
+	if (!ret)
+		wilc->keep_awake[source] = false;
+}
 
-			do {
-				usleep_range(2 * 1000, 2 * 1000);
-				wilc_get_chipid(wilc, true);
-			} while (wilc_get_chipid(wilc, true) == 0);
-		} while (wilc_get_chipid(wilc, true) == 0);
-	} else if ((wilc->io_type & 0x1) == HIF_SDIO)	 {
-		wilc->hif_func->hif_write_reg(wilc, 0xfa, 1);
-		udelay(200);
-		wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-		do {
-			wilc->hif_func->hif_write_reg(wilc, 0xf0,
-						      reg | BIT(0));
-			wilc->hif_func->hif_read_reg(wilc, 0xf1,
-						     &clk_status_reg);
+void chip_wakeup_wilc1000(struct wilc *wilc, int source)
+{
+	u32 ret = 0;
+	u32 reg = 0, clk_status_val = 0, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = 0xf0;
+		clk_status_reg = 0xf1;
+		wakeup_bit = BIT(0);
+		clk_status_bit = BIT(0);
+		from_host_to_fw_reg = 0xfa;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);
+	} else {
+		wakeup_reg = 0x1;
+		clk_status_reg = 0x0f;
+		wakeup_bit = BIT(1);
+		clk_status_bit = BIT(2);
+		from_host_to_fw_reg = 0x0b;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);
+	}
 
-			while ((clk_status_reg & 0x1) == 0) {
-				usleep_range(2 * 1000, 2 * 1000);
+	ret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+	if (!ret)
+		goto _fail_;
 
-				wilc->hif_func->hif_read_reg(wilc, 0xf1,
-							     &clk_status_reg);
-			}
-			if ((clk_status_reg & 0x1) == 0) {
-				wilc->hif_func->hif_write_reg(wilc, 0xf0,
-							      reg & (~BIT(0)));
-			}
-		} while ((clk_status_reg & 0x1) == 0);
+	if (!(reg & from_host_to_fw_bit)) {
+		/*USE bit 0 to indicate host wakeup*/
+		ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg,
+					      reg | from_host_to_fw_bit);
+		if (!ret)
+			goto _fail_;
 	}
 
-	if (chip_ps_state == CHIP_SLEEPING_MANUAL) {
-		if (wilc_get_chipid(wilc, false) < 0x1002b0) {
-			u32 val32;
+	ret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+	if (!ret)
+		goto _fail_;
+	/* Set bit 1 */
+	if (!(reg & wakeup_bit)) {
+		ret = hif_func->hif_write_reg(wilc, wakeup_reg,
+					      reg | wakeup_bit);
+		if (!ret)
+			goto _fail_;
+	}
 
-			wilc->hif_func->hif_read_reg(wilc, 0x1e1c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e1c, val32);
+	do {
+		ret = hif_func->hif_read_reg(wilc, clk_status_reg,
+					     &clk_status_val);
+		if (!ret) {
+			pr_err("Bus error (5).%d %x\n", ret, clk_status_val);
+			goto _fail_;
+		}
+		if (clk_status_val & clk_status_bit)
+			break;
 
-			wilc->hif_func->hif_read_reg(wilc, 0x1e9c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e9c, val32);
+		//nm_bsp_sleep(2);
+		trials++;
+		if (trials > WAKUP_TRAILS_TIMEOUT) {
+			pr_err("Failed to wakup the chip\n");
+			ret = -1;
+			goto _fail_;
 		}
+	} while (1);
+
+	if (wilc_get_chipid(wilc, false) < 0x1002b0) {
+		uint32_t val32;
+		/* Enable PALDO back right after wakeup */
+		hif_func->hif_read_reg(wilc, 0x1e1c, &val32);
+		val32 |= BIT(6);
+		hif_func->hif_write_reg(wilc, 0x1e1c, val32);
+
+		hif_func->hif_read_reg(wilc, 0x1e9c, &val32);
+		val32 |= BIT(6);
+		hif_func->hif_write_reg(wilc, 0x1e9c, val32);
 	}
-	chip_ps_state = CHIP_WAKEDUP;
+	/*workaround sometimes spi fail to read clock regs after reading
+	 * writing clockless registers
+	 */
+	reset_bus(wilc);
+
+_fail_:
+	return;
 }
-EXPORT_SYMBOL_GPL(chip_wakeup);
 
-void wilc_chip_sleep_manually(struct wilc *wilc)
+void chip_wakeup_wilc3000(struct wilc *wilc, int source)
 {
-	if (chip_ps_state != CHIP_WAKEDUP)
-		return;
-	acquire_bus(wilc, ACQUIRE_ONLY);
+	u32 wakeup_reg_val, clk_status_reg_val, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	int wake_seq_trials = 5;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = 0xf0;
+		clk_status_reg = 0xf0;
+		wakeup_bit = BIT(0);
+		clk_status_bit = BIT(4);
+	} else {
+		wakeup_reg = 0x1;
+		clk_status_reg = 0x13;
+		wakeup_bit = BIT(1);
+		clk_status_bit = BIT(2);
+	}
+
+	hif_func->hif_read_reg(wilc, wakeup_reg, &wakeup_reg_val);
+	do {
+		hif_func->hif_write_reg(wilc, wakeup_reg, wakeup_reg_val |
+							  wakeup_bit);
+		/* Check the clock status */
+		hif_func->hif_read_reg(wilc, clk_status_reg,
+				       &clk_status_reg_val);
+
+		/*
+		 * in case of clocks off, wait 1ms, and check it again.
+		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * If still off, redo the wake up sequence
+		 */
+		while (((clk_status_reg_val & clk_status_bit) == 0) &&
+		       (((++trials) % 3) == 0)) {
+			/* Wait for the chip to stabilize*/
+			usleep_range(1000, 1100);
+
+			/*
+			 * Make sure chip is awake. This is an extra step that
+			 * can be removed later to avoid the bus access
+			 * overhead
+			 */
+			hif_func->hif_read_reg(wilc, clk_status_reg,
+					       &clk_status_reg_val);
 
-	chip_allow_sleep(wilc);
-	wilc->hif_func->hif_write_reg(wilc, 0x10a8, 1);
+		}
+		/* in case of failure, Reset the wakeup bit to introduce a new
+		 * edge on the next loop
+		 */
+		if ((clk_status_reg_val & clk_status_bit) == 0) {
+			dev_warn(wilc->dev, "clocks still OFF. Retrying\n");
+			hif_func->hif_write_reg(wilc, wakeup_reg,
+						wakeup_reg_val & (~wakeup_bit));
+		}
+	} while (((clk_status_reg_val & clk_status_bit) == 0)
+		 && (wake_seq_trials-- > 0));
+	if (!wake_seq_trials)
+		dev_err(wilc->dev, "clocks still OFF. Wake up failed\n");
+	wilc->keep_awake[source] = true;
+}
 
-	chip_ps_state = CHIP_SLEEPING_MANUAL;
-	release_bus(wilc, RELEASE_ONLY);
+void chip_wakeup(struct wilc *wilc, int source)
+{
+	if (wilc->chip == WILC_1000)
+		chip_wakeup_wilc1000(wilc, source);
+	else
+		chip_wakeup_wilc3000(wilc, source);
 }
-EXPORT_SYMBOL_GPL(wilc_chip_sleep_manually);
 
-void host_wakeup_notify(struct wilc *wilc)
+void host_wakeup_notify(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);
-	release_bus(wilc, RELEASE_ONLY);
+	acquire_bus(wilc, ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, 0x10c0, 1);
+	release_bus(wilc, RELEASE_ONLY, source);
 }
-EXPORT_SYMBOL_GPL(host_wakeup_notify);
 
-void host_sleep_notify(struct wilc *wilc)
+void host_sleep_notify(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);
-	release_bus(wilc, RELEASE_ONLY);
+	acquire_bus(wilc, ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, 0x10bc, 1);
+	release_bus(wilc, RELEASE_ONLY, source);
 }
-EXPORT_SYMBOL_GPL(host_sleep_notify);
 
+static u8 ac_fw_count[NQUEUES] = {0, 0, 0, 0};
 int wilc_wlan_handle_txq(struct net_device *dev, u32 *txq_count)
 {
 	int i, entries = 0;
+	u8 k, ac;
 	u32 sum;
 	u32 reg;
+	u8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};
+	u8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};
+	u8 *num_pkts_to_add;
+	u8 vmm_entries_ac[WILC_VMM_TBL_SIZE];
 	u8 *txb;
 	u32 offset = 0;
+	bool max_size_over = 0, ac_exist = 0;
 	int vmm_sz = 0;
-	struct txq_entry_t *tqe;
+	struct txq_entry_t *tqe_q[NQUEUES];
 	int ret = 0;
 	int counter;
 	int timeout;
 	u32 vmm_table[WILC_VMM_TBL_SIZE];
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	u8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	const struct wilc_hif_func *func;
 
 	txb = wilc->tx_buffer;
-	wilc->txq_exit = 0;
+	if (!wilc->txq_entries) {
+		*txq_count = 0;
+		return 0;
+	}
+
+	if (wilc->quit)
+		goto out;
+	if (ac_balance(ac_fw_count, ac_desired_ratio))
+		return -1;
+
+	mutex_lock(&wilc->txq_add_to_head_cs);
+	wilc_wlan_txq_filter_dup_tcp_ack(dev);
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Getting the head of the TxQ\n");
+	for (ac = 0; ac < NQUEUES; ac++)
+		tqe_q[ac] = txq_get_first(wilc, ac);
+	i = 0;
+	sum = 0;
+	max_size_over = 0;
+	num_pkts_to_add = ac_desired_ratio;
 	do {
-		if (wilc->quit)
-			break;
+		ac_exist = 0;
+		for (ac = 0; (ac < NQUEUES) && (!max_size_over); ac++) {
+			if (!tqe_q[ac])
+				continue;
+
+			ac_exist = 1;
+			for (k = 0; (k < num_pkts_to_add[ac]) &&
+				    (!max_size_over) && tqe_q[ac]; k++) {
+				if (i >= (WILC_VMM_TBL_SIZE - 1)) {
+					max_size_over = 1;
+					break;
+				}
 
-		mutex_lock(&wilc->txq_add_to_head_cs);
-		wilc_wlan_txq_filter_dup_tcp_ack(dev);
-		tqe = wilc_wlan_txq_get_first(wilc);
-		i = 0;
-		sum = 0;
-		do {
-			if (tqe && (i < (WILC_VMM_TBL_SIZE - 1))) {
-				if (tqe->type == WILC_CFG_PKT)
+				if (tqe_q[ac]->type == WILC_CFG_PKT)
 					vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
-
-				else if (tqe->type == WILC_NET_PKT)
+				else if (tqe_q[ac]->type == WILC_NET_PKT)
 					vmm_sz = ETH_ETHERNET_HDR_OFFSET;
-
 				else
 					vmm_sz = HOST_HDR_OFFSET;
 
-				vmm_sz += tqe->buffer_size;
-
+				vmm_sz += tqe_q[ac]->buffer_size;
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size before alignment = %d\n",
+					   vmm_sz);
 				if (vmm_sz & 0x3)
 					vmm_sz = (vmm_sz + 4) & ~0x3;
 
-				if ((sum + vmm_sz) > LINUX_TX_SIZE)
+				if ((sum + vmm_sz) > LINUX_TX_SIZE) {
+					max_size_over = 1;
 					break;
-
+				}
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size AFTER alignment = %d\n",
+					   vmm_sz);
 				vmm_table[i] = vmm_sz / 4;
-				if (tqe->type == WILC_CFG_PKT)
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMMTable entry size = %d\n",
+					   vmm_table[i]);
+				if (tqe_q[ac]->type == WILC_CFG_PKT) {
 					vmm_table[i] |= BIT(10);
-				vmm_table[i] = cpu_to_le32(vmm_table[i]);
+					PRINT_INFO(vif->ndev, TX_DBG,
+						   "VMMTable entry changed for CFG packet = %d\n",
+						   vmm_table[i]);
+				}
+				cpu_to_le32s(&vmm_table[i]);
+				vmm_entries_ac[i] = ac;
 
 				i++;
 				sum += vmm_sz;
-				tqe = wilc_wlan_txq_get_next(wilc, tqe);
-			} else {
-				break;
+				PRINT_INFO(vif->ndev, TX_DBG, "sum = %d\n",
+					   sum);
+				tqe_q[ac] = txq_get_next(wilc, tqe_q[ac], ac);
 			}
-		} while (1);
-
-		if (i == 0)
-			break;
-		vmm_table[i] = 0x0;
+		}
+		num_pkts_to_add = ac_preserve_ratio;
+	} while (!max_size_over && ac_exist);
 
-		acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-		counter = 0;
-		do {
-			ret = wilc->hif_func->hif_read_reg(wilc,
-							   WILC_HOST_TX_CTRL,
-							   &reg);
-			if (!ret)
-				break;
+	if (i == 0) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Nothing in TX-Q\n");
+		goto out;
+	}
+	vmm_table[i] = 0x0;
 
-			if ((reg & 0x1) == 0)
-				break;
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
+	counter = 0;
+	func = wilc->hif_func;
+	do {
+		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+		if (!ret) {
+			PRINT_ER(vif->ndev, "fail read reg vmm_tbl_entry..\n");
+			break;
+		}
+		if ((reg & 0x1) == 0) {
+			ac_pkt_count(reg, ac_fw_count);
+			ac_acm_bit(wilc, reg);
+			break;
+		}
 
-			counter++;
-			if (counter > 200) {
-				counter = 0;
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
-				break;
-			}
-		} while (!wilc->quit);
+		counter++;
+		if (counter > 200) {
+			counter = 0;
+			PRINT_INFO(vif->ndev, TX_DBG,
+				    "Looping in tx ctrl , force quit\n");
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
+			break;
+		}
+	} while (!wilc->quit);
 
-		if (!ret)
-			goto _end_;
+	if (!ret)
+		goto out_release_bus;
 
-		timeout = 200;
-		do {
-			ret = wilc->hif_func->hif_block_tx(wilc, WILC_VMM_TBL_RX_SHADOW_BASE, (u8 *)vmm_table, ((i + 1) * 4));
-			if (!ret)
-				break;
+	timeout = 200;
+	do {
+		ret = func->hif_block_tx(wilc,
+					 VMM_TBL_RX_SHADOW_BASE,
+					 (u8 *)vmm_table,
+					 ((i + 1) * 4));
+		if (!ret) {
+			PRINT_ER(vif->ndev, "ERR block TX of VMM table.\n");
+			break;
+		}
 
+		if (wilc->chip == WILC_1000) {
 			ret = wilc->hif_func->hif_write_reg(wilc,
 							    WILC_HOST_VMM_CTL,
 							    0x2);
-			if (!ret)
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg host_vmm_ctl..\n");
 				break;
+			}
 
 			do {
-				ret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);
+				ret = func->hif_read_reg(wilc,
+						      WILC_HOST_VMM_CTL,
+						      &reg);
 				if (!ret)
 					break;
 				if ((reg >> 2) & 0x1) {
 					entries = ((reg >> 3) & 0x3f);
 					break;
 				}
-				release_bus(wilc, RELEASE_ALLOW_SLEEP);
 			} while (--timeout);
-			if (timeout <= 0) {
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
+		} else {
+			ret = func->hif_write_reg(wilc,
+					      WILC_HOST_VMM_CTL,
+					      0);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg host_vmm_ctl..\n");
 				break;
 			}
-
-			if (!ret)
+			/* interrupt firmware */
+			ret = func->hif_write_reg(wilc,
+					      WILC_INTERRUPT_CORTUS_0,
+					      1);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_INTERRUPT_CORTUS_0..\n");
 				break;
+			}
 
-			if (entries == 0) {
-				ret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-				if (!ret)
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_INTERRUPT_CORTUS_0,
+						      &reg);
+				if (!ret) {
+					PRINT_ER(vif->ndev,
+						  "fail read reg WILC_INTERRUPT_CORTUS_0..\n");
 					break;
-				reg &= ~BIT(0);
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
-				if (!ret)
+				}
+				if (reg == 0) {
+					// Get the entries
+
+					ret = func->hif_read_reg(wilc,
+							      WILC_HOST_VMM_CTL,
+							      &reg);
+					if (!ret) {
+						PRINT_ER(vif->ndev,
+							  "fail read reg host_vmm_ctl..\n");
+						break;
+					}
+					entries = ((reg >> 3) & 0x3f);
 					break;
-				break;
-			}
+				}
+			} while (--timeout);
+		}
+		if (timeout <= 0) {
+			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
 			break;
-		} while (1);
+		}
 
 		if (!ret)
-			goto _end_;
+			break;
 
 		if (entries == 0) {
-			ret = WILC_TX_ERR_NO_BUF;
-			goto _end_;
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "no buffer in the chip (reg: %08x), retry later [[ %d, %x ]]\n",
+				   reg, i, vmm_table[i-1]);
+			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail read reg WILC_HOST_TX_CTRL..\n");
+				break;
+			}
+			reg &= ~BIT(0);
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_HOST_TX_CTRL..\n");
+				break;
+			}
+			break;
 		}
+		break;
+	} while (1);
 
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
+	if (!ret)
+		goto out_release_bus;
 
-		offset = 0;
-		i = 0;
-		do {
-			tqe = wilc_wlan_txq_remove_from_head(dev);
-			if (tqe && (vmm_table[i] != 0)) {
-				u32 header, buffer_offset;
-
-				vmm_table[i] = cpu_to_le32(vmm_table[i]);
-				vmm_sz = (vmm_table[i] & 0x3ff);
-				vmm_sz *= 4;
-				header = (tqe->type << 31) |
-					 (tqe->buffer_size << 15) |
-					 vmm_sz;
-				if (tqe->type == WILC_MGMT_PKT)
-					header |= BIT(30);
-				else
-					header &= ~BIT(30);
-
-				header = cpu_to_le32(header);
-				memcpy(&txb[offset], &header, 4);
-				if (tqe->type == WILC_CFG_PKT) {
-					buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
-				} else if (tqe->type == WILC_NET_PKT) {
-					char *bssid = ((struct tx_complete_data *)(tqe->priv))->bssid;
-
-					buffer_offset = ETH_ETHERNET_HDR_OFFSET;
-					memcpy(&txb[offset + 8], bssid, 6);
-				} else {
-					buffer_offset = HOST_HDR_OFFSET;
-				}
+	if (entries == 0) {
+		ret = WILC_TX_ERR_NO_BUF;
+		goto out_release_bus;
+	}
 
-				memcpy(&txb[offset + buffer_offset],
-				       tqe->buffer, tqe->buffer_size);
-				offset += vmm_sz;
-				i++;
-				tqe->status = 1;
-				if (tqe->tx_complete_func)
-					tqe->tx_complete_func(tqe->priv,
-							      tqe->status);
-				if (tqe->tcp_pending_ack_idx != NOT_TCP_ACK &&
-				    tqe->tcp_pending_ack_idx < MAX_PENDING_ACKS)
-					pending_acks_info[tqe->tcp_pending_ack_idx].txqe = NULL;
-				kfree(tqe);
-			} else {
-				break;
-			}
-		} while (--entries);
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
+	offset = 0;
+	i = 0;
+	do {
+		struct txq_entry_t *tqe;
+		u32 header, buffer_offset;
+
+		tqe = wilc_wlan_txq_remove_from_head(dev, vmm_entries_ac[i]);
+		ac_pkt_num_to_chip[vmm_entries_ac[i]]++;
+		if (!tqe)
+			break;
 
-		acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
+		if (vmm_table[i] == 0)
+			break;
 
-		ret = wilc->hif_func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
-		if (!ret)
-			goto _end_;
+		le32_to_cpus(&vmm_table[i]);
+		vmm_sz = (vmm_table[i] & 0x3ff);
+		vmm_sz *= 4;
+		header = (tqe->type << 31) |
+			 (tqe->buffer_size << 15) |
+			 vmm_sz;
+		if (tqe->type == WILC_MGMT_PKT)
+			header |= BIT(30);
+		else
+			header &= ~BIT(30);
+
+		cpu_to_le32s(&header);
+		memcpy(&txb[offset], &header, 4);
+		if (tqe->type == WILC_CFG_PKT) {
+			buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
+		} else if (tqe->type == WILC_NET_PKT) {
+			char *bssid = ((struct tx_complete_data *)
+				       (tqe->priv))->bssid;
+			int prio = tqe->q_num;
+
+			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
+			memcpy(&txb[offset + 4], &prio, sizeof(prio));
+			memcpy(&txb[offset + 8], bssid, 6);
+		} else {
+			buffer_offset = HOST_HDR_OFFSET;
+		}
 
-		ret = wilc->hif_func->hif_block_tx_ext(wilc, 0, txb, offset);
-		if (!ret)
-			goto _end_;
+		memcpy(&txb[offset + buffer_offset],
+		       tqe->buffer, tqe->buffer_size);
+		offset += vmm_sz;
+		i++;
+		tqe->status = 1;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv,
+					      tqe->status);
+		if (tqe->ack_idx != NOT_TCP_ACK &&
+		    tqe->ack_idx < MAX_PENDING_ACKS)
+			vif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;
+		kfree(tqe);
+	} while (--entries);
+	for (i = 0; i < NQUEUES; i++)
+		ac_fw_count[i] += ac_pkt_num_to_chip[i];
 
-_end_:
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-		if (ret != 1)
-			break;
-	} while (0);
+	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail start tx VMM ...\n");
+		goto out_release_bus;
+	}
+
+	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
+	if (!ret)
+		PRINT_ER(vif->ndev, "fail block tx ext...\n");
+
+out_release_bus:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
+
+out:
 	mutex_unlock(&wilc->txq_add_to_head_cs);
 
-	wilc->txq_exit = 1;
+	PRINT_INFO(vif->ndev, TX_DBG, "THREAD: Exiting txq\n");
 	*txq_count = wilc->txq_entries;
+	if (ret == 1)
+		cfg_packet_timeout = 0;
 	return ret;
 }
 
+static void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)
+{
+	int offset = 0;
+	u32 header;
+	u32 pkt_len, pkt_offset, tp_len;
+	int is_cfg_packet;
+	u8 *buff_ptr;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	do {
+		PRINT_INFO(vif->ndev, RX_DBG, "Handling rx buffer\n");
+		buff_ptr = buffer + offset;
+		memcpy(&header, buff_ptr, 4);
+		le32_to_cpus(&header);
+		PRINT_INFO(vif->ndev, RX_DBG,
+			   "Header = %04x - Offset = %d\n", header, offset);
+
+		is_cfg_packet = (header >> 31) & 0x1;
+		pkt_offset = (header >> 22) & 0x1ff;
+		tp_len = (header >> 11) & 0x7ff;
+		pkt_len = header & 0x7ff;
+
+		if (pkt_len == 0 || tp_len == 0) {
+			PRINT_INFO(vif->ndev, RX_DBG,
+				   "Data corrupted %d, %d\n",
+				   pkt_len, tp_len);
+			break;
+		}
+
+		if (is_cfg_packet) {
+			struct wilc_cfg_rsp rsp;
+
+			buff_ptr += pkt_offset;
+
+			cfg_indicate_rx(wilc, buff_ptr, pkt_len,
+					&rsp);
+			if (rsp.type == WILC_CFG_RSP) {
+				PRINT_INFO(vif->ndev, RX_DBG,
+					"cfg_seq %d rsp.seq %d\n",
+					wilc->cfg_seq_no, rsp.seq_no);
+
+				if (wilc->cfg_seq_no == rsp.seq_no)
+					complete(&wilc->cfg_event);
+			} else if (rsp.type == WILC_CFG_RSP_STATUS) {
+				wilc_mac_indicate(wilc);
+			}
+		} else if (pkt_offset & IS_MANAGMEMENT) {
+			pkt_offset &= ~(IS_MANAGMEMENT |
+					IS_MANAGMEMENT_CALLBACK |
+					IS_MGMT_STATUS_SUCCES);
+			buff_ptr += HOST_HDR_OFFSET;
+			wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len);
+		} else if (pkt_offset & IS_MON_PKT) {
+			/* packet received on monitor interface */
+			buff_ptr += HOST_HDR_OFFSET;
+			wilc_wfi_handle_monitor_rx(wilc, buff_ptr, pkt_len);
+		} else if (pkt_len > 0) {
+			struct net_device *wilc_netdev;
+
+			wilc_netdev = get_if_handler(wilc, buff_ptr);
+			if (!wilc_netdev) {
+				PRINT_ER(vif->ndev,
+					 "wilc_netdev in wilc is NULL");
+				return;
+			}
+			vif = netdev_priv(wilc_netdev);
+			wilc_frmw_to_linux(vif, buff_ptr,
+					pkt_len,
+					pkt_offset,
+					PKT_STATUS_NEW);
+		}
+
+		offset += tp_len;
+		if (offset >= size)
+			break;
+	} while (1);
+}
+
 static void wilc_wlan_handle_rxq(struct wilc *wilc)
 {
-	int offset = 0, size;
+	int size;
 	u8 *buffer;
 	struct rxq_entry_t *rqe;
-
-	wilc->rxq_exit = 0;
+	struct wilc_vif *vif = wilc->vif[0];
 
 	do {
 		if (wilc->quit) {
+			PRINT_INFO(vif->ndev, RX_DBG,
+				   "Quitting. Exit handle RX queue\n");
 			complete(&wilc->cfg_event);
 			break;
 		}
-		rqe = wilc_wlan_rxq_remove(wilc);
-		if (!rqe)
+		rqe = rxq_remove(wilc);
+		if (!rqe) {
+			PRINT_INFO(vif->ndev, RX_DBG,
+				   "nothing in RX queue\n");
 			break;
+		}
 
 		buffer = rqe->buffer;
 		size = rqe->buffer_size;
-		offset = 0;
-
-		do {
-			u32 header;
-			u32 pkt_len, pkt_offset, tp_len;
-			int is_cfg_packet;
-
-			memcpy(&header, &buffer[offset], 4);
-			header = cpu_to_le32(header);
+		PRINT_INFO(vif->ndev, RX_DBG,
+			   "rxQ entery Size = %d - Address = %p\n",
+			   size, buffer);
 
-			is_cfg_packet = (header >> 31) & 0x1;
-			pkt_offset = (header >> 22) & 0x1ff;
-			tp_len = (header >> 11) & 0x7ff;
-			pkt_len = header & 0x7ff;
+		wilc_wlan_handle_rx_buff(wilc, buffer, size);
 
-			if (pkt_len == 0 || tp_len == 0)
-				break;
-
-			#define IS_MANAGMEMENT				0x100
-			#define IS_MANAGMEMENT_CALLBACK			0x080
-			#define IS_MGMT_STATUS_SUCCES			0x040
-
-			if (pkt_offset & IS_MANAGMEMENT) {
-				pkt_offset &= ~(IS_MANAGMEMENT |
-						IS_MANAGMEMENT_CALLBACK |
-						IS_MGMT_STATUS_SUCCES);
-
-				WILC_WFI_mgmt_rx(wilc, &buffer[offset + HOST_HDR_OFFSET], pkt_len);
-			} else {
-				if (!is_cfg_packet) {
-					if (pkt_len > 0) {
-						wilc_frmw_to_linux(wilc,
-								   &buffer[offset],
-								   pkt_len,
-								   pkt_offset);
-					}
-				} else {
-					struct wilc_cfg_rsp rsp;
-
-					wilc_wlan_cfg_indicate_rx(wilc, &buffer[pkt_offset + offset], pkt_len, &rsp);
-					if (rsp.type == WILC_CFG_RSP) {
-						if (wilc->cfg_seq_no == rsp.seq_no)
-							complete(&wilc->cfg_event);
-					} else if (rsp.type == WILC_CFG_RSP_STATUS) {
-						wilc_mac_indicate(wilc, WILC_MAC_INDICATE_STATUS);
-
-					} else if (rsp.type == WILC_CFG_RSP_SCAN) {
-						wilc_mac_indicate(wilc, WILC_MAC_INDICATE_SCAN);
-					}
-				}
-			}
-			offset += tp_len;
-			if (offset >= size)
-				break;
-		} while (1);
 		kfree(rqe);
 	} while (1);
 
-	wilc->rxq_exit = 1;
+	PRINT_INFO(vif->ndev, RX_DBG, "THREAD: Exiting RX thread\n");
 }
 
 static void wilc_unknown_isr_ext(struct wilc *wilc)
@@ -844,26 +1396,6 @@ static void wilc_unknown_isr_ext(struct wilc *wilc)
 	wilc->hif_func->hif_clear_int_ext(wilc, 0);
 }
 
-static void wilc_pllupdate_isr_ext(struct wilc *wilc, u32 int_stats)
-{
-	int trials = 10;
-
-	wilc->hif_func->hif_clear_int_ext(wilc, PLL_INT_CLR);
-
-	if (wilc->io_type == HIF_SDIO)
-		mdelay(WILC_PLL_TO_SDIO);
-	else
-		mdelay(WILC_PLL_TO_SPI);
-
-	while (!(ISWILC1000(wilc_get_chipid(wilc, true)) && --trials))
-		mdelay(1);
-}
-
-static void wilc_sleeptimer_isr_ext(struct wilc *wilc, u32 int_stats1)
-{
-	wilc->hif_func->hif_clear_int_ext(wilc, SLEEP_INT_CLR);
-}
-
 static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
 {
 	u32 offset = wilc->rx_buffer_offset;
@@ -872,65 +1404,68 @@ static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
 	u32 retries = 0;
 	int ret = 0;
 	struct rxq_entry_t *rqe;
+	struct wilc_vif *vif = wilc->vif[0];
 
 	size = (int_status & 0x7fff) << 2;
 
 	while (!size && retries < 10) {
+		PRINT_ER(vif->ndev,
+			 "RX Size equal zero Trying to read it again\n");
 		wilc->hif_func->hif_read_size(wilc, &size);
 		size = (size & 0x7fff) << 2;
 		retries++;
 	}
 
-	if (size > 0) {
-		if (LINUX_RX_SIZE - offset < size)
-			offset = 0;
+	if (size <= 0)
+		return;
 
-		if (wilc->rx_buffer)
-			buffer = &wilc->rx_buffer[offset];
-		else
-			goto _end_;
-
-		wilc->hif_func->hif_clear_int_ext(wilc,
-					      DATA_INT_CLR | ENABLE_RX_VMM);
-		ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
-
-_end_:
-		if (ret) {
-			offset += size;
-			wilc->rx_buffer_offset = offset;
-			rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
-			if (rqe) {
-				rqe->buffer = buffer;
-				rqe->buffer_size = size;
-				wilc_wlan_rxq_add(wilc, rqe);
-			}
-		}
+	if (LINUX_RX_SIZE - offset < size)
+		offset = 0;
+
+	buffer = &wilc->rx_buffer[offset];
+
+	wilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);
+
+	ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail block rx\n");
+		return;
 	}
+
+	offset += size;
+	wilc->rx_buffer_offset = offset;
+	rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
+	if (!rqe)
+		return;
+
+	rqe->buffer = buffer;
+	rqe->buffer_size = size;
+	PRINT_INFO(vif->ndev, RX_DBG,
+		   "rxq entery Size= %d Address= %p\n",
+		   rqe->buffer_size, rqe->buffer);
+	rxq_add(wilc, rqe);
 	wilc_wlan_handle_rxq(wilc);
 }
 
 void wilc_handle_isr(struct wilc *wilc)
 {
 	u32 int_status;
+	struct wilc_vif *vif = wilc->vif[0];
 
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	wilc->hif_func->hif_read_int(wilc, &int_status);
 
-	if (int_status & PLL_INT_EXT)
-		wilc_pllupdate_isr_ext(wilc, int_status);
-
 	if (int_status & DATA_INT_EXT)
 		wilc_wlan_handle_isr_ext(wilc, int_status);
 
-	if (int_status & SLEEP_INT_EXT)
-		wilc_sleeptimer_isr_ext(wilc, int_status);
-
-	if (!(int_status & (ALL_INT_EXT)))
+	if (!(int_status & (ALL_INT_EXT))) {
+		PRINT_WRN(vif->ndev, TX_DBG, ">> UNKNOWN_INTERRUPT - 0x%08x\n",
+			  int_status);
 		wilc_unknown_isr_ext(wilc);
+	}
 
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 }
-EXPORT_SYMBOL_GPL(wilc_handle_isr);
 
 int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size)
@@ -939,20 +1474,38 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 	u32 addr, size, size2, blksz;
 	u8 *dma_buffer;
 	int ret = 0;
+	u32 reg = 0;
+	struct wilc_vif *vif = wilc->vif[0];
 
 	blksz = BIT(12);
 
 	dma_buffer = kmalloc(blksz, GFP_KERNEL);
-	if (!dma_buffer)
+	if (!dma_buffer) {
+		PRINT_ER(vif->ndev,
+			 "Can't allocate buffer for fw download IO error\n");
 		return -EIO;
+	}
 
 	offset = 0;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading firmware size = %d\n",
+		   buffer_size);
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	reg &= ~(1ul << 10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if ((reg & (1ul << 10)) != 0)
+		PRINT_ER(vif->ndev, "Failed to reset Wifi CPU\n");
+
+	release_bus(wilc, RELEASE_ONLY, DEV_WIFI);
 	do {
 		memcpy(&addr, &buffer[offset], 4);
 		memcpy(&size, &buffer[offset + 4], 4);
-		addr = cpu_to_le32(addr);
-		size = cpu_to_le32(size);
-		acquire_bus(wilc, ACQUIRE_ONLY);
+		le32_to_cpus(&addr);
+		le32_to_cpus(&size);
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
 		offset += 8;
 		while (((int)size) && (offset < buffer_size)) {
 			if (size <= blksz)
@@ -970,15 +1523,17 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 			offset += size2;
 			size -= size2;
 		}
-		release_bus(wilc, RELEASE_ONLY);
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 		if (!ret) {
 			ret = -EIO;
-			goto _fail_;
+			PRINT_ER(vif->ndev, "Bus error\n");
+			goto fail;
 		}
+		PRINT_INFO(vif->ndev, INIT_DBG, "Offset = %d\n", offset);
 	} while (offset < buffer_size);
 
-_fail_:
+fail:
 
 	kfree(dma_buffer);
 
@@ -989,60 +1544,39 @@ int wilc_wlan_start(struct wilc *wilc)
 {
 	u32 reg = 0;
 	int ret;
-	u32 chipid;
+	struct wilc_vif *vif = wilc->vif[0];
 
-	if (wilc->io_type == HIF_SDIO) {
-		reg = 0;
+	if (wilc->io_type == HIF_SDIO ||
+	    wilc->io_type == HIF_SDIO_GPIO_IRQ)
 		reg |= BIT(3);
-	} else if (wilc->io_type == HIF_SPI) {
+	else if (wilc->io_type == HIF_SPI)
 		reg = 1;
-	}
-	acquire_bus(wilc, ACQUIRE_ONLY);
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
 	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
+		PRINT_ER(vif->ndev,
+			 "[wilc start]: fail write reg vmm_core_cfg...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return -EIO;
 	}
 	reg = 0;
-	if (wilc->io_type == HIF_SDIO && wilc->dev_irq_num)
+	if (wilc->io_type == HIF_SDIO_GPIO_IRQ)
 		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
 
-#ifdef WILC_DISABLE_PMU
-#else
-	reg |= WILC_HAVE_USE_PMU;
-#endif
-
-#ifdef WILC_SLEEP_CLK_SRC_XO
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_XO;
-#elif defined WILC_SLEEP_CLK_SRC_RTC
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
-#endif
-
-#ifdef WILC_EXT_PA_INV_TX_RX
-	reg |= WILC_HAVE_EXT_PA_INV_TX_RX;
-#endif
-	reg |= WILC_HAVE_USE_IRQ_AS_HOST_WAKE;
-	reg |= WILC_HAVE_LEGACY_RF_SETTINGS;
-#ifdef XTAL_24
-	reg |= WILC_HAVE_XTAL_24;
-#endif
-#ifdef DISABLE_WILC_UART
-	reg |= WILC_HAVE_DISABLE_WILC_UART;
-#endif
+	if (wilc->chip == WILC_3000)
+		reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
 
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
 	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
+		PRINT_ER(vif->ndev,
+			 "[wilc start]: fail write WILC_GP_REG_1...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return -EIO;
 	}
 
 	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
 
-	ret = wilc->hif_func->hif_read_reg(wilc, 0x1000, &chipid);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
-		return -EIO;
-	}
 
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 	if ((reg & BIT(10)) == BIT(10)) {
@@ -1054,7 +1588,12 @@ int wilc_wlan_start(struct wilc *wilc)
 	reg |= BIT(10);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	release_bus(wilc, RELEASE_ONLY);
+
+	if (ret >= 0)
+		wilc->initialized = 1;
+	else
+		wilc->initialized = 0;
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return (ret < 0) ? ret : 0;
 }
@@ -1064,19 +1603,56 @@ int wilc_wlan_stop(struct wilc *wilc)
 	u32 reg = 0;
 	int ret;
 	u8 timeout = 10;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	/* Clear Wifi mode*/
+	ret = wilc->hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	reg &= ~BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	/* Configure the power sequencer to ignore WIFI sleep signal on making
+	 * chip sleep decision
+	 */
+	ret = wilc->hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
 
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
+	reg &= ~BIT(28);
+	ret = wilc->hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
 
 	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 	if (!ret) {
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
 	reg &= ~BIT(10);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
 	if (!ret) {
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
@@ -1084,37 +1660,54 @@ int wilc_wlan_stop(struct wilc *wilc)
 		ret = wilc->hif_func->hif_read_reg(wilc,
 						   WILC_GLB_RESET_0, &reg);
 		if (!ret) {
-			release_bus(wilc, RELEASE_ALLOW_SLEEP);
+			PRINT_ER(vif->ndev, "Error while reading reg\n");
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 			return ret;
 		}
-
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Read RESET Reg %x : Retry%d\n", reg, timeout);
 		if ((reg & BIT(10))) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Bit 10 not reset : Retry %d\n", timeout);
 			reg &= ~BIT(10);
 			ret = wilc->hif_func->hif_write_reg(wilc,
 							    WILC_GLB_RESET_0,
 							    reg);
 			timeout--;
 		} else {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Bit 10 reset after : Retry %d\n", timeout);
 			ret = wilc->hif_func->hif_read_reg(wilc,
 							   WILC_GLB_RESET_0,
 							   &reg);
 			if (!ret) {
-				release_bus(wilc, RELEASE_ALLOW_SLEEP);
+				PRINT_ER(vif->ndev, "Error reading reg\n");
+				release_bus(wilc, RELEASE_ALLOW_SLEEP,
+					    DEV_WIFI);
 				return ret;
 			}
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Read RESET Reg %x : Retry%d\n", reg,
+				   timeout);
 			break;
 		}
 
 	} while (timeout);
-	reg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) | BIT(26) |
-	       BIT(29) | BIT(30) | BIT(31));
 
-	wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	reg = (u32)~BIT(10);
+	if (wilc->chip == WILC_1000) {
+		reg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) |
+		       BIT(26) | BIT(29) | BIT(30) | BIT(31));
+	} else {
+		reg = (BIT(0) | BIT(2) | BIT(3) | BIT(8) | BIT(9) |
+		       BIT(20) | BIT(26) | BIT(29) | BIT(30) | BIT(31));
+	}
 
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);
+	reg = BIT(0);
+
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);
 
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return ret;
 }
@@ -1123,26 +1716,24 @@ void wilc_wlan_cleanup(struct net_device *dev)
 {
 	struct txq_entry_t *tqe;
 	struct rxq_entry_t *rqe;
-	u32 reg = 0;
-	int ret;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	u8 ac;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
 	wilc->quit = 1;
-	do {
-		tqe = wilc_wlan_txq_remove_from_head(dev);
-		if (!tqe)
-			break;
-		if (tqe->tx_complete_func)
-			tqe->tx_complete_func(tqe->priv, 0);
-		kfree(tqe);
-	} while (1);
+	for (ac = 0; ac < NQUEUES; ac++) {
+		do {
+			tqe = wilc_wlan_txq_remove_from_head(dev, ac);
+			if (!tqe)
+				break;
+			if (tqe->tx_complete_func)
+				tqe->tx_complete_func(tqe->priv, 0);
+			kfree(tqe);
+		} while (1);
+	}
 
 	do {
-		rqe = wilc_wlan_rxq_remove(wilc);
+		rqe = rxq_remove(wilc);
 		if (!rqe)
 			break;
 		kfree(rqe);
@@ -1152,20 +1743,6 @@ void wilc_wlan_cleanup(struct net_device *dev)
 	wilc->rx_buffer = NULL;
 	kfree(wilc->tx_buffer);
 	wilc->tx_buffer = NULL;
-
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
-	if (!ret)
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
-					(reg | ABORT_INT));
-	if (!ret)
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
-	wilc->hif_func->hif_deinit(NULL);
 }
 
 static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
@@ -1196,7 +1773,7 @@ static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
 	return 0;
 }
 
-int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
+int cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		      u32 buffer_size, int commit, u32 drv_handler)
 {
 	u32 offset;
@@ -1210,36 +1787,36 @@ int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		wilc->cfg_frame_offset = 0;
 
 	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_set_wid(wilc->cfg_frame.frame, offset,
+	ret_size = cfg_set_wid(vif, wilc->cfg_frame.frame, offset,
 					 wid, buffer, buffer_size);
 	offset += ret_size;
 	wilc->cfg_frame_offset = offset;
 
-	if (commit) {
-		netdev_dbg(vif->ndev,
-			   "[WILC]PACKET Commit with sequence number %d\n",
-			   wilc->cfg_seq_no);
-		netdev_dbg(vif->ndev, "Processing cfg_set()\n");
-		wilc->cfg_frame_in_use = 1;
+	if (!commit)
+		return ret_size;
 
-		if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
-			ret_size = 0;
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "[WILC]PACKET Commit with sequence number%d\n",
+		   wilc->cfg_seq_no);
+	wilc->cfg_frame_in_use = 1;
 
-		if (!wait_for_completion_timeout(&wilc->cfg_event,
-						 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
-			netdev_dbg(vif->ndev, "Set Timed Out\n");
-			ret_size = 0;
-		}
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
+		ret_size = 0;
 
-		wilc->cfg_frame_in_use = 0;
-		wilc->cfg_frame_offset = 0;
-		wilc->cfg_seq_no += 1;
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
+		PRINT_ER(vif->ndev, "Timed Out\n");
+		ret_size = 0;
 	}
 
+	wilc->cfg_frame_in_use = 0;
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
+
 	return ret_size;
 }
 
-int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
+int cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 		      u32 drv_handler)
 {
 	u32 offset;
@@ -1253,69 +1830,82 @@ int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 		wilc->cfg_frame_offset = 0;
 
 	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
+	ret_size = cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
 	offset += ret_size;
 	wilc->cfg_frame_offset = offset;
 
-	if (commit) {
-		wilc->cfg_frame_in_use = 1;
+	if (!commit)
+		return ret_size;
 
-		if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
-			ret_size = 0;
+	wilc->cfg_frame_in_use = 1;
 
-		if (!wait_for_completion_timeout(&wilc->cfg_event,
-					msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
-			netdev_dbg(vif->ndev, "Get Timed Out\n");
-			ret_size = 0;
-		}
-		wilc->cfg_frame_in_use = 0;
-		wilc->cfg_frame_offset = 0;
-		wilc->cfg_seq_no += 1;
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
+		ret_size = 0;
+
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Timed Out\n");
+		ret_size = 0;
 	}
+	PRINT_INFO(vif->ndev, TX_DBG, "Get Response received\n");
+	wilc->cfg_frame_in_use = 0;
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
 
 	return ret_size;
 }
 
-int wilc_wlan_cfg_get_val(u16 wid, u8 *buffer, u32 buffer_size)
+int cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size)
 {
-	return wilc_wlan_cfg_get_wid_value(wid, buffer, buffer_size);
+	return cfg_get_wid_value(wl, wid, buffer, buffer_size);
 }
-
+unsigned int cfg_packet_timeout;
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count, u32 drv)
 {
 	int i;
 	int ret = 0;
 
+	if (wait_for_recovery) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is suspended\n");
+		while (wait_for_recovery)
+			msleep(300);
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is resumed\n");
+	}
+
 	if (mode == GET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_get(vif, !i,
-					       wids[i].id,
-					       (i == count - 1),
-					       drv)) {
+			PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"Sending CFG packet [%d][%d]\n", !i,
+				(i == count - 1));
+			if (!cfg_get(vif, !i, wids[i].id, (i == count - 1),
+				     drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Get Timed out\n");
 				break;
 			}
 		}
 		for (i = 0; i < count; i++) {
-			wids[i].size = wilc_wlan_cfg_get_val(wids[i].id,
+			wids[i].size = cfg_get_val(vif->wilc, wids[i].id,
 							     wids[i].val,
 							     wids[i].size);
 		}
 	} else if (mode == SET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_set(vif, !i,
-					       wids[i].id,
-					       wids[i].val,
-					       wids[i].size,
-					       (i == count - 1),
-					       drv)) {
+			PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+				   "Sending config SET PACKET WID:%x\n",
+				   wids[i].id);
+			if (!cfg_set(vif, !i, wids[i].id, wids[i].val,
+				     wids[i].size, (i == count - 1), drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Set Timed out\n");
 				break;
 			}
 		}
 	}
-
+	cfg_packet_timeout = (ret < 0) ? cfg_packet_timeout + 1 : 0;
 	return ret;
 }
 
@@ -1323,36 +1913,44 @@ static u32 init_chip(struct net_device *dev)
 {
 	u32 chipid;
 	u32 reg, ret = 0;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
 
-	acquire_bus(wilc, ACQUIRE_ONLY);
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
 	chipid = wilc_get_chipid(wilc, true);
 
-	if ((chipid & 0xfff) != 0xa0) {
-		ret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);
-		if (!ret) {
-			netdev_err(dev, "fail read reg 0x1118\n");
-			return ret;
-		}
-		reg |= BIT(0);
-		ret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);
-		if (!ret) {
-			netdev_err(dev, "fail write reg 0x1118\n");
-			return ret;
-		}
-		ret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);
+	ret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail read reg 0x1118\n");
+		goto end;
+	}
+
+	reg |= BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0x1118\n");
+		goto end;
+	}
+	ret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0xc0000 ...\n");
+		goto end;
+	}
+
+	if (wilc->chip == WILC_3000) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x207ac, &reg);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Bootrom sts = %x\n", reg);
+		ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000,
+						    0x71);
 		if (!ret) {
-			netdev_err(dev, "fail write reg 0xc0000\n");
-			return ret;
+			PRINT_ER(vif->ndev, "fail write reg 0x4f0000 ...\n");
+			goto end;
 		}
 	}
 
-	release_bus(wilc, RELEASE_ONLY);
+end:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return ret;
 }
@@ -1360,28 +1958,30 @@ static u32 init_chip(struct net_device *dev)
 u32 wilc_get_chipid(struct wilc *wilc, bool update)
 {
 	static u32 chipid;
+	int ret;
 	u32 tempchipid = 0;
-	u32 rfrevid = 0;
 
 	if (chipid == 0 || update) {
-		wilc->hif_func->hif_read_reg(wilc, 0x1000, &tempchipid);
-		wilc->hif_func->hif_read_reg(wilc, 0x13f4, &rfrevid);
-		if (!ISWILC1000(tempchipid)) {
-			chipid = 0;
-			return chipid;
-		}
-		if (tempchipid == 0x1002a0) {
-			if (rfrevid != 0x1)
-				tempchipid = 0x1002a1;
-		} else if (tempchipid == 0x1002b0) {
-			if (rfrevid == 0x4)
-				tempchipid = 0x1002b1;
-			else if (rfrevid != 0x3)
-				tempchipid = 0x1002b2;
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x3b0000,
+						     &tempchipid);
+		if (!ret)
+			pr_err("[wilc start]: fail read reg 0x3b0000\n");
+		if (!is_wilc3000(tempchipid)) {
+			wilc->hif_func->hif_read_reg(wilc, 0x1000,
+						     &tempchipid);
+			if (!is_wilc1000(tempchipid)) {
+				chipid = 0;
+				return chipid;
+			}
+			if (tempchipid < 0x1003a0) {
+				pr_err("WILC1002 isn't suported %x\n", chipid);
+				chipid = 0;
+				return chipid;
+			}
 		}
-
 		chipid = tempchipid;
 	}
+
 	return chipid;
 }
 
@@ -1395,14 +1995,16 @@ int wilc_wlan_init(struct net_device *dev)
 
 	wilc->quit = 0;
 
-	if (!wilc->hif_func->hif_init(wilc, false)) {
-		ret = -EIO;
-		goto _fail_;
-	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing WILC_Wlan\n");
 
-	if (!wilc_wlan_cfg_init()) {
-		ret = -ENOBUFS;
-		goto _fail_;
+	if (!wilc->hif_func->hif_is_init(wilc)) {
+		acquire_bus(wilc, ACQUIRE_ONLY, DEV_WIFI);
+		if (!wilc->hif_func->hif_init(wilc, false)) {
+			ret = -EIO;
+			release_bus(wilc, RELEASE_ONLY, DEV_WIFI);
+			goto fail;
+		}
+		release_bus(wilc, RELEASE_ONLY, DEV_WIFI);
 	}
 
 	if (!wilc->tx_buffer)
@@ -1410,25 +2012,27 @@ int wilc_wlan_init(struct net_device *dev)
 
 	if (!wilc->tx_buffer) {
 		ret = -ENOBUFS;
-		goto _fail_;
+		PRINT_ER(vif->ndev, "Can't allocate Tx Buffer");
+		goto fail;
 	}
 
 	if (!wilc->rx_buffer)
 		wilc->rx_buffer = kmalloc(LINUX_RX_SIZE, GFP_KERNEL);
-
+	PRINT_D(vif->ndev, TX_DBG, "g_wlan.rx_buffer =%p\n", wilc->rx_buffer);
 	if (!wilc->rx_buffer) {
 		ret = -ENOBUFS;
-		goto _fail_;
+		PRINT_ER(vif->ndev, "Can't allocate Rx Buffer");
+		goto fail;
 	}
 
 	if (!init_chip(dev)) {
 		ret = -EIO;
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	kfree(wilc->rx_buffer);
 	wilc->rx_buffer = NULL;
diff --git a/drivers/staging/wilc1000/wilc_wlan.h b/drivers/staging/wilc1000/wilc_wlan.h
index da7173105497..e06517964140 100644
--- a/drivers/staging/wilc1000/wilc_wlan.h
+++ b/drivers/staging/wilc1000/wilc_wlan.h
@@ -1,10 +1,24 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
 #ifndef WILC_WLAN_H
 #define WILC_WLAN_H
 
 #include <linux/types.h>
+#include <linux/version.h>
+
+static inline bool is_wilc1000(u32 id)
+{
+	return ((id & 0xfffff000) == 0x100000 ? true : false);
+}
 
-#define ISWILC1000(id)			((id & 0xfffff000) == 0x100000 ? 1 : 0)
+static inline bool is_wilc3000(u32 id)
+{
+	return ((id & 0xfffff000) == 0x300000 ? true : false);
+}
 
 /********************************************
  *
@@ -35,6 +49,8 @@
 
 #define ETH_CONFIG_PKT_HDR_OFFSET	(ETH_ETHERNET_HDR_OFFSET + \
 					 ETH_CONFIG_PKT_HDR_LEN)
+#define PKT_STATUS_NEW          0
+#define PKT_STATUS_BUFFERED     1
 
 /********************************************
  *
@@ -42,7 +58,6 @@
  *
  ********************************************/
 #define WILC_PERIPH_REG_BASE		0x1000
-#define WILC_CHANGING_VIR_IF		0x108c
 #define WILC_CHIPID			WILC_PERIPH_REG_BASE
 #define WILC_GLB_RESET_0		(WILC_PERIPH_REG_BASE + 0x400)
 #define WILC_PIN_MUX_0			(WILC_PERIPH_REG_BASE + 0x408)
@@ -53,6 +68,7 @@
 #define WILC_HOST_RX_CTRL		(WILC_PERIPH_REG_BASE + 0x80)
 #define WILC_HOST_RX_EXTRA_SIZE		(WILC_PERIPH_REG_BASE + 0x84)
 #define WILC_HOST_TX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x88)
+#define WILC_INTERRUPT_CORTUS_0		(WILC_PERIPH_REG_BASE + 0xa8)
 #define WILC_MISC			(WILC_PERIPH_REG_BASE + 0x428)
 #define WILC_INTR_REG_BASE		(WILC_PERIPH_REG_BASE + 0xa00)
 #define WILC_INTR_ENABLE		WILC_INTR_REG_BASE
@@ -93,21 +109,24 @@
 #define WILC_AHB_DATA_MEM_BASE		0x30000
 #define WILC_AHB_SHARE_MEM_BASE		0xd0000
 
-#define WILC_VMM_TBL_RX_SHADOW_BASE	WILC_AHB_SHARE_MEM_BASE
-#define WILC_VMM_TBL_RX_SHADOW_SIZE	256
+#define VMM_TBL_RX_SHADOW_BASE		WILC_AHB_SHARE_MEM_BASE
+#define VMM_TBL_RX_SHADOW_SIZE		256
 
+#define WILC_FW_HOST_COMM		0x13c0
 #define WILC_GP_REG_0			0x149c
 #define WILC_GP_REG_1			0x14a0
 
+#define WILC_COEXIST_CTL		0x161E00
+#define GLOBAL_MODE_CONTROL		0x1614
+#define PWR_SEQ_MISC_CTRL		0x3008
+#define COE_AUTO_PS_ON_NULL_PKT		0x160468
+#define COE_AUTO_PS_OFF_NULL_PKT	0x16046C
+#define CCA_CTL_2 (0x160EF4)
+#define CCA_CTL_7 (0x160F08)
+
 #define WILC_HAVE_SDIO_IRQ_GPIO		BIT(0)
-#define WILC_HAVE_USE_PMU		BIT(1)
 #define WILC_HAVE_SLEEP_CLK_SRC_RTC	BIT(2)
 #define WILC_HAVE_SLEEP_CLK_SRC_XO	BIT(3)
-#define WILC_HAVE_EXT_PA_INV_TX_RX	BIT(4)
-#define WILC_HAVE_LEGACY_RF_SETTINGS	BIT(5)
-#define WILC_HAVE_XTAL_24		BIT(6)
-#define WILC_HAVE_DISABLE_WILC_UART	BIT(7)
-#define WILC_HAVE_USE_IRQ_AS_HOST_WAKE	BIT(8)
 
 /********************************************
  *
@@ -124,16 +143,26 @@
 #define WILC_CFG_RSP		1
 #define WILC_CFG_RSP_STATUS	2
 #define WILC_CFG_RSP_SCAN	3
-
-#define WILC_PLL_TO_SDIO	4
-#define WILC_PLL_TO_SPI		2
 #define ABORT_INT		BIT(31)
 
 #define LINUX_RX_SIZE		(96 * 1024)
 #define LINUX_TX_SIZE		(64 * 1024)
 
 #define MODALIAS		"WILC_SPI"
-#define GPIO_NUM		0x44
+#define GPIO_NUM		0x5B
+#define GPIO_NUM_CHIP_EN	94
+#define GPIO_NUM_RESET		60
+
+#define NQUEUES			4
+#define VO_AC_COUNT_POS		25
+#define VO_AC_ACM_STAT_POS	24
+#define VI_AC_COUNT_POS		17
+#define VI_AC_ACM_STAT_POS	16
+#define BE_AC_COUNT_POS		9
+#define BE_AC_ACM_STAT_POS	8
+#define BK_AC_COUNT_POS		2
+#define BK_AC_ACM_STAT_POS	1
+#define AC_BUFFER_SIZE		1000
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
 /*******************************************/
@@ -155,8 +184,7 @@
 #define INT_2			BIT(IRG_FLAGS_OFFSET + 2)
 #define INT_3			BIT(IRG_FLAGS_OFFSET + 3)
 #define INT_4			BIT(IRG_FLAGS_OFFSET + 4)
-#define INT_5			BIT(IRG_FLAGS_OFFSET + 5)
-#define MAX_NUM_INT		6
+#define MAX_NUM_INT		5
 
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
@@ -182,25 +210,20 @@
 #define EN_VMM			BIT(8)
 
 #define DATA_INT_EXT		INT_0
-#define PLL_INT_EXT		INT_1
-#define SLEEP_INT_EXT		INT_2
-#define ALL_INT_EXT		(DATA_INT_EXT | PLL_INT_EXT | SLEEP_INT_EXT)
-#define NUM_INT_EXT		3
+#define ALL_INT_EXT		(DATA_INT_EXT)
+#define NUM_INT_EXT		1
 
 #define DATA_INT_CLR		CLR_INT0
-#define PLL_INT_CLR		CLR_INT1
-#define SLEEP_INT_CLR		CLR_INT2
 
 #define ENABLE_RX_VMM		(SEL_VMM_TBL1 | EN_VMM)
 #define ENABLE_TX_VMM		(SEL_VMM_TBL0 | EN_VMM)
 /*time for expiring the completion of cfg packets*/
-#define CFG_PKTS_TIMEOUT	2000
-/********************************************
- *
- *      Debug Type
- *
- ********************************************/
-typedef void (*wilc_debug_func)(u32, char *, ...);
+#define CFG_PKTS_TIMEOUT	3000
+
+#define IS_MANAGMEMENT		0x100
+#define IS_MANAGMEMENT_CALLBACK	0x080
+#define IS_MGMT_STATUS_SUCCES	0x040
+#define IS_MON_PKT		0x020
 
 /********************************************
  *
@@ -208,24 +231,42 @@ typedef void (*wilc_debug_func)(u32, char *, ...);
  *
  ********************************************/
 
+enum ip_pkt_priority {
+	AC_VO_Q = 0,
+	AC_VI_Q = 1,
+	AC_BE_Q = 2,
+	AC_BK_Q = 3
+};
+
 struct txq_entry_t {
-	struct txq_entry_t *next;
-	struct txq_entry_t *prev;
+	struct list_head list;
 	int type;
-	int tcp_pending_ack_idx;
+	u8 q_num;
+	int ack_idx;
 	u8 *buffer;
 	int buffer_size;
 	void *priv;
 	int status;
-	void (*tx_complete_func)(void *, int);
+	void (*tx_complete_func)(void *priv, int status);
+};
+
+struct txq_handle {
+	struct txq_entry_t txq_head;
+	u16 count;
+	u8 acm;
 };
 
 struct rxq_entry_t {
-	struct rxq_entry_t *next;
+	struct list_head list;
 	u8 *buffer;
 	int buffer_size;
 };
 
+enum wilc_chip_type {
+	WILC_1000,
+	WILC_3000,
+};
+
 /********************************************
  *
  *      Host IF Structure
@@ -233,34 +274,27 @@ struct rxq_entry_t {
  ********************************************/
 struct wilc;
 struct wilc_hif_func {
-	int (*hif_init)(struct wilc *, bool resume);
-	int (*hif_deinit)(struct wilc *);
-	int (*hif_read_reg)(struct wilc *, u32, u32 *);
-	int (*hif_write_reg)(struct wilc *, u32, u32);
-	int (*hif_block_rx)(struct wilc *, u32, u8 *, u32);
-	int (*hif_block_tx)(struct wilc *, u32, u8 *, u32);
-	int (*hif_read_int)(struct wilc *, u32 *);
-	int (*hif_clear_int_ext)(struct wilc *, u32);
-	int (*hif_read_size)(struct wilc *, u32 *);
-	int (*hif_block_tx_ext)(struct wilc *, u32, u8 *, u32);
-	int (*hif_block_rx_ext)(struct wilc *, u32, u8 *, u32);
-	int (*hif_sync_ext)(struct wilc *, int);
+	int (*hif_init)(struct wilc *wilc, bool resume);
+	int (*hif_deinit)(struct wilc *wilc);
+	int (*hif_read_reg)(struct wilc *wilc, u32 addr, u32 *data);
+	int (*hif_write_reg)(struct wilc *wilc, u32 addr, u32 data);
+	int (*hif_block_rx)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_block_tx)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_read_int)(struct wilc *wilc, u32 *int_status);
+	int (*hif_clear_int_ext)(struct wilc *wilc, u32 val);
+	int (*hif_read_size)(struct wilc *wilc, u32 *size);
+	int (*hif_block_tx_ext)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_block_rx_ext)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_sync_ext)(struct wilc *wilc, int nint);
 	int (*enable_interrupt)(struct wilc *nic);
 	void (*disable_interrupt)(struct wilc *nic);
+	int (*hif_reset)(struct wilc *wilc);
+	bool (*hif_is_init)(struct wilc *wilc);
 };
 
-/********************************************
- *
- *      Configuration Structure
- *
- ********************************************/
-
 #define MAX_CFG_FRAME_SIZE	1468
 
 struct wilc_cfg_frame {
-	u8 ether_header[14];
-	u8 ip_header[20];
-	u8 udp_header[8];
 	u8 wid_header[8];
 	u8 frame[MAX_CFG_FRAME_SIZE];
 };
@@ -277,30 +311,45 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size);
 int wilc_wlan_start(struct wilc *wilc);
 int wilc_wlan_stop(struct wilc *wilc);
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			      u32 buffer_size, wilc_tx_complete_func_t func);
 int wilc_wlan_handle_txq(struct net_device *dev, u32 *txq_count);
 void wilc_handle_isr(struct wilc *wilc);
 void wilc_wlan_cleanup(struct net_device *dev);
-int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
+int cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		      u32 buffer_size, int commit, u32 drv_handler);
-int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
+int cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 		      u32 drv_handler);
-int wilc_wlan_cfg_get_val(u16 wid, u8 *buffer, u32 buffer_size);
-int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size);
+int txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			       u32 buffer_size, wilc_tx_complete_func_t func);
-void wilc_chip_sleep_manually(struct wilc *wilc);
 
-void wilc_enable_tcp_ack_filter(bool value);
+void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value);
 int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc);
-int wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
-
-void WILC_WFI_p2p_rx(struct net_device *dev, u8 *buff, u32 size);
-void host_wakeup_notify(struct wilc *wilc);
-void host_sleep_notify(struct wilc *wilc);
-extern bool wilc_enable_ps;
-void chip_allow_sleep(struct wilc *wilc);
-void chip_wakeup(struct wilc *wilc);
+netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
+
+void wilc_wfi_p2p_rx(struct net_device *dev, u8 *buff, u32 size);
+void host_wakeup_notify(struct wilc *wilc, int source);
+void host_sleep_notify(struct wilc *wilc, int source);
+void chip_allow_sleep(struct wilc *wilc, int source);
+void chip_wakeup(struct wilc *wilc, int source);
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count, u32 drv);
+void wilc_wlan_power_on_sequence(struct wilc *wilc);
+void wilc_wlan_power_off_sequence(struct wilc *wilc);
+
+void wilc_bt_init(struct wilc *wilc);
+void wilc_bt_deinit(void);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t);
+#else
+void eap_buff_timeout(unsigned long user);
+#endif
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source);
+void release_bus(struct wilc *wilc, enum bus_release release, int source);
+int wilc_wlan_init(struct net_device *dev);
+u32 wilc_get_chipid(struct wilc *wilc, bool update);
+void wilc_frmw_to_linux(struct wilc_vif *vif, u8 *buff, u32 size,
+				u32 pkt_offset, u8 status);
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size);
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.c b/drivers/staging/wilc1000/wilc_wlan_cfg.c
index 19e4f85fdd27..904d00e215cd 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.c
+++ b/drivers/staging/wilc1000/wilc_wlan_cfg.c
@@ -1,24 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0
-/* ////////////////////////////////////////////////////////////////////////// */
-/*  */
-/* Copyright (c) Atmel Corporation.  All rights reserved. */
-/*  */
-/* Module Name:  wilc_wlan_cfg.c */
-/*  */
-/*  */
-/* ///////////////////////////////////////////////////////////////////////// */
-
-#include <linux/string.h>
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
 #include "wilc_wlan_if.h"
 #include "wilc_wlan.h"
 #include "wilc_wlan_cfg.h"
-#include "coreconfigurator.h"
+#include "wilc_wfi_netdevice.h"
 
-/********************************************
- *
- *      Global Data
- *
- ********************************************/
 enum cfg_cmd_type {
 	CFG_BYTE_CMD	= 0,
 	CFG_HWORD_CMD	= 1,
@@ -27,134 +17,37 @@ enum cfg_cmd_type {
 	CFG_BIN_CMD	= 4
 };
 
-struct wilc_mac_cfg {
-	int mac_status;
-	u8 mac_address[7];
-	u8 ip_address[5];
-	u8 bssid[7];
-	u8 ssid[34];
-	u8 firmware_version[129];
-	u8 supp_rate[24];
-	u8 wep_key[28];
-	u8 i_psk[66];
-	u8 hw_product_version[33];
-	u8 phyversion[17];
-	u8 supp_username[21];
-	u8 supp_password[64];
-	u8 assoc_req[256];
-	u8 assoc_rsp[256];
-	u8 firmware_info[8];
-	u8 scan_result[256];
-	u8 scan_result1[256];
-};
-
-static struct wilc_mac_cfg g_mac;
-
 static struct wilc_cfg_byte g_cfg_byte[] = {
-	{WID_BSS_TYPE, 0},
-	{WID_CURRENT_TX_RATE, 0},
-	{WID_CURRENT_CHANNEL, 0},
-	{WID_PREAMBLE, 0},
-	{WID_11G_OPERATING_MODE, 0},
 	{WID_STATUS, 0},
-	{WID_SCAN_TYPE, 0},
-	{WID_KEY_ID, 0},
-	{WID_QOS_ENABLE, 0},
-	{WID_POWER_MANAGEMENT, 0},
-	{WID_11I_MODE, 0},
-	{WID_AUTH_TYPE, 0},
-	{WID_SITE_SURVEY, 0},
-	{WID_LISTEN_INTERVAL, 0},
-	{WID_DTIM_PERIOD, 0},
-	{WID_ACK_POLICY, 0},
-	{WID_BCAST_SSID, 0},
-	{WID_REKEY_POLICY, 0},
-	{WID_SHORT_SLOT_ALLOWED, 0},
-	{WID_START_SCAN_REQ, 0},
 	{WID_RSSI, 0},
 	{WID_LINKSPEED, 0},
-	{WID_AUTO_RX_SENSITIVITY, 0},
-	{WID_DATAFLOW_CONTROL, 0},
-	{WID_SCAN_FILTER, 0},
-	{WID_11N_PROT_MECH, 0},
-	{WID_11N_ERP_PROT_TYPE, 0},
-	{WID_11N_ENABLE, 0},
-	{WID_11N_OPERATING_MODE, 0},
-	{WID_11N_OBSS_NONHT_DETECTION, 0},
-	{WID_11N_HT_PROT_TYPE, 0},
-	{WID_11N_RIFS_PROT_ENABLE, 0},
-	{WID_11N_SMPS_MODE, 0},
-	{WID_11N_CURRENT_TX_MCS, 0},
-	{WID_11N_SHORT_GI_ENABLE, 0},
-	{WID_RIFS_MODE, 0},
-	{WID_TX_ABORT_CONFIG, 0},
-	{WID_11N_IMMEDIATE_BA_ENABLED, 0},
-	{WID_11N_TXOP_PROT_DISABLE, 0},
+	{WID_TX_POWER, 0},
+	{WID_WOWLAN_TRIGGER, 0},
 	{WID_NIL, 0}
 };
 
 static struct wilc_cfg_hword g_cfg_hword[] = {
-	{WID_LINK_LOSS_THRESHOLD, 0},
-	{WID_RTS_THRESHOLD, 0},
-	{WID_FRAG_THRESHOLD, 0},
-	{WID_SHORT_RETRY_LIMIT, 0},
-	{WID_LONG_RETRY_LIMIT, 0},
-	{WID_BEACON_INTERVAL, 0},
-	{WID_RX_SENSE, 0},
-	{WID_ACTIVE_SCAN_TIME, 0},
-	{WID_PASSIVE_SCAN_TIME, 0},
-	{WID_SITE_SURVEY_SCAN_TIME, 0},
-	{WID_JOIN_START_TIMEOUT, 0},
-	{WID_AUTH_TIMEOUT, 0},
-	{WID_ASOC_TIMEOUT, 0},
-	{WID_11I_PROTOCOL_TIMEOUT, 0},
-	{WID_EAPOL_RESPONSE_TIMEOUT, 0},
-	{WID_11N_SIG_QUAL_VAL, 0},
-	{WID_CCA_THRESHOLD, 0},
 	{WID_NIL, 0}
 };
 
 static struct wilc_cfg_word g_cfg_word[] = {
 	{WID_FAILED_COUNT, 0},
-	{WID_RETRY_COUNT, 0},
-	{WID_MULTIPLE_RETRY_COUNT, 0},
-	{WID_FRAME_DUPLICATE_COUNT, 0},
-	{WID_ACK_FAILURE_COUNT, 0},
 	{WID_RECEIVED_FRAGMENT_COUNT, 0},
-	{WID_MCAST_RECEIVED_FRAME_COUNT, 0},
-	{WID_FCS_ERROR_COUNT, 0},
 	{WID_SUCCESS_FRAME_COUNT, 0},
-	{WID_TX_FRAGMENT_COUNT, 0},
-	{WID_TX_MULTICAST_FRAME_COUNT, 0},
-	{WID_RTS_SUCCESS_COUNT, 0},
-	{WID_RTS_FAILURE_COUNT, 0},
-	{WID_WEP_UNDECRYPTABLE_COUNT, 0},
-	{WID_REKEY_PERIOD, 0},
-	{WID_REKEY_PACKET_COUNT, 0},
-	{WID_HW_RX_COUNT, 0},
 	{WID_GET_INACTIVE_TIME, 0},
 	{WID_NIL, 0}
 
 };
 
 static struct wilc_cfg_str g_cfg_str[] = {
-	{WID_SSID, g_mac.ssid},	/* 33 + 1 bytes */
-	{WID_FIRMWARE_VERSION, g_mac.firmware_version},
-	{WID_OPERATIONAL_RATE_SET, g_mac.supp_rate},
-	{WID_BSSID, g_mac.bssid},	/* 6 bytes */
-	{WID_WEP_KEY_VALUE, g_mac.wep_key},	/* 27 bytes */
-	{WID_11I_PSK, g_mac.i_psk},	/* 65 bytes */
-	{WID_HARDWARE_VERSION, g_mac.hw_product_version},
-	{WID_MAC_ADDR, g_mac.mac_address},
-	{WID_PHY_VERSION, g_mac.phyversion},
-	{WID_SUPP_USERNAME, g_mac.supp_username},
-	{WID_SUPP_PASSWORD, g_mac.supp_password},
-	{WID_SITE_SURVEY_RESULTS, g_mac.scan_result},
-	{WID_SITE_SURVEY_RESULTS, g_mac.scan_result1},
-	{WID_ASSOC_REQ_INFO, g_mac.assoc_req},
-	{WID_ASSOC_RES_INFO, g_mac.assoc_rsp},
-	{WID_FIRMWARE_INFO, g_mac.firmware_version},
-	{WID_IP_ADDRESS, g_mac.ip_address},
+	{WID_FIRMWARE_VERSION, NULL},
+	{WID_MAC_ADDR, NULL},
+	{WID_ASSOC_RES_INFO, NULL},
+	{WID_NIL, NULL}
+};
+
+static struct wilc_cfg_bin g_cfg_bin[] = {
+	{WID_ANTENNA_SELECTION, NULL},
 	{WID_NIL, NULL}
 };
 
@@ -221,7 +114,8 @@ static int wilc_wlan_cfg_set_word(u8 *frame, u32 offset, u16 id, u32 val32)
 	return 8;
 }
 
-static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str, u32 size)
+static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str,
+				 u32 size)
 {
 	u8 *buf;
 
@@ -235,7 +129,7 @@ static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str, u32 siz
 	buf[2] = (u8)size;
 	buf[3] = (u8)(size >> 8);
 
-	if ((str) && (size != 0))
+	if (str && size != 0)
 		memcpy(&buf[4], str, size);
 
 	return (size + 4);
@@ -256,7 +150,7 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
 	buf[2] = (u8)size;
 	buf[3] = (u8)(size >> 8);
 
-	if ((b) && (size != 0)) {
+	if ((b) && size != 0) {
 		memcpy(&buf[4], b, size);
 		for (i = 0; i < size; i++)
 			checksum += buf[i + 4];
@@ -273,23 +167,28 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
  *
  ********************************************/
 
-static void wilc_wlan_parse_response_frame(u8 *info, int size)
+#define GET_WID_TYPE(wid)		(((wid) >> 12) & 0x7)
+static void wilc_wlan_parse_response_frame(struct wilc *wl, u8 *info,
+					   int size)
 {
-	u32 wid, len = 0, i = 0;
+	u16 wid;
+	u32 len = 0, i = 0;
+	struct wilc_vif *vif = wl->vif[0];
 
 	while (size > 0) {
 		i = 0;
 		wid = info[0] | (info[1] << 8);
-		wid = cpu_to_le32(wid);
 
-		switch ((wid >> 12) & 0x7) {
+		PRINT_D(vif->ndev, GENERIC_DBG, "Processing response for %d\n",
+			wid);
+		switch (GET_WID_TYPE(wid)) {
 		case WID_CHAR:
 			do {
-				if (g_cfg_byte[i].id == WID_NIL)
+				if (wl->cfg.b[i].id == WID_NIL)
 					break;
 
-				if (g_cfg_byte[i].id == wid) {
-					g_cfg_byte[i].val = info[4];
+				if (wl->cfg.b[i].id == wid) {
+					wl->cfg.b[i].val = info[4];
 					break;
 				}
 				i++;
@@ -299,13 +198,12 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 
 		case WID_SHORT:
 			do {
-				if (g_cfg_hword[i].id == WID_NIL)
+				if (wl->cfg.hw[i].id == WID_NIL)
 					break;
 
-				if (g_cfg_hword[i].id == wid) {
-					g_cfg_hword[i].val =
-						cpu_to_le16(info[4] |
-							    (info[5] << 8));
+				if (wl->cfg.hw[i].id == wid) {
+					wl->cfg.hw[i].val = (info[4] |
+							      (info[5] << 8));
 					break;
 				}
 				i++;
@@ -315,15 +213,14 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 
 		case WID_INT:
 			do {
-				if (g_cfg_word[i].id == WID_NIL)
+				if (wl->cfg.w[i].id == WID_NIL)
 					break;
 
-				if (g_cfg_word[i].id == wid) {
-					g_cfg_word[i].val =
-						cpu_to_le32(info[4] |
-							    (info[5] << 8) |
-							    (info[6] << 16) |
-							    (info[7] << 24));
+				if (wl->cfg.w[i].id == wid) {
+					wl->cfg.hw[i].val = (info[4] |
+							     (info[5] << 8) |
+							     (info[6] << 16) |
+							     (info[7] << 24));
 					break;
 				}
 				i++;
@@ -333,25 +230,58 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 
 		case WID_STR:
 			do {
-				if (g_cfg_str[i].id == WID_NIL)
+				if (wl->cfg.s[i].id == WID_NIL)
 					break;
 
-				if (g_cfg_str[i].id == wid) {
-					if (wid == WID_SITE_SURVEY_RESULTS) {
-						static int toggle;
-
-						i += toggle;
-						toggle ^= 1;
-					}
-					memcpy(g_cfg_str[i].str, &info[2],
-					       (info[2] + 2));
+				if (wl->cfg.s[i].id == wid) {
+					memcpy(wl->cfg.s[i].str, &info[2],
+					       (2+((info[3] << 8) | info[2])));
 					break;
 				}
 				i++;
 			} while (1);
-			len = 2 + info[2];
+			len = 2+((info[3] << 8) | info[2]);
 			break;
+		case WID_BIN_DATA:
+			do {
+				uint16_t length = (info[3] << 8) |
+				info[2];
+				uint8_t  checksum = 0;
+				uint16_t i = 0;
 
+				if (wl->cfg.bin[i].id == WID_NIL)
+					break;
+
+				if (wl->cfg.bin[i].id != wid) {
+					i++;
+					continue;
+				}
+
+				/*
+				 * Compute the Checksum of received
+				 * data field
+				 */
+				for (i = 0; i < length; i++)
+					checksum += info[4 + i];
+				/*
+				 * Verify the checksum of recieved BIN
+				 * DATA
+				 */
+				if (checksum != info[4 + length]) {
+					PRINT_ER(vif->ndev, "Checksum Failed");
+					return;
+				}
+
+				memcpy(wl->cfg.bin[i].bin, &info[2], length+2);
+				/*
+				 * value length + data length +
+				 * checksum
+				 */
+				len = 2 + length + 1;
+				break;
+
+			} while (1);
+			break;
 		default:
 			break;
 		}
@@ -360,22 +290,30 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 	}
 }
 
-static int wilc_wlan_parse_info_frame(u8 *info, int size)
+static void wilc_wlan_parse_info_frame(struct wilc *wl, u8 *info)
 {
-	struct wilc_mac_cfg *pd = &g_mac;
+	struct wilc_vif *vif = wl->vif[0];
 	u32 wid, len;
-	int type = WILC_CFG_RSP_STATUS;
 
 	wid = info[0] | (info[1] << 8);
 
 	len = info[2];
+	PRINT_D(vif->ndev, GENERIC_DBG, "Status Len = %d Id= %d\n", len, wid);
 
-	if ((len == 1) && (wid == WID_STATUS)) {
-		pd->mac_status = info[3];
-		type = WILC_CFG_RSP_STATUS;
-	}
+	if (len == 1 && wid == WID_STATUS) {
+		int i = 0;
+
+		do {
+			if (wl->cfg.b[i].id == WID_NIL)
+				break;
 
-	return type;
+			if (wl->cfg.b[i].id == wid) {
+				wl->cfg.b[i].val = info[3];
+				break;
+			}
+			i++;
+		} while (1);
+	}
 }
 
 /********************************************
@@ -384,7 +322,8 @@ static int wilc_wlan_parse_info_frame(u8 *info, int size)
  *
  ********************************************/
 
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
+int cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id, u8 *buf,
+			  int size)
 {
 	u8 type = (id >> 12) & 0xf;
 	int ret = 0;
@@ -414,12 +353,14 @@ int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
 	case CFG_BIN_CMD:
 		ret = wilc_wlan_cfg_set_bin(frame, offset, id, buf, size);
 		break;
+	default:
+		PRINT_ER(vif->ndev, "illegal id\n");
 	}
 
 	return ret;
 }
 
-int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id)
+int cfg_get_wid(u8 *frame, u32 offset, u16 id)
 {
 	u8 *buf;
 
@@ -434,24 +375,19 @@ int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id)
 	return 2;
 }
 
-int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
+int cfg_get_wid_value(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size)
 {
 	u32 type = (wid >> 12) & 0xf;
 	int i, ret = 0;
 
-	if (wid == WID_STATUS) {
-		*((u32 *)buffer) = g_mac.mac_status;
-		return 4;
-	}
-
 	i = 0;
 	if (type == CFG_BYTE_CMD) {
 		do {
-			if (g_cfg_byte[i].id == WID_NIL)
+			if (wl->cfg.b[i].id == WID_NIL)
 				break;
 
-			if (g_cfg_byte[i].id == wid) {
-				memcpy(buffer,  &g_cfg_byte[i].val, 1);
+			if (wl->cfg.b[i].id == wid) {
+				memcpy(buffer,  &wl->cfg.b[i].val, 1);
 				ret = 1;
 				break;
 			}
@@ -459,11 +395,11 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 		} while (1);
 	} else if (type == CFG_HWORD_CMD) {
 		do {
-			if (g_cfg_hword[i].id == WID_NIL)
+			if (wl->cfg.hw[i].id == WID_NIL)
 				break;
 
-			if (g_cfg_hword[i].id == wid) {
-				memcpy(buffer,  &g_cfg_hword[i].val, 2);
+			if (wl->cfg.hw[i].id == wid) {
+				memcpy(buffer,  &wl->cfg.hw[i].val, 2);
 				ret = 2;
 				break;
 			}
@@ -471,11 +407,11 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 		} while (1);
 	} else if (type == CFG_WORD_CMD) {
 		do {
-			if (g_cfg_word[i].id == WID_NIL)
+			if (wl->cfg.w[i].id == WID_NIL)
 				break;
 
-			if (g_cfg_word[i].id == wid) {
-				memcpy(buffer,  &g_cfg_word[i].val, 4);
+			if (wl->cfg.w[i].id == wid) {
+				memcpy(buffer,  &wl->cfg.w[i].val, 4);
 				ret = 4;
 				break;
 			}
@@ -483,22 +419,17 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 		} while (1);
 	} else if (type == CFG_STR_CMD) {
 		do {
-			if (g_cfg_str[i].id == WID_NIL)
+			u32 id = wl->cfg.s[i].id;
+
+			if (id == WID_NIL)
 				break;
 
-			if (g_cfg_str[i].id == wid) {
-				u32 size = g_cfg_str[i].str[0] |
-						(g_cfg_str[i].str[1] << 8);
+			if (id == wid) {
+				u32 size = wl->cfg.s[i].str[0] |
+						(wl->cfg.s[i].str[1] << 8);
 
 				if (buffer_size >= size) {
-					if (g_cfg_str[i].id == WID_SITE_SURVEY_RESULTS)	{
-						static int toggle;
-
-						i += toggle;
-						toggle ^= 1;
-
-					}
-					memcpy(buffer,  &g_cfg_str[i].str[2],
+					memcpy(buffer,  &wl->cfg.s[i].str[2],
 					       size);
 					ret = size;
 				}
@@ -506,15 +437,33 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 			}
 			i++;
 		} while (1);
+	} else if (type == CFG_BIN_CMD) { /* binary command */
+		do {
+			if (wl->cfg.bin[i].id == WID_NIL)
+				break;
+
+			if (wl->cfg.bin[i].id == wid) {
+				uint32_t size = wl->cfg.bin[i].bin[0] |
+					     (wl->cfg.bin[i].bin[1]<<8);
+				if (buffer_size >= size) {
+					memcpy(buffer, &wl->cfg.bin[i].bin[2],
+						size);
+					ret = size;
+				}
+				break;
+			}
+			i++;
+		} while (1);
+	} else {
+		PRINT_ER(wl->vif[0]->ndev, "[CFG]: illegal type (%08x)\n", wid);
 	}
 
 	return ret;
 }
 
-int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
-			      struct wilc_cfg_rsp *rsp)
+void cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
+			       struct wilc_cfg_rsp *rsp)
 {
-	int ret = 1;
 	u8 msg_type;
 	u8 msg_id;
 
@@ -522,46 +471,134 @@ int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 	msg_id = frame[1];      /* seq no */
 	frame += 4;
 	size -= 4;
+	rsp->type = 0;
 
-	/**
-	 *      The  valid types of response messages are 'R' (Response), 'I' (Information), and 'N' (Network Information)
-	 **/
+	/*
+	 * The valid types of response messages are
+	 * 'R' (Response),
+	 * 'I' (Information), and
+	 * 'N' (Network Information)
+	 */
 
 	switch (msg_type) {
 	case 'R':
-		wilc_wlan_parse_response_frame(frame, size);
+		wilc_wlan_parse_response_frame(wilc, frame, size);
 		rsp->type = WILC_CFG_RSP;
 		rsp->seq_no = msg_id;
 		break;
 
 	case 'I':
-		rsp->type = wilc_wlan_parse_info_frame(frame, size);
+		wilc_wlan_parse_info_frame(wilc, frame);
+		rsp->type = WILC_CFG_RSP_STATUS;
 		rsp->seq_no = msg_id;
 		/*call host interface info parse as well*/
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG, "Info message received\n");
 		wilc_gnrl_async_info_received(wilc, frame - 4, size + 4);
 		break;
 
 	case 'N':
 		wilc_network_info_received(wilc, frame - 4, size + 4);
-		rsp->type = 0;
 		break;
 
 	case 'S':
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG,
+			"Scan Notification Received\n");
 		wilc_scan_complete_received(wilc, frame - 4, size + 4);
 		break;
 
 	default:
-		rsp->type = 0;
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG,
+			"Receive unknown message %d-%d-%d-%d-%d-%d-%d-%d\n",
+			 frame[0], frame[1], frame[2], frame[3], frame[4],
+			 frame[5], frame[6], frame[7]);
 		rsp->seq_no = msg_id;
-		ret = 0;
 		break;
 	}
+}
 
-	return ret;
+int cfg_init(struct wilc *wl)
+{
+	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_bin_vals *bin_vals;
+	int i = 0;
+
+	wl->cfg.b = kmemdup(g_cfg_byte, sizeof(g_cfg_byte), GFP_KERNEL);
+	if (!wl->cfg.b)
+		return -ENOMEM;
+
+	wl->cfg.hw = kmemdup(g_cfg_hword, sizeof(g_cfg_hword), GFP_KERNEL);
+	if (!wl->cfg.hw)
+		goto out_b;
+
+	wl->cfg.w = kmemdup(g_cfg_word, sizeof(g_cfg_word), GFP_KERNEL);
+	if (!wl->cfg.w)
+		goto out_hw;
+
+	wl->cfg.s = kmemdup(g_cfg_str, sizeof(g_cfg_str), GFP_KERNEL);
+	if (!wl->cfg.s)
+		goto out_w;
+
+	str_vals = kzalloc(sizeof(*str_vals), GFP_KERNEL);
+	if (!str_vals)
+		goto out_s;
+
+
+	wl->cfg.bin = kmemdup(g_cfg_bin, sizeof(g_cfg_bin), GFP_KERNEL);
+	if (!wl->cfg.bin)
+		goto out_str_val;
+
+	bin_vals = kzalloc(sizeof(*bin_vals), GFP_KERNEL);
+	if (!bin_vals)
+		goto out_bin;
+
+	/* store the string cfg parameters */
+	wl->cfg.str_vals = str_vals;
+	wl->cfg.s[i].id = WID_FIRMWARE_VERSION;
+	wl->cfg.s[i].str = str_vals->firmware_version;
+	i++;
+	wl->cfg.s[i].id = WID_MAC_ADDR;
+	wl->cfg.s[i].str = str_vals->mac_address;
+	i++;
+	wl->cfg.s[i].id = WID_ASSOC_RES_INFO;
+	wl->cfg.s[i].str = str_vals->assoc_rsp;
+	i++;
+	wl->cfg.s[i].id = WID_NIL;
+	wl->cfg.s[i].str = NULL;
+
+	/* store the bin parameters */
+	i = 0;
+	wl->cfg.bin[i].id = WID_ANTENNA_SELECTION;
+	wl->cfg.bin[i].bin = bin_vals->antenna_param;
+	i++;
+
+	wl->cfg.bin[i].id = WID_NIL;
+	wl->cfg.bin[i].bin = NULL;
+
+	return 0;
+
+out_bin:
+	kfree(wl->cfg.bin);
+out_str_val:
+	kfree(str_vals);
+out_s:
+	kfree(wl->cfg.s);
+out_w:
+	kfree(wl->cfg.w);
+out_hw:
+	kfree(wl->cfg.hw);
+out_b:
+	kfree(wl->cfg.b);
+	return -ENOMEM;
 }
 
-int wilc_wlan_cfg_init(void)
+void cfg_deinit(struct wilc *wl)
 {
-	memset((void *)&g_mac, 0, sizeof(struct wilc_mac_cfg));
-	return 1;
+	kfree(wl->cfg.b);
+	kfree(wl->cfg.hw);
+	kfree(wl->cfg.w);
+	kfree(wl->cfg.s);
+	kfree(wl->cfg.str_vals);
+	kfree(wl->cfg.bin);
+	kfree(wl->cfg.bin_vals);
 }
+
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.h b/drivers/staging/wilc1000/wilc_wlan_cfg.h
index 08092a551840..3f78a154f973 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.h
+++ b/drivers/staging/wilc1000/wilc_wlan_cfg.h
@@ -1,19 +1,15 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* ////////////////////////////////////////////////////////////////////////// */
-/*  */
-/* Copyright (c) Atmel Corporation.  All rights reserved. */
-/*  */
-/* Module Name:  wilc_wlan_cfg.h */
-/*  */
-/*  */
-/* ///////////////////////////////////////////////////////////////////////// */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
 
 #ifndef WILC_WLAN_CFG_H
 #define WILC_WLAN_CFG_H
 
 struct wilc_cfg_byte {
 	u16 id;
-	u16 val;
+	u8 val;
 };
 
 struct wilc_cfg_hword {
@@ -27,16 +23,43 @@ struct wilc_cfg_word {
 };
 
 struct wilc_cfg_str {
-	u32 id;
+	u16 id;
 	u8 *str;
 };
 
+struct wilc_cfg_bin {
+	u16 id;
+	u8 *bin;
+};
+
+struct wilc_cfg_str_vals {
+	u8 mac_address[7];
+	u8 firmware_version[129];
+	u8 assoc_rsp[256];
+};
+
+struct wilc_bin_vals {
+	u8 antenna_param[5];
+};
+
+struct wilc_cfg {
+	struct wilc_cfg_byte *b;
+	struct wilc_cfg_hword *hw;
+	struct wilc_cfg_word *w;
+	struct wilc_cfg_str *s;
+	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_cfg_bin *bin;
+	struct wilc_bin_vals *bin_vals;
+};
+
 struct wilc;
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size);
-int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id);
-int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size);
-int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
-			      struct wilc_cfg_rsp *rsp);
-int wilc_wlan_cfg_init(void);
+int cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id, u8 *buf,
+		int size);
+int cfg_get_wid(u8 *frame, u32 offset, u16 id);
+int cfg_get_wid_value(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size);
+void cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
+			       struct wilc_cfg_rsp *rsp);
+int cfg_init(struct wilc *wl);
+void cfg_deinit(struct wilc *wl);
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan_if.h b/drivers/staging/wilc1000/wilc_wlan_if.h
index c1693cfc076d..e7764eb0ba55 100644
--- a/drivers/staging/wilc1000/wilc_wlan_if.h
+++ b/drivers/staging/wilc1000/wilc_wlan_if.h
@@ -1,17 +1,14 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* ///////////////////////////////////////////////////////////////////////// */
-/*  */
-/* Copyright (c) Atmel Corporation.  All rights reserved. */
-/*  */
-/* Module Name:  wilc_wlan_if.h */
-/*  */
-/*  */
-/* ///////////////////////////////////////////////////////////////////////// */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
 
 #ifndef WILC_WLAN_IF_H
 #define WILC_WLAN_IF_H
 
 #include <linux/netdevice.h>
+#include "wilc_debugfs.h"
 
 /********************************************
  *
@@ -23,6 +20,10 @@
 #define HIF_SPI			BIT(0)
 #define HIF_SDIO_GPIO_IRQ	BIT(2)
 
+#define	FW_WILC1000_WIFi		"mchp/wilc1000_wifi_firmware.bin"
+#define	FW_WILC3000_WIFI		"mchp/wilc3000_wifi_firmware.bin"
+#define	FW_WILC3000_BLE		"mchp/wilc3000_ble_firmware.bin"
+
 /********************************************
  *
  *      Wlan Interface Defines
@@ -48,18 +49,16 @@ struct sdio_cmd53 {
 	u32 block_size;
 };
 
-#define WILC_MAC_INDICATE_STATUS	0x1
-#define WILC_MAC_STATUS_INIT		-1
-#define WILC_MAC_STATUS_READY		0
-#define WILC_MAC_STATUS_CONNECT		1
-
-#define WILC_MAC_INDICATE_SCAN		0x2
+#define MAC_STATUS_INIT			-1
+#define MAC_STATUS_CONNECTED		1
+#define MAC_STATUS_DISCONNECTED		0
 
 struct tx_complete_data {
 	int size;
 	void *buff;
 	u8 *bssid;
 	struct sk_buff *skb;
+	struct wilc_vif *vif;
 };
 
 typedef void (*wilc_tx_complete_func_t)(void *, int);
@@ -75,85 +74,53 @@ typedef void (*wilc_tx_complete_func_t)(void *, int);
 #define MAX_SSID_LEN            33
 #define MAX_RATES_SUPPORTED     12
 
-typedef enum {
-	SUPP_RATES_IE		= 1,
-	EXT_SUPP_RATES_IE	= 50,
-	HT_CAPABILITY_IE	= 45,
-	RSN_IE			= 48,
-	WPA_IE			= 221,
-	WMM_IE			= 221,
-	P2P_IE			= 221,
-} BEACON_IE;
-
-typedef enum {
+enum bss_types {
 	INFRASTRUCTURE		= 0,
 	INDEPENDENT,
 	AP,
-} BSSTYPE_T;
-
-typedef enum {
-	RATE_AUTO		= 0,
-	RATE_1MB		= 1,
-	RATE_2MB		= 2,
-	RATE_5MB		= 5,
-	RATE_6MB		= 6,
-	RATE_9MB		= 9,
-	RATE_11MB		= 11,
-	RATE_12MB		= 12,
-	RATE_18MB		= 18,
-	RATE_24MB		= 24,
-	RATE_26MB		= 36,
-	RATE_48MB		= 48,
-	RATE_54MB		= 54
-} TX_RATE_T;
-
-typedef enum {
+};
+
+enum {
 	B_ONLY_MODE		= 0,    /* 1, 2 M, otherwise 5, 11 M */
 	G_ONLY_MODE,			/* 6,12,24 otherwise 9,18,36,48,54 */
 	G_MIXED_11B_1_MODE,		/* 1,2,5.5,11 otherwise all on */
 	G_MIXED_11B_2_MODE,		/* 1,2,5,11,6,12,24 otherwise all on */
-} G_OPERATING_MODE_T;
+};
 
-typedef enum {
+enum {
 	G_SHORT_PREAMBLE	= 0,	/* Short Preamble */
 	G_LONG_PREAMBLE		= 1,	/* Long Preamble */
 	G_AUTO_PREAMBLE		= 2,	/* Auto Preamble Selection */
-} G_PREAMBLE_T;
+};
 
-#define MAC_CONNECTED		1
-#define MAC_DISCONNECTED	0
+#define DEV_WIFI	0
+#define DEV_BT		1
+#define DEV_MAX		2
 
-#define SCAN_DONE		TRUE
-typedef enum {
+enum {
 	PASSIVE_SCAN		= 0,
 	ACTIVE_SCAN		= 1,
-} SCANTYPE_T;
+};
 
-typedef enum {
+enum {
 	NO_POWERSAVE		= 0,
 	MIN_FAST_PS		= 1,
 	MAX_FAST_PS		= 2,
 	MIN_PSPOLL_PS		= 3,
 	MAX_PSPOLL_PS		= 4
-} USER_PS_MODE_T;
-
-typedef enum {
-	CHIP_WAKEDUP		= 0,
-	CHIP_SLEEPING_AUTO      = 1,
-	CHIP_SLEEPING_MANUAL	= 2
-} CHIP_PS_STATE_T;
+};
 
-typedef enum {
+enum bus_acquire {
 	ACQUIRE_ONLY            = 0,
 	ACQUIRE_AND_WAKEUP	= 1,
-} BUS_ACQUIRE_T;
+};
 
-typedef enum {
+enum bus_release {
 	RELEASE_ONLY		= 0,
 	RELEASE_ALLOW_SLEEP	= 1,
-} BUS_RELEASE_T;
+};
 
-typedef enum {
+enum {
 	NO_SECURITY		= 0,
 	WEP_40			= 0x3,
 	WEP_104			= 0x7,
@@ -163,103 +130,77 @@ typedef enum {
 	WPA2_AES		= 0x31,
 	WPA2_TKIP		= 0x51,
 	WPA2_AES_TKIP		= 0x71,	/* Aes or Tkip */
-} SECURITY_T;
+};
 
-enum AUTHTYPE {
+enum authtype {
 	OPEN_SYSTEM		= 1,
 	SHARED_KEY		= 2,
 	ANY			= 3,
 	IEEE8021		= 5
 };
 
-enum SITESURVEY {
+enum site_survey {
 	SITE_SURVEY_1CH		= 0,
 	SITE_SURVEY_ALL_CH	= 1,
 	SITE_SURVEY_OFF		= 2
 };
 
-typedef enum {
+enum {
 	NORMAL_ACK		= 0,
 	NO_ACK,
-} ACK_POLICY_T;
-
-typedef enum {
-	DONT_RESET		= 0,
-	DO_RESET		= 1,
-	NO_REQUEST		= 2,
-} RESET_REQ_T;
+};
 
-typedef enum {
+enum {
 	REKEY_DISABLE		= 1,
 	REKEY_TIME_BASE,
 	REKEY_PKT_BASE,
 	REKEY_TIME_PKT_BASE
-} RSNA_REKEY_POLICY_T;
+};
 
-typedef enum {
+enum {
 	FILTER_NO		= 0x00,
 	FILTER_AP_ONLY		= 0x01,
 	FILTER_STA_ONLY		= 0x02
-} SCAN_CLASS_FITLER_T;
-
-typedef enum {
-	PRI_HIGH_RSSI		= 0x00,
-	PRI_LOW_RSSI		= 0x04,
-	PRI_DETECT		= 0x08
-} SCAN_PRI_T;
-
-typedef enum {
-	CH_FILTER_OFF		= 0x00,
-	CH_FILTER_ON		= 0x10
-} CH_FILTER_T;
+};
 
-typedef enum {
+enum {
 	AUTO_PROT		= 0,	/* Auto */
 	NO_PROT,			/* Do not use any protection */
 	ERP_PROT,			/* Protect all ERP frame exchanges */
 	HT_PROT,			/* Protect all HT frame exchanges  */
 	GF_PROT,			/* Protect all GF frame exchanges  */
-} N_PROTECTION_MODE_T;
+};
 
-typedef enum {
+enum {
 	G_SELF_CTS_PROT,
 	G_RTS_CTS_PROT,
-} G_PROTECTION_MODE_T;
+};
 
-typedef enum {
+enum {
 	HT_MIXED_MODE		= 1,
 	HT_ONLY_20MHZ_MODE,
 	HT_ONLY_20_40MHZ_MODE,
-} N_OPERATING_MODE_T;
+};
 
-typedef enum {
+enum {
 	NO_DETECT		= 0,
 	DETECT_ONLY		= 1,
 	DETECT_PROTECT		= 2,
 	DETECT_PROTECT_REPORT	= 3,
-} N_OBSS_DETECTION_T;
+};
 
-typedef enum {
+enum {
 	RTS_CTS_NONHT_PROT	= 0,	/* RTS-CTS at non-HT rate */
 	FIRST_FRAME_NONHT_PROT,		/* First frame at non-HT rate */
 	LSIG_TXOP_PROT,                 /* LSIG TXOP Protection */
 	FIRST_FRAME_MIXED_PROT,		/* First frame at Mixed format */
-} N_PROTECTION_TYPE_T;
+};
 
-typedef enum {
+enum {
 	STATIC_MODE		= 1,
 	DYNAMIC_MODE		= 2,
 	MIMO_MODE		= 3,	/* power save disable */
-} N_SMPS_MODE_T;
-
-typedef enum {
-	DISABLE_SELF_CTS,
-	ENABLE_SELF_CTS,
-	DISABLE_TX_ABORT,
-	ENABLE_TX_ABORT,
-	HW_TRIGGER_ABORT,
-	SW_TRIGGER_ABORT,
-} TX_ABORT_OPTION_T;
+};
 
 enum wid_type {
 	WID_CHAR		= 0,
@@ -268,10 +209,13 @@ enum wid_type {
 	WID_STR			= 3,
 	WID_BIN_DATA		= 4,
 	WID_BIN			= 5,
-	WID_IP			= 6,
-	WID_ADR			= 7,
-	WID_UNDEF		= 8,
-	WID_TYPE_FORCE_32BIT	= 0xFFFFFFFF
+};
+
+enum {
+	ANTENNA1		= 0,
+	ANTENNA2		= 1,
+	DIVERSITY		= 2,
+	NUM_ANT_MODE
 };
 
 struct wid {
@@ -281,7 +225,7 @@ struct wid {
 	s8 *val;
 };
 
-typedef enum {
+enum {
 	WID_NIL				= 0xffff,
 
 	/*
@@ -337,6 +281,7 @@ typedef enum {
 	 *  -----------------------------------------------------------
 	 */
 	WID_STATUS			= 0x0005,
+	WID_BT_COEX_MODE		= 0x0006,
 
 	/*
 	 *  Scan type
@@ -432,6 +377,15 @@ typedef enum {
 	 */
 	WID_ACK_POLICY			= 0x0011,
 
+	/*
+	 *  Set coex null frames transmission mode
+	 * --------------------------------------------------------------
+	 *  Configuration :   Enable	Disable
+	 *  Values to set :       1			0
+	 * --------------------------------------------------------------
+	 */
+	WID_COEX_NULL_FRAMES_MODE               = 0x0013,
+
 	/*
 	 *  Reset MAC (Set only)
 	 *  -----------------------------------------------------------
@@ -741,8 +695,9 @@ typedef enum {
 
 	WID_DEL_BEACON			= 0x00CA,
 
-	WID_LOGTerminal_Switch		= 0x00CD,
+	WID_LOG_TERMINAL_SWITCH		= 0x00CD,
 	WID_TX_POWER			= 0x00CE,
+	WID_WOWLAN_TRIGGER		= 0X00CF,
 	/*  EMAC Short WID list */
 	/*  RTS Threshold */
 	/*
@@ -766,13 +721,8 @@ typedef enum {
 	WID_LONG_RETRY_LIMIT		= 0x1003,
 	WID_BEACON_INTERVAL		= 0x1006,
 	WID_MEMORY_ACCESS_16BIT		= 0x1008,
-	WID_RX_SENSE			= 0x100B,
-	WID_ACTIVE_SCAN_TIME		= 0x100C,
-	WID_PASSIVE_SCAN_TIME		= 0x100D,
 
-	WID_SITE_SURVEY_SCAN_TIME	= 0x100E,
 	WID_JOIN_START_TIMEOUT		= 0x100F,
-	WID_AUTH_TIMEOUT		= 0x1010,
 	WID_ASOC_TIMEOUT		= 0x1011,
 	WID_11I_PROTOCOL_TIMEOUT	= 0x1012,
 	WID_EAPOL_RESPONSE_TIMEOUT	= 0x1013,
@@ -807,11 +757,8 @@ typedef enum {
 	WID_HW_RX_COUNT			= 0x2015,
 	WID_MEMORY_ADDRESS		= 0x201E,
 	WID_MEMORY_ACCESS_32BIT		= 0x201F,
-	WID_RF_REG_VAL			= 0x2021,
 
 	/* NMAC Integer WID list */
-	WID_11N_PHY_ACTIVE_REG_VAL	= 0x2080,
-
 	/* Custom Integer WID list */
 	WID_GET_INACTIVE_TIME		= 0x2084,
 	WID_SET_OPERATION_MODE		= 0X2086,
@@ -832,7 +779,6 @@ typedef enum {
 	WID_SUPP_PASSWORD		= 0x3011,
 	WID_SITE_SURVEY_RESULTS		= 0x3012,
 	WID_RX_POWER_LEVEL		= 0x3013,
-	WID_DEL_ALL_RX_BA		= 0x3014,
 	WID_SET_STA_MAC_INACTIVE_TIME	= 0x3017,
 	WID_ADD_WEP_KEY			= 0x3019,
 	WID_REMOVE_WEP_KEY		= 0x301A,
@@ -846,9 +792,9 @@ typedef enum {
 	WID_MODEL_NAME			= 0x3027, /*Added for CAPI tool */
 	WID_MODEL_NUM			= 0x3028, /*Added for CAPI tool */
 	WID_DEVICE_NAME			= 0x3029, /*Added for CAPI tool */
-	WID_SET_DRV_HANDLER		= 0x3079,
 
 	/* NMAC String WID list */
+	WID_SET_DRV_HANDLER		= 0x3079,
 	WID_11N_P_ACTION_REQ		= 0x3080,
 	WID_HUT_TEST_ID			= 0x3081,
 	WID_PMKID_INFO			= 0x3082,
@@ -886,13 +832,12 @@ typedef enum {
 
 	WID_SETUP_MULTICAST_FILTER	= 0x408b,
 
+	WID_ANTENNA_SELECTION		= 0x408c,
 	/* Miscellaneous WIDs */
 	WID_ALL				= 0x7FFE,
 	WID_MAX				= 0xFFFF
-} WID_T;
+};
 
 struct wilc;
-int wilc_wlan_init(struct net_device *dev);
-u32 wilc_get_chipid(struct wilc *wilc, bool update);
 
 #endif
